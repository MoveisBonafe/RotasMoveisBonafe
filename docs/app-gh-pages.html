<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ffc107">
    <meta name="description" content="Otimizador de Rotas Móveis Bonafé - Solução para logística e transporte, com suporte a cálculo de rotas entre múltiplos pontos, otimização de sequência, e visualização de eventos e restrições em cidades brasileiras." />
    <meta name="keywords" content="Bonafé, otimizador de rotas, problema do caixeiro viajante, logística, transporte, planejamento de rotas, otimização de entregas, Brasil, Google Maps, pedágios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas Móveis Bonafé" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas Móveis Bonafé</title>
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="apple-touch-icon" href="assets/icon-192.png">
    <link rel="manifest" href="assets/manifest.json">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            display: flex;
            height: 100vh;
            width: 100%;
            background-color: #f5f7fa;
        }
        
        /* Estilos para a barra lateral */
        .sidebar {
            width: 400px;
            padding: 20px;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            position: relative;
            z-index: 2;
        }
        
        /* Estilos para o mapa */
        .map-container {
            flex: 1;
            height: 100%;
            position: relative;
        }
        
        /* Estilos para formulários e inputs */
        .form-control, .form-select {
            margin-bottom: 15px;
            border-radius: 6px;
        }
        
        .btn-upload {
            background-color: #e9ecef;
            border-color: #ced4da;
            color: #495057;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .btn-upload:hover {
            background-color: #dde2e6;
            border-color: #bdc6d0;
        }
        
        /* Estilos para a lista de locais */
        .locations-list {
            list-style-type: none;
            padding-left: 0;
            margin: 20px 0;
        }
        
        .location-item {
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #6c757d;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .location-item:hover {
            background-color: #e9ecef;
        }
        
        .origin-point {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            font-weight: bold;
        }
        
        /* Estilos específicos para inputs de data */
        .date-inputs {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .date-input-group {
            flex: 1;
        }
        
        .date-input-group:first-child {
            margin-right: 10px;
        }
        
        /* Estilo para o botão de remover localização */
        .btn-remove {
            float: right;
            color: #dc3545;
            background: none;
            border: none;
            padding: 0 5px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .btn-remove:hover {
            color: #bd2130;
        }
        
        /* Estilo para o botão Otimizar Rota */
        #optimize-route {
            width: 100%;
            padding: 12px;
            font-weight: 600;
            margin-top: 20px;
            background-color: #ffc107;
            border-color: #ffab00;
            color: #000;
            transition: all 0.3s ease;
        }
        
        #optimize-route:hover {
            background-color: #ffab00;
            border-color: #ff9800;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 171, 0, 0.3);
        }
        
        .optimize-btn-container {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        
        /* Estilos para o modo de rota personalizada */
        .modo-rota-personalizada .location-item {
            position: relative;
            transition: background-color 0.2s;
        }
        .modo-rota-personalizada .location-item:hover {
            background-color: #fffbeb;
        }
        .btn-rota-personalizada {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px 12px;
            background-color: #f8f9fa;
            border: 1px solid #ced4da;
            border-radius: 4px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-rota-personalizada.ativo {
            background-color: #ffc107;
            border-color: #ffab00;
        }
        .btn-rota-personalizada:hover {
            background-color: #e9ecef;
        }
        .btn-rota-personalizada.ativo:hover {
            background-color: #ffab00;
        }
        .btn-mover {
            padding: 2px 4px;
            margin-right: 3px;
            background: transparent;
            border: 1px solid #ffc107;
            border-radius: 3px;
            color: #ffc107;
            font-size: 12px;
            cursor: pointer;
        }
        .btn-mover:hover {
            background-color: #fff8e1;
        }
        .controles-rota {
            display: inline-block;
            margin-right: 8px;
        }
        
        /* Estilos para abas */
        .tab-container {
            margin-top: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tabs {
            display: flex;
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            border-right: 1px solid #dee2e6;
            transition: all 0.2s ease;
        }
        
        .tab:last-child {
            border-right: none;
        }
        
        .tab.active {
            background-color: #fff;
            border-bottom: 3px solid #ffc107;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
            padding: 15px;
            background-color: white;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Estilo para o cartão de rotas alternativas */
        .route-option-card {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .route-option-card:hover {
            background-color: #f8f9fa;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .route-option-card.selected {
            background-color: #fff8e1;
            border-color: #ffc107;
        }
        
        /* Estilo para o resumo da rota */
        .route-summary {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #fff8e1;
            border: 1px solid #ffc107;
        }
        
        .route-sequence {
            margin-top: 10px;
        }
        
        .sequence-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #fff;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .sequence-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #ffc107;
            color: #000;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .sequence-name {
            flex: 1;
        }
        
        /* Estilo para título da aplicação */
        .app-title {
            margin-bottom: 25px;
            text-align: center;
            color: #333;
            font-family: 'Poppins', sans-serif;
            position: relative;
            padding-bottom: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .app-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, #000000, #ffc107);
            border-radius: 3px;
        }
        
        .app-title-text {
            font-size: 22px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 0;
        }
        
        .app-title-highlight {
            font-size: 20px;
            font-weight: 700;
            color: #ffc107;
            margin-top: 2px;
        }
        
        /* Animações */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        /* Estilos de responsividade */
        @media (max-width: 992px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 50vh;
            }
            
            .map-container {
                height: 50vh;
            }
        }
        
        /* Estilos para notificações */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notification.success {
            background-color: #28a745;
        }
        
        .notification.error {
            background-color: #dc3545;
        }
        
        .notification.info {
            background-color: #17a2b8;
        }
        
        .notification.warning {
            background-color: #ffc107;
            color: #212529;
        }
        
        /* Estilo para o título do resumo da rota */
        .route-summary-title {
            color: #000;
            font-weight: 700;
            font-size: 16px;
            margin-bottom: 15px;
            font-family: 'Poppins', sans-serif;
        }
        
        /* Estilos para eventos, pontos de interesse e restrições */
        .event-item, .poi-item, .restriction-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .event-item {
            background-color: #f8f9fa;
            border-left: 4px solid #17a2b8;
        }
        
        .poi-item {
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
        }
        
        .restriction-item {
            background-color: #f8f9fa;
            border-left: 4px solid #dc3545;
        }
        
        .event-date, .poi-type, .restriction-type {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .event-city, .poi-city, .restriction-city {
            font-weight: 500;
            color: #343a40;
        }
        
        .event-name, .poi-name, .restriction-description {
            color: #000;
        }
        
        /* Estilos para o modo de upload de arquivo */
        .file-upload-area {
            border: 2px dashed #ced4da;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        .file-upload-area:hover, .file-upload-area.dragover {
            border-color: #ffc107;
            background-color: #fff8e1;
        }
        
        .file-upload-icon {
            font-size: 24px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .file-upload-text {
            color: #495057;
            font-size: 14px;
        }
        
        #file-upload {
            display: none;
        }
        
        /* Estilo específico para o campo de entrada de endereço */
        .pac-container {
            z-index: 9999;
            border-radius: 8px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        
        .address-input-container {
            position: relative;
        }
        
        .address-input-container .form-control {
            padding-right: 40px;
        }
        
        .address-input-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div id="app-container" class="app-container">
        <!-- Barra lateral -->
        <div class="sidebar">
            <div class="app-title">
                <div class="app-title-text">Otimizador de Rotas</div>
                <div class="app-title-highlight">Móveis Bonafé</div>
            </div>
            
            <!-- Formulário de entrada de datas -->
            <div class="date-inputs">
                <div class="date-input-group">
                    <label for="start-date" class="form-label">Data Inicial</label>
                    <input type="date" id="start-date" class="form-control">
                </div>
                <div class="date-input-group">
                    <label for="end-date" class="form-label">Data Final</label>
                    <input type="date" id="end-date" class="form-control">
                </div>
            </div>
            
            <!-- Origem fixada em Dois Córregos -->
            <div class="locations-section">
                <h6 class="mb-3">Origem</h6>
                <ul id="locations-list" class="locations-list">
                    <li class="location-item origin-point" data-id="origin">
                        <i class="bi bi-geo-alt-fill me-2"></i>
                        <span>Dois Córregos, SP</span>
                    </li>
                </ul>
            </div>
            
            <!-- Formulário para adicionar locais -->
            <div class="address-input-container">
                <label for="address-input" class="form-label">Destinos</label>
                <input type="text" id="address-input" class="form-control" placeholder="Digite o endereço">
                <i class="bi bi-search address-input-icon"></i>
            </div>
            
            <!-- Botão para adicionar local -->
            <button id="add-location" class="btn btn-primary mb-3 w-100">Adicionar Local</button>
            
            <!-- Área de upload de arquivo -->
            <div id="file-upload-area" class="file-upload-area">
                <div class="file-upload-icon">
                    <i class="bi bi-file-earmark-text"></i>
                </div>
                <div class="file-upload-text">
                    Arraste um arquivo de CEPs ou clique para selecionar
                </div>
                <input type="file" id="file-upload" accept=".txt,.csv">
            </div>
            
            <!-- Lista de localizações adicionadas -->
            <div class="destinations-section">
                <h6 class="mb-3">Localizações Adicionadas</h6>
                <ul id="destinations-list" class="locations-list">
                    <!-- Locais adicionados serão inseridos aqui -->
                </ul>
            </div>
            
            <!-- Botão para otimizar rota -->
            <div class="optimize-btn-container">
                <button id="optimize-route" class="btn btn-warning">Otimizar Rota</button>
            </div>

            <!-- Botão de Rota Personalizada -->
            <button id="custom-route-btn" class="btn-rota-personalizada">Rota Personalizada</button>
            
            <!-- Resumo da rota otimizada -->
            <div id="route-info" class="route-summary" style="display: none;">
                <div class="route-summary-title">Resumo da Rota</div>
                <div id="route-details">
                    <!-- Detalhes da rota serão inseridos aqui -->
                </div>
                <div id="route-sequence" class="route-sequence">
                    <!-- Sequência de paradas será inserida aqui -->
                </div>
            </div>
            
            <!-- Abas para informações adicionais -->
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" data-tab="events">Eventos</div>
                    <div class="tab" data-tab="restrictions">Restrições</div>
                    <div class="tab" data-tab="pois">Pedágios/Balanças</div>
                </div>
                
                <div class="tab-content active" id="events-tab">
                    <!-- Conteúdo da aba de eventos -->
                    <div id="events-content">
                        <p>Selecione uma rota para ver os eventos nas cidades.</p>
                    </div>
                </div>
                
                <div class="tab-content" id="restrictions-tab">
                    <!-- Conteúdo da aba de restrições -->
                    <div id="restrictions-content">
                        <p>Selecione uma rota para ver as restrições de tráfego.</p>
                    </div>
                </div>
                
                <div class="tab-content" id="pois-tab">
                    <!-- Conteúdo da aba de pontos de interesse -->
                    <div id="pois-content">
                        <p>Selecione uma rota para ver os pedágios e balanças.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div id="map-container" class="map-container">
            <div id="map" style="width: 100%; height: 100%;"></div>
        </div>
    </div>
    
    <!-- Container para notificações -->
    <div id="notification" class="notification"></div>
    
    <!-- Scripts externos -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
    // Dados globais
    let map;
    let directionsService;
    let directionsRenderer;
    let placesService;
    let autocomplete;
    let markers = [];
    let polylines = [];
    let routeResults = null;
    let currentOptimizedPath = [];
    let locations = [];
    let origin = {
        id: 'origin',
        name: 'Dois Córregos',
        address: 'Dois Córregos, SP',
        lat: -22.3642,
        lng: -48.3804,
        isOrigin: true
    };
    
    // Dados de mockup
    const mockData = {
        // Eventos em cidades
        cityEvents: [
            { id: 1, cityName: 'Dois Córregos', name: 'Aniversário da Cidade', date: '2023-12-15', description: 'Fundada em 15 de dezembro de 1883.' },
            { id: 2, cityName: 'Jaú', name: 'Aniversário da Cidade', date: '2023-08-15', description: 'Fundada em 15 de agosto de 1853.' },
            { id: 3, cityName: 'Bauru', name: 'Festa do Sanduíche Bauru', date: '2023-07-20', description: 'Festival gastronômico em homenagem ao famoso sanduíche.' },
            { id: 4, cityName: 'Barra Bonita', name: 'Festival Náutico', date: '2023-09-10', description: 'Competições e exposições de embarcações no Rio Tietê.' },
            { id: 5, cityName: 'Brotas', name: 'Festival de Esportes Radicais', date: '2023-06-25', description: 'Competições de rafting, rapel e outros esportes de aventura.' },
            { id: 6, cityName: 'Piracicaba', name: 'Festival da Pamonha', date: '2023-07-05', description: 'Celebrações culinárias com pratos à base de milho.' },
            { id: 7, cityName: 'Pirassununga', name: 'Festa do Peão', date: '2023-08-05', description: 'Rodeio e apresentações musicais.' },
            { id: 8, cityName: 'São Carlos', name: 'Feira de Tecnologia', date: '2023-09-20', description: 'Exposição de inovações tecnológicas desenvolvidas na região.' }
        ],
        
        // Restrições de tráfego para caminhões
        truckRestrictions: [
            { id: 1, cityName: 'Dois Córregos', description: 'Restrição de caminhões acima de 2 eixos no centro entre 8h e 18h em dias úteis.', restrictionType: 'time' },
            { id: 2, cityName: 'Jaú', description: 'Proibida a circulação de caminhões acima de 4 toneladas no centro histórico.', restrictionType: 'weight' },
            { id: 3, cityName: 'Bauru', description: 'Tráfego de caminhões restrito nas principais avenidas entre 7h e 20h.', restrictionType: 'time' },
            { id: 4, cityName: 'São Carlos', description: 'Caminhões de grande porte devem utilizar o anel viário.', restrictionType: 'route' },
            { id: 5, cityName: 'Piracicaba', description: 'Restrição de circulação de caminhões no centro entre 7h e 19h.', restrictionType: 'time' },
            { id: 6, cityName: 'Campinas', description: 'Caminhões proibidos no centro expandido entre 7h e 20h em dias úteis.', restrictionType: 'time' }
        ],
        
        // Pontos de interesse (pedágios e balanças)
        pointsOfInterest: [
            { id: 1, name: 'Pedágio SP-225 (Brotas)', type: 'toll', lat: -22.2793, lng: -48.1285, description: 'R$ 8,50 para automóveis e R$ 8,50 por eixo para caminhões.' },
            { id: 2, name: 'Pedágio SP-225 (Jaú)', type: 'toll', lat: -22.3003, lng: -48.5420, description: 'R$ 9,30 para automóveis e R$ 9,30 por eixo para caminhões.' },
            { id: 3, name: 'Pedágio SP-310 (Itirapina)', type: 'toll', lat: -22.1726, lng: -47.8550, description: 'R$ 10,50 para automóveis e R$ 10,50 por eixo para caminhões.' },
            { id: 4, name: 'Pedágio SP-304 (Santa Maria da Serra)', type: 'toll', lat: -22.5707, lng: -48.1630, description: 'R$ 7,90 para automóveis e R$ 7,90 por eixo para caminhões.' },
            { id: 5, name: 'Balança SP-225 (Km 177)', type: 'weight_station', lat: -22.3285, lng: -48.4250, description: 'Operação 24h. Fiscalização de peso por eixo e PBT.' },
            { id: 6, name: 'Balança SP-310 (Km 221)', type: 'weight_station', lat: -22.1510, lng: -47.7720, description: 'Operação em horário comercial. Verificação de nota fiscal e excesso de peso.' },
            { id: 7, name: 'Posto da Polícia Rodoviária SP-225', type: 'police', lat: -22.2967, lng: -48.2340, description: 'Posto de fiscalização da Polícia Rodoviária Estadual.' }
        ],
        
        // Tipos de veículos
        vehicleTypes: [
            { id: 1, name: 'Caminhão 1 eixo', type: 'truck1', description: 'Caminhão pequeno com 1 eixo.' },
            { id: 2, name: 'Caminhão 2 eixos', type: 'truck2', description: 'Caminhão médio com 2 eixos.' },
            { id: 3, name: 'Caminhão 3 eixos', type: 'truck3', description: 'Caminhão grande com 3 eixos.' },
            { id: 4, name: 'Carreta 5 eixos', type: 'truck5', description: 'Carreta com 5 eixos.' },
            { id: 5, name: 'Carreta 6 eixos', type: 'truck6', description: 'Carreta grande com 6 eixos.' }
        ]
    };
    
    // Inicialização do mapa após carregamento da página
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Iniciando carregamento da Google Maps API...');
        
        // Inicializar variáveis de data
        initializeDateInputs();
        
        // Inicializar mapa
        initMap();
        
        // Configurar eventos para os tabs
        setupTabs();
        
        // Configurar eventos para upload de arquivo
        setupFileUpload();
        
        // Configurar o botão de adicionar localização
        document.getElementById('add-location').addEventListener('click', addLocation);
        
        // Configurar o botão de otimizar rota
        document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
        
        // Inicializar o modo de rota personalizada
        setupCustomRoute();
    });
    
    // Inicializar os campos de data
    function initializeDateInputs() {
        const today = new Date();
        const nextWeek = new Date();
        nextWeek.setDate(today.getDate() + 7);
        
        const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        
        document.getElementById('start-date').value = formatDate(today);
        document.getElementById('end-date').value = formatDate(nextWeek);
    }
    
    // Inicializar o mapa do Google
    function initMap() {
        // Coordenadas de Dois Córregos, SP
        const doiscorregos = { lat: -22.3642, lng: -48.3804 };
        
        // Criar mapa centrado em Dois Córregos
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 10,
            center: doiscorregos,
            mapTypeControl: true,
            streetViewControl: true,
            zoomControl: true,
            fullscreenControl: true,
            gestureHandling: 'greedy' // Permitir zoom sem pressionar Ctrl
        });
        
        // Inicializar serviços do Google Maps
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: true, // Suprimir marcadores padrão
            polylineOptions: {
                strokeColor: '#0066cc',
                strokeOpacity: 0.8,
                strokeWeight: 5
            }
        });
        
        placesService = new google.maps.places.PlacesService(map);
        
        // Inicializar o autocomplete para o campo de endereço
        autocomplete = new google.maps.places.Autocomplete(
            document.getElementById('address-input'),
            { types: ['geocode'], componentRestrictions: { country: 'br' } }
        );
        
        // Adicionar marcador para a origem (Dois Córregos)
        addMarker(origin);
        
        // Adicionar location inicial (origem)
        locations.push(origin);
        
        console.log('Google Maps API carregada com sucesso');
    }
    
    // Configurar os eventos para as abas
    function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remover classe active de todas as abas
                tabs.forEach(t => t.classList.remove('active'));
                
                // Adicionar classe active à aba clicada
                this.classList.add('active');
                
                // Esconder todos os conteúdos de aba
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Mostrar o conteúdo da aba selecionada
                const tabName = this.getAttribute('data-tab');
                document.getElementById(tabName + '-tab').classList.add('active');
            });
        });
    }
    
    // Configurar o upload de arquivos
    function setupFileUpload() {
        const fileUploadArea = document.getElementById('file-upload-area');
        const fileInput = document.getElementById('file-upload');
        
        // Abrir o diálogo de arquivo ao clicar na área
        fileUploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Manipular o drag and drop
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.classList.add('dragover');
        });
        
        fileUploadArea.addEventListener('dragleave', () => {
            fileUploadArea.classList.remove('dragover');
        });
        
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            
            if (e.dataTransfer.files.length) {
                handleFileUpload(e.dataTransfer.files[0]);
            }
        });
        
        // Manipular o upload pelo input
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length) {
                handleFileUpload(fileInput.files[0]);
            }
        });
    }
    
    // Manipular o arquivo enviado
    function handleFileUpload(file) {
        if (file.type !== 'text/plain' && file.type !== 'text/csv' && file.name.split('.').pop() !== 'txt' && file.name.split('.').pop() !== 'csv') {
            showNotification('Por favor, envie um arquivo .txt ou .csv', 'error');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const content = e.target.result;
            processFileContent(content);
        };
        
        reader.onerror = () => {
            showNotification('Erro ao ler o arquivo', 'error');
        };
        
        reader.readAsText(file);
    }
    
    // Processar o conteúdo do arquivo
    function processFileContent(content) {
        const lines = content.split(/\r?\n/);
        const validLines = [];
        const invalidLines = [];
        
        lines.forEach(line => {
            if (!line.trim()) return; // Ignorar linhas vazias
            
            const parts = line.split(',');
            if (parts.length >= 2) {
                const cep = parts[0].trim();
                const name = parts.slice(1).join(',').trim();
                
                if (/^\d{5}-?\d{3}$/.test(cep)) {
                    validLines.push({ cep, name });
                } else {
                    invalidLines.push(line);
                }
            } else {
                invalidLines.push(line);
            }
        });
        
        if (validLines.length === 0) {
            showNotification('Nenhuma linha válida encontrada no arquivo. O formato deve ser "CEP,Nome"', 'error');
            return;
        }
        
        if (invalidLines.length > 0) {
            console.warn('Linhas inválidas:', invalidLines);
        }
        
        showNotification(`Processando ${validLines.length} locais do arquivo...`, 'info');
        
        // Processar cada linha válida
        processValidLines(validLines);
    }
    
    // Processar as linhas válidas do arquivo
    function processValidLines(validLines) {
        let processed = 0;
        let successful = 0;
        
        validLines.forEach((line, index) => {
            // Atrasar as solicitações para evitar exceder os limites da API
            setTimeout(() => {
                geocodeCEP(line.cep, line.name).then(result => {
                    if (result) {
                        successful++;
                    }
                    
                    processed++;
                    
                    if (processed === validLines.length) {
                        showNotification(`Adicionados ${successful} de ${validLines.length} locais do arquivo`, 'success');
                    }
                });
            }, index * 300);
        });
    }
    
    // Geocodificar um CEP
    function geocodeCEP(cep, name) {
        return new Promise((resolve) => {
            const formattedCep = cep.replace(/[^\d]/g, '');
            const address = `${formattedCep}, Brasil`;
            
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ address }, (results, status) => {
                if (status === google.maps.GeocoderStatus.OK && results && results.length > 0) {
                    const location = results[0].geometry.location;
                    const lat = location.lat();
                    const lng = location.lng();
                    
                    // Obter o endereço formatado
                    let formattedAddress = results[0].formatted_address;
                    
                    // Criar um objeto de localização
                    const newLocation = {
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        name: name || formattedAddress,
                        address: formattedAddress,
                        lat: lat,
                        lng: lng,
                        isOrigin: false
                    };
                    
                    // Adicionar a localização
                    addLocationToList(newLocation);
                    resolve(true);
                } else {
                    console.error('Geocoding falhou para o CEP', cep, status);
                    resolve(false);
                }
            });
        });
    }
    
    // Adicionar uma nova localização a partir do campo de endereço
    function addLocation() {
        const place = autocomplete.getPlace();
        
        if (!place || !place.geometry) {
            showNotification('Por favor, selecione um endereço da lista de sugestões', 'warning');
            return;
        }
        
        const lat = place.geometry.location.lat();
        const lng = place.geometry.location.lng();
        
        // Criar um objeto de localização
        const newLocation = {
            id: Date.now() + Math.floor(Math.random() * 1000),
            name: place.name || place.formatted_address,
            address: place.formatted_address,
            lat: lat,
            lng: lng,
            isOrigin: false
        };
        
        // Adicionar a localização
        addLocationToList(newLocation);
        
        // Limpar o campo de endereço
        document.getElementById('address-input').value = '';
    }
    
    // Adicionar uma localização à lista e ao mapa
    function addLocationToList(location) {
        // Verificar se a localização já existe
        const exists = locations.some(loc => 
            loc.lat === location.lat && 
            loc.lng === location.lng &&
            !loc.isOrigin
        );
        
        if (exists) {
            showNotification('Esta localização já foi adicionada', 'warning');
            return;
        }
        
        // Adicionar ao array de localizações
        locations.push(location);
        
        // Adicionar à lista visual
        const destinationsList = document.getElementById('destinations-list');
        const listItem = document.createElement('li');
        listItem.className = 'location-item fade-in';
        listItem.setAttribute('data-id', location.id);
        
        listItem.innerHTML = `
            <i class="bi bi-geo-alt me-2"></i>
            <span>${location.name}</span>
            <button class="btn-remove" title="Remover" data-id="${location.id}">
                <i class="bi bi-x-circle"></i>
            </button>
        `;
        
        destinationsList.appendChild(listItem);
        
        // Adicionar evento de clique para o botão de remover
        listItem.querySelector('.btn-remove').addEventListener('click', function(e) {
            e.stopPropagation();
            const id = this.getAttribute('data-id');
            removeLocation(id);
        });
        
        // Adicionar marcador no mapa
        addMarker(location);
        
        // Mostrar notificação
        showNotification('Localização adicionada com sucesso', 'success');
    }
    
    // Remover uma localização
    function removeLocation(id) {
        // Encontrar o índice da localização
        const index = locations.findIndex(loc => String(loc.id) === String(id));
        
        if (index !== -1) {
            // Remover do array de localizações
            const location = locations[index];
            locations.splice(index, 1);
            
            // Remover da lista visual
            const listItem = document.querySelector(`li[data-id="${id}"]`);
            if (listItem) {
                listItem.remove();
            }
            
            // Remover marcador do mapa
            removeMarker(location);
            
            // Mostrar notificação
            showNotification('Localização removida com sucesso', 'info');
            
            // Limpar rotas se existirem
            if (routeResults) {
                clearRoute();
                routeResults = null;
                document.getElementById('route-info').style.display = 'none';
                
                // Limpar conteúdo das abas
                document.getElementById('events-content').innerHTML = '<p>Selecione uma rota para ver os eventos nas cidades.</p>';
                document.getElementById('restrictions-content').innerHTML = '<p>Selecione uma rota para ver as restrições de tráfego.</p>';
                document.getElementById('pois-content').innerHTML = '<p>Selecione uma rota para ver os pedágios e balanças.</p>';
            }
        }
    }
    
    // Adicionar um marcador no mapa
    function addMarker(location) {
        const marker = new google.maps.Marker({
            position: { lat: location.lat, lng: location.lng },
            map: map,
            title: location.name,
            animation: google.maps.Animation.DROP,
            icon: location.isOrigin ? 
                { url: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png' } : 
                { url: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png' }
        });
        
        // Adicionar info window
        const infoWindow = new google.maps.InfoWindow({
            content: `<div><strong>${location.name}</strong><br>${location.address}</div>`
        });
        
        marker.addListener('click', () => {
            infoWindow.open(map, marker);
        });
        
        // Armazenar o marcador e sua info window
        markers.push({ marker, infoWindow, location });
        
        // Centralizar mapa se for o primeiro destino
        if (markers.length === 2) {
            map.setCenter({ lat: location.lat, lng: location.lng });
            map.setZoom(10);
        }
    }
    
    // Remover um marcador do mapa
    function removeMarker(location) {
        const index = markers.findIndex(m => String(m.location.id) === String(location.id));
        
        if (index !== -1) {
            markers[index].marker.setMap(null);
            markers.splice(index, 1);
        }
    }
    
    // Limpar todos os marcadores da rota atual
    function clearRouteMarkers() {
        for (let i = 0; i < markers.length; i++) {
            if (!markers[i].location.isOrigin) {
                markers[i].marker.setMap(null);
            }
        }
        
        // Filtrar apenas o marcador de origem
        markers = markers.filter(m => m.location.isOrigin);
    }
    
    // Otimizar a rota usando o algoritmo do caixeiro viajante
    function optimizeRoute() {
        if (locations.length < 2) {
            showNotification('Adicione pelo menos um destino para otimizar a rota', 'warning');
            return;
        }
        
        // Implementação simples do algoritmo do caixeiro viajante (Vizinho mais próximo)
        const originIndex = locations.findIndex(loc => loc.isOrigin);
        
        if (originIndex === -1) {
            showNotification('Ponto de origem não encontrado', 'error');
            return;
        }
        
        // Mostrar notificação de processamento
        showNotification('Calculando melhor rota...', 'info');
        
        // Resolver o problema do caixeiro viajante
        const tspResult = solveTSP(locations, originIndex);
        
        // Atualizar o roteiro
        updateRouteSummary(tspResult);
        
        // Desenhar rota no mapa
        drawOptimizedRoute(tspResult.path);
    }
    
    // Resolver o problema do caixeiro viajante
    function solveTSP(locations, originIndex) {
        // Construir matriz de distâncias
        const distMatrix = buildDistanceMatrix(locations);
        
        // Resolver usando o algoritmo do vizinho mais próximo
        const result = nearestNeighborTSP(distMatrix, originIndex);
        
        // Mapear o caminho de volta para as localizações
        const path = result.path.map(index => locations[index]);
        
        return {
            path: path,
            distance: result.distance,
            duration: Math.ceil(result.distance / 80 * 60) // Estimativa baseada em 80 km/h
        };
    }
    
    // Construir matriz de distâncias
    function buildDistanceMatrix(locations) {
        const n = locations.length;
        const matrix = Array(n).fill().map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    matrix[i][j] = calculateDistance(
                        locations[i].lat, locations[i].lng,
                        locations[j].lat, locations[j].lng
                    );
                }
            }
        }
        
        return matrix;
    }
    
    // Calcular distância entre dois pontos usando a fórmula de Haversine
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Raio da Terra em km
        const dLat = deg2rad(lat2 - lat1);
        const dLon = deg2rad(lon2 - lon1);
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distância em km
        return distance;
    }
    
    // Converter graus para radianos
    function deg2rad(deg) {
        return deg * (Math.PI/180);
    }
    
    // Algoritmo do vizinho mais próximo para o TSP
    function nearestNeighborTSP(distMatrix, startIdx = 0) {
        const n = distMatrix.length;
        const visited = Array(n).fill(false);
        const path = [startIdx];
        let totalDistance = 0;
        
        visited[startIdx] = true;
        
        for (let i = 1; i < n; i++) {
            let lastNode = path[path.length - 1];
            let nearestNode = -1;
            let shortestDistance = Infinity;
            
            for (let j = 0; j < n; j++) {
                if (!visited[j] && distMatrix[lastNode][j] < shortestDistance) {
                    nearestNode = j;
                    shortestDistance = distMatrix[lastNode][j];
                }
            }
            
            if (nearestNode !== -1) {
                visited[nearestNode] = true;
                path.push(nearestNode);
                totalDistance += shortestDistance;
            }
        }
        
        return { path, distance: totalDistance };
    }
    
    // Atualizar o resumo da rota
    function updateRouteSummary(tspResult) {
        // Atualizar informações da rota
        const routeInfo = document.getElementById('route-info');
        const routeDetails = document.getElementById('route-details');
        const routeSequence = document.getElementById('route-sequence');
        
        // Salvar o resultado atual
        routeResults = tspResult;
        currentOptimizedPath = tspResult.path.map(loc => loc.id);
        
        // Formatar a distância e duração
        const distance = tspResult.distance.toFixed(1);
        const hours = Math.floor(tspResult.duration / 60);
        const minutes = tspResult.duration % 60;
        
        // Atualizar detalhes da rota
        routeDetails.innerHTML = `
            <p><strong>Distância Total:</strong> ${distance} km</p>
            <p><strong>Tempo Estimado:</strong> ${hours > 0 ? `${hours}h ` : ''}${minutes}min</p>
            <p><strong>Velocidade Média:</strong> 80 km/h</p>
        `;
        
        // Atualizar a sequência de visitas
        routeSequence.innerHTML = '<div class="mt-3 mb-2"><strong>Sequência de Visitas:</strong></div>';
        
        tspResult.path.forEach((location, index) => {
            const sequenceItem = document.createElement('div');
            sequenceItem.className = 'sequence-item';
            
            sequenceItem.innerHTML = `
                <span class="sequence-number">${index}</span>
                <span class="sequence-name">${location.name}</span>
            `;
            
            routeSequence.appendChild(sequenceItem);
        });
        
        // Mostrar o resumo da rota
        routeInfo.style.display = 'block';
        
        // Atualizar conteúdo das abas com informações relevantes
        updateEventsList(tspResult.path);
        updateRestrictionsList(tspResult.path);
        updatePOIsList(tspResult.path);
    }
    
    // Atualizar a lista de eventos com base nas cidades da rota
    function updateEventsList(routePath) {
        const eventsContent = document.getElementById('events-content');
        const cities = extractCitiesFromRoute(routePath);
        
        console.log('Cidades detectadas para eventos:', cities);
        
        // Obter datas selecionadas
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        
        // Filtrar eventos para as cidades na rota e dentro do intervalo de datas
        const relevantEvents = mockData.cityEvents.filter(event => {
            return cities.some(city => event.cityName.includes(city)) && 
                   isDateInRange(event.date, startDate, endDate);
        });
        
        if (relevantEvents.length === 0) {
            eventsContent.innerHTML = '<p>Nenhum evento encontrado para as cidades nesta rota no período selecionado.</p>';
            return;
        }
        
        eventsContent.innerHTML = '<div class="mb-3">Eventos nas cidades da rota:</div>';
        
        relevantEvents.forEach(event => {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Formatar a data
            const eventDate = new Date(event.date);
            const formattedDate = eventDate.toLocaleDateString('pt-BR');
            
            eventItem.innerHTML = `
                <div class="event-date">${formattedDate}</div>
                <div class="event-city">${event.cityName}</div>
                <div class="event-name">${event.name}</div>
                <div class="event-description">${event.description}</div>
            `;
            
            eventsContent.appendChild(eventItem);
        });
    }
    
    // Verificar se uma data está dentro de um intervalo
    function isDateInRange(dateStr, startStr, endStr) {
        const date = new Date(dateStr);
        const start = new Date(startStr);
        const end = new Date(endStr);
        
        // Ajustar o horário para comparação apenas da data
        date.setHours(0, 0, 0, 0);
        start.setHours(0, 0, 0, 0);
        end.setHours(23, 59, 59, 999);
        
        return date >= start && date <= end;
    }
    
    // Atualizar a lista de restrições com base nas cidades da rota
    function updateRestrictionsList(routePath) {
        const restrictionsContent = document.getElementById('restrictions-content');
        const cities = extractCitiesFromRoute(routePath);
        
        // Filtrar restrições para as cidades na rota
        const relevantRestrictions = mockData.truckRestrictions.filter(restriction => {
            return cities.some(city => restriction.cityName.includes(city));
        });
        
        if (relevantRestrictions.length === 0) {
            restrictionsContent.innerHTML = '<p>Nenhuma restrição de tráfego encontrada para as cidades nesta rota.</p>';
            return;
        }
        
        restrictionsContent.innerHTML = '<div class="mb-3">Restrições nas cidades da rota:</div>';
        
        relevantRestrictions.forEach(restriction => {
            const restrictionItem = document.createElement('div');
            restrictionItem.className = 'restriction-item';
            
            let typeLabel = '';
            switch (restriction.restrictionType) {
                case 'time':
                    typeLabel = 'Restrição de Horário';
                    break;
                case 'weight':
                    typeLabel = 'Restrição de Peso';
                    break;
                case 'route':
                    typeLabel = 'Restrição de Rota';
                    break;
                default:
                    typeLabel = 'Restrição Geral';
            }
            
            restrictionItem.innerHTML = `
                <div class="restriction-type">${typeLabel}</div>
                <div class="restriction-city">${restriction.cityName}</div>
                <div class="restriction-description">${restriction.description}</div>
            `;
            
            restrictionsContent.appendChild(restrictionItem);
        });
    }
    
    // Atualizar a lista de pontos de interesse (pedágios e balanças)
    function updatePOIsList(routePath) {
        const poisContent = document.getElementById('pois-content');
        
        // Criar um "corredor" ao longo da rota para detectar POIs próximos
        const routeBuffer = 20; // km de distância da rota
        
        // Filtrar POIs próximos à rota
        const nearbyPOIs = mockData.pointsOfInterest.filter(poi => {
            return routePath.some(location => {
                const distance = calculateDistance(poi.lat, poi.lng, location.lat, location.lng);
                return distance <= routeBuffer;
            });
        });
        
        if (nearbyPOIs.length === 0) {
            poisContent.innerHTML = '<p>Nenhum pedágio ou balança encontrado próximo a esta rota.</p>';
            return;
        }
        
        poisContent.innerHTML = '<div class="mb-3">Pedágios e balanças próximos à rota:</div>';
        
        nearbyPOIs.forEach(poi => {
            const poiItem = document.createElement('div');
            poiItem.className = 'poi-item';
            
            let typeLabel = '';
            let iconClass = '';
            
            switch (poi.type) {
                case 'toll':
                    typeLabel = 'Pedágio';
                    iconClass = 'bi-currency-dollar';
                    break;
                case 'weight_station':
                    typeLabel = 'Balança';
                    iconClass = 'bi-truck';
                    break;
                case 'police':
                    typeLabel = 'Posto Policial';
                    iconClass = 'bi-shield';
                    break;
                default:
                    typeLabel = 'Ponto de Interesse';
                    iconClass = 'bi-geo-alt';
            }
            
            poiItem.innerHTML = `
                <div class="poi-type"><i class="bi ${iconClass} me-1"></i> ${typeLabel}</div>
                <div class="poi-name">${poi.name}</div>
                <div class="poi-description">${poi.description}</div>
            `;
            
            poisContent.appendChild(poiItem);
        });
    }
    
    // Extrair nomes de cidades da rota
    function extractCitiesFromRoute(routePath) {
        const cities = [];
        
        routePath.forEach(location => {
            // Tentar encontrar o nome da cidade no endereço
            let city = '';
            
            if (location.address) {
                // Padrão típico de endereços no Brasil: "Rua X, Bairro, Cidade - Estado, CEP"
                const parts = location.address.split(',');
                
                if (parts.length > 1) {
                    // Tentar obter a cidade da parte que contém a cidade e o estado
                    const cityStatePart = parts[parts.length - 2] || '';
                    const cityMatch = cityStatePart.trim().split('-')[0];
                    
                    if (cityMatch) {
                        city = cityMatch.trim();
                    }
                }
                
                // Se não conseguir extrair a cidade do endereço, usar parte do nome
                if (!city && location.name) {
                    // Verificar se o nome contém uma cidade conhecida
                    const knownCities = ['Dois Córregos', 'Jaú', 'Bauru', 'São Carlos', 'Araraquara', 
                                         'Piracicaba', 'Brotas', 'Barra Bonita', 'Rio Claro', 'Campinas'];
                    
                    for (const knownCity of knownCities) {
                        if (location.name.includes(knownCity)) {
                            city = knownCity;
                            break;
                        }
                    }
                }
            }
            
            // Se ainda não tiver cidade, tentar extrair do nome do local
            if (!city && location.name) {
                // Se o nome for "Dois Córregos, SP" ou similar
                const parts = location.name.split(',');
                if (parts.length > 0) {
                    city = parts[0].trim();
                }
            }
            
            if (city && !cities.includes(city)) {
                cities.push(city);
            }
        });
        
        return cities;
    }
    
    // Desenhar a rota otimizada no mapa
    function drawOptimizedRoute(routePath) {
        // Limpar rotas anteriores
        clearRoute();
        
        // Adicionar novos marcadores com números de sequência
        routePath.forEach((location, index) => {
            const marker = new google.maps.Marker({
                position: { lat: location.lat, lng: location.lng },
                map: map,
                title: `${index}: ${location.name}`,
                label: {
                    text: index.toString(),
                    color: 'black',
                    fontSize: '16px',
                    fontWeight: 'bold'
                },
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#ffc107',
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: '#000',
                    scale: 13
                },
                zIndex: 100
            });
            
            // Adicionar info window
            const infoWindow = new google.maps.InfoWindow({
                content: `<div><strong>${index}: ${location.name}</strong><br>${location.address}</div>`
            });
            
            marker.addListener('click', () => {
                infoWindow.open(map, marker);
            });
            
            // Armazenar o marcador e sua info window
            markers.push({ marker, infoWindow, location });
        });
        
        // Desenhar a rota usando o Google Directions Service
        drawGoogleDirectionsRoute(routePath);
    }
    
    // Desenhar a rota usando o Google Directions Service
    function drawGoogleDirectionsRoute(routePath) {
        if (routePath.length < 2) return;
        
        // Se tivermos mais de 25 pontos (limite da API do Google), dividir em múltiplas requisições
        const maxWaypoints = 23; // Google directions pode ter no máximo 23 waypoints + origem/destino
        
        if (routePath.length <= maxWaypoints + 2) {
            // Caso simples: uma única requisição
            calculateAndDisplayRoute(routePath);
        } else {
            // Caso complexo: múltiplas requisições
            const chunks = chunkArray(routePath, maxWaypoints);
            
            // Desenhar cada segmento da rota
            chunks.forEach((chunk, index) => {
                // Adicionar o último ponto do chunk anterior como primeiro ponto deste chunk
                // (exceto para o primeiro chunk)
                if (index > 0) {
                    chunk.unshift(chunks[index - 1][chunks[index - 1].length - 1]);
                }
                
                // Calcular e exibir este segmento
                calculateAndDisplayRoute(chunk, index);
            });
        }
    }
    
    // Dividir um array em chunks de tamanho especificado
    function chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize - 1) {
            // -1 para permitir sobreposição de um ponto entre chunks
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }
    
    // Calcular e exibir uma rota
    function calculateAndDisplayRoute(routePath, routeIndex = 0) {
        const origin = routePath[0];
        const destination = routePath[routePath.length - 1];
        
        // Criar waypoints para pontos intermediários
        const waypoints = routePath.slice(1, routePath.length - 1).map(point => ({
            location: new google.maps.LatLng(point.lat, point.lng),
            stopover: true
        }));
        
        // Configurar a requisição de rota
        const request = {
            origin: new google.maps.LatLng(origin.lat, origin.lng),
            destination: new google.maps.LatLng(destination.lat, destination.lng),
            waypoints: waypoints,
            optimizeWaypoints: false, // Não otimizar, já temos a ordem
            travelMode: google.maps.TravelMode.DRIVING
        };
        
        // Calcular a rota
        directionsService.route(request, (result, status) => {
            if (status === google.maps.DirectionsStatus.OK) {
                if (routeIndex === 0) {
                    // Para a primeira rota, usar o directionsRenderer
                    directionsRenderer.setDirections(result);
                } else {
                    // Para rotas adicionais, desenhar manualmente para evitar substituição
                    const polylineOptions = {
                        path: [],
                        strokeColor: '#0066cc',
                        strokeOpacity: 0.8,
                        strokeWeight: 5
                    };
                    
                    const legs = result.routes[0].legs;
                    for (let i = 0; i < legs.length; i++) {
                        const steps = legs[i].steps;
                        for (let j = 0; j < steps.length; j++) {
                            const nextSegment = steps[j].path;
                            for (let k = 0; k < nextSegment.length; k++) {
                                polylineOptions.path.push(nextSegment[k]);
                            }
                        }
                    }
                    
                    const polyline = new google.maps.Polyline(polylineOptions);
                    polyline.setMap(map);
                    polylines.push(polyline);
                }
            } else {
                showNotification(`Erro ao calcular rota: ${status}`, 'error');
            }
        });
    }
    
    // Limpar a rota atual
    function clearRoute() {
        // Limpar o renderizador de direções
        directionsRenderer.setDirections({ routes: [] });
        
        // Limpar polylines adicionais
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];
        
        // Limpar marcadores existentes (exceto origem)
        clearRouteMarkers();
        
        // Readicionar marcador de origem
        const origin = locations.find(loc => loc.isOrigin);
        if (origin) {
            addMarker(origin);
        }
        
        // Readicionar todos os destinos
        locations.forEach(loc => {
            if (!loc.isOrigin) {
                addMarker(loc);
            }
        });
    }
    
    // Mostrar uma notificação ao usuário
    function showNotification(message, type = 'info') {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = `notification ${type}`;
        notification.classList.add('show');
        
        // Remover classes anteriores
        notification.classList.remove('success', 'error', 'info', 'warning');
        notification.classList.add(type);
        
        // Mostrar a notificação
        notification.classList.add('show');
        
        // Esconder após alguns segundos
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }
    
    // Configurar o modo de rota personalizada
    function setupCustomRoute() {
        const customRouteButton = document.getElementById('custom-route-btn');
        
        if (!customRouteButton) return;
        
        let modoAtivo = false;
        
        customRouteButton.addEventListener('click', function() {
            // Alternar o estado
            modoAtivo = !modoAtivo;
            
            // Lista de localizações
            const listaLocais = document.getElementById('destinations-list');
            if (!listaLocais) {
                console.error('[RotaPersonalizada] Lista de localizações não encontrada');
                return;
            }
            
            if (modoAtivo) {
                // Ativar o modo de rota personalizada
                customRouteButton.classList.add('ativo');
                listaLocais.classList.add('modo-rota-personalizada');
                
                // Adicionar botões para cada item da lista
                const itensLista = listaLocais.querySelectorAll('li');
                
                itensLista.forEach(function(item) {
                    // Criar container para os botões
                    const controles = document.createElement('div');
                    controles.className = 'controles-rota';
                    
                    // Botão para mover para cima
                    const btnCima = document.createElement('button');
                    btnCima.type = 'button';
                    btnCima.className = 'btn-mover btn-cima';
                    btnCima.textContent = '↑';
                    btnCima.title = 'Mover para cima';
                    
                    // Botão para mover para baixo
                    const btnBaixo = document.createElement('button');
                    btnBaixo.type = 'button';
                    btnBaixo.className = 'btn-mover btn-baixo';
                    btnBaixo.textContent = '↓';
                    btnBaixo.title = 'Mover para baixo';
                    
                    // Adicionar os botões ao controle
                    controles.appendChild(btnCima);
                    controles.appendChild(btnBaixo);
                    
                    // Inserir no início do item
                    item.insertBefore(controles, item.firstChild);
                    
                    // Evento de clique no botão para cima
                    btnCima.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const li = this.closest('li');
                        const prev = li.previousElementSibling;
                        
                        if (prev) {
                            listaLocais.insertBefore(li, prev);
                            atualizarRotaPersonalizada();
                        }
                    });
                    
                    // Evento de clique no botão para baixo
                    btnBaixo.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const li = this.closest('li');
                        const next = li.nextElementSibling;
                        
                        if (next) {
                            listaLocais.insertBefore(next, li);
                            atualizarRotaPersonalizada();
                        }
                    });
                });
                
                // Exibir notificação
                showNotification('Modo de rota personalizada ativado. Use as setas para reordenar os locais.', 'info');
                
            } else {
                // Desativar o modo de rota personalizada
                customRouteButton.classList.remove('ativo');
                listaLocais.classList.remove('modo-rota-personalizada');
                
                // Remover os botões de controle
                const controles = listaLocais.querySelectorAll('.controles-rota');
                controles.forEach(function(controle) {
                    controle.remove();
                });
                
                // Atualizar rota com a ordem atual
                atualizarRotaPersonalizada();
            }
        });
        
        // Função para atualizar a rota com a ordem personalizada
        function atualizarRotaPersonalizada() {
            // Obter a lista de localizações
            const listaLocais = document.getElementById('destinations-list');
            if (!listaLocais) return;
            
            // Coletar os IDs na ordem atual
            const itens = listaLocais.querySelectorAll('li');
            const ids = [];
            
            itens.forEach(function(item) {
                const id = item.getAttribute('data-id');
                if (id) {
                    ids.push(id);
                }
            });
            
            if (ids.length < 1) {
                console.log('Não há locais suficientes para uma rota');
                return;
            }
            
            // Ordenar as localizações de acordo com os IDs
            const locaisOrdenados = [];
            
            // Adicionar origem
            const origem = locations.find(loc => loc.isOrigin);
            if (origem) {
                locaisOrdenados.push(origem);
            }
            
            // Adicionar demais locais na ordem personalizada
            for (const id of ids) {
                const localEncontrado = locations.find(loc => !loc.isOrigin && String(loc.id) === String(id));
                if (localEncontrado) {
                    locaisOrdenados.push(localEncontrado);
                }
            }
            
            if (locaisOrdenados.length > 1) {
                // Recalcular rota com a nova ordem
                clearRoute();
                const customTSPResult = {
                    path: locaisOrdenados,
                    distance: calculateRouteDistance(locaisOrdenados),
                    duration: calculateRouteDuration(locaisOrdenados)
                };
                
                updateRouteSummary(customTSPResult);
                drawOptimizedRoute(customTSPResult.path);
            }
        }
        
        // Função para calcular a distância aproximada da rota
        function calculateRouteDistance(routePath) {
            let totalDistance = 0;
            
            for (let i = 0; i < routePath.length - 1; i++) {
                const distance = calculateDistance(
                    routePath[i].lat, routePath[i].lng,
                    routePath[i + 1].lat, routePath[i + 1].lng
                );
                totalDistance += distance;
            }
            
            // Adicionar 30% para compensar que a rota real é mais longa que a linha reta
            return totalDistance * 1.3;
        }
        
        // Função para calcular a duração aproximada da rota
        function calculateRouteDuration(routePath) {
            const distance = calculateRouteDistance(routePath);
            return Math.ceil(distance / 80 * 60); // 80 km/h
        }
    }
    </script>
</body>
</html>