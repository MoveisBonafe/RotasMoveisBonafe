<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Otimizador de Rotas para logística e transporte, com suporte a cálculo de rotas entre múltiplos pontos, otimização de sequência, e visualização de eventos e restrições em cidades brasileiras." />
    <meta name="keywords" content="otimizador de rotas, problema do caixeiro viajante, logística, transporte, planejamento de rotas, otimização de entregas, Brasil, Google Maps, pedágios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 380px;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .map-container {
            flex: 1;
            height: 100%;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .location-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        /* Spinner de carregamento */
        #loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            display: none;
            text-align: center;
        }
        
        #loading-spinner::after {
            content: "";
            display: block;
            width: 40px;
            height: 40px;
            margin: 10px auto;
            border-radius: 50%;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            animation: spin 2s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-address {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn-container {
            position: sticky;
            bottom: 0;
            background-color: #f8f9fa;
            padding: 15px 0;
            margin-top: 20px;
        }
        #optimize-route {
            width: 100%;
        }
        .marker-label {
            color: white;
            background-color: #1976D2;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 14px;
        }
        .pac-container {
            z-index: 9999; /* Garantir que as sugestões apareçam acima de outros elementos */
        }
        .truck-icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
        }
        .truck-type {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .truck-type label {
            margin-left: 10px;
            cursor: pointer;
        }
        #route-summary {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        #route-steps {
            margin-top: 15px;
            padding-left: 15px;
        }
        .summary-header {
            font-weight: bold;
            margin-bottom: 10px;
        }
        /* Estilos para a área de upload de arquivo */
        .file-upload {
            margin-top: 15px;
            border: 2px dashed #3498db;
            padding: 25px 15px;
            text-align: center;
            border-radius: 10px;
            background-color: #f0f8ff;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }
        .file-upload:hover, .file-upload.dragover {
            border-color: #2980b9;
            background-color: #e6f2ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .file-upload p {
            margin-bottom: 10px;
            color: #444;
            font-weight: 500;
        }
        .file-upload-icon {
            display: block;
            margin: 0 auto 10px;
            font-size: 32px;
            color: #3498db;
        }
        .file-format-example {
            background-color: #e2f3ff;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            display: inline-block;
            margin: 8px auto;
            color: #2c3e50;
            border: 1px solid #bde0ff;
            font-size: 14px;
        }
        .file-upload input[type="file"] {
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .file-upload-text {
            display: block;
            margin-top: 5px;
            color: #7f8c8d;
            font-size: 13px;
        }
        /* Estilos para notificação de sucesso no upload */
        .upload-success {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            height: 100%;
        }
        .upload-success-icon {
            font-size: 48px;
            color: #2ecc71;
            margin-bottom: 10px;
            animation: scale-in 0.3s ease-out;
        }
        .upload-success-text {
            color: #555;
            font-size: 16px;
            margin-top: 5px;
        }
        .file-upload.success {
            border-color: #2ecc71;
            background-color: #ebfaf0;
            transition: all 0.3s ease;
        }
        .file-upload.fading {
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        @keyframes scale-in {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            80% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        /* Botão para fechar o sidebar em telas pequenas */
        .sidebar-close {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        /* Estilo quando o sidebar está fechado */
        .sidebar-hidden {
            transform: translateX(-100%);
        }
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 100%;
                max-width: 320px;
            }
            .sidebar-close {
                display: block;
            }
            .toggle-sidebar {
                display: block;
            }
        }
        /* Estilo para o ponto de origem na lista da rota */
        .origin-point {
            color: #ff6600;
            font-weight: bold;
            border-bottom: 1px solid #ff6600;
            padding-bottom: 3px;
            margin-bottom: 5px;
        }
        
        /* Estilo para os marcadores de pontos de interesse */
        .poi-marker {
            background-color: #4caf50;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            font-size: 12px;
        }
        /* Estilos para tooltip personalizado */
        .custom-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
        }
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        /* Estilos para abas */
        .tab-container {
            margin-bottom: 20px;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }
        .tab-button {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }
        .tab-button.active {
            border-bottom: 2px solid #1976D2;
            background-color: #e9ecef;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Estilo para datas */
        .date-range-container {
            display: flex;
            gap: 10px;
        }
        .date-range-container input {
            flex: 1;
        }
        
        /* Estilos para ícones de evento */
        .event-marker {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            font-size: 14px;
        }
        .event-marker.holiday {
            background-color: #f44336; /* Vermelho para feriados */
        }
        .event-marker.event {
            background-color: #ff9800; /* Laranja para eventos */
        }
        
        /* Estilo para lista de eventos */
        .events-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .event-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .event-name {
            font-weight: bold;
        }
        .event-date {
            font-size: 0.8em;
            color: #666;
        }
        .event-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .event-type.holiday {
            background-color: #f44336;
        }
        .event-type.event {
            background-color: #ff9800;
        }
        .restriction-level {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-level.low {
            background-color: #4caf50;
        }
        .restriction-level.medium {
            background-color: #ff9800;
        }
        .restriction-level.high {
            background-color: #f44336;
        }
        
        /* Estilos para restrições de caminhões */
        .restrictions-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .restriction-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .restriction-city {
            font-weight: bold;
        }
        .restriction-time {
            font-size: 0.8em;
            color: #666;
        }
        .restriction-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-type.partial {
            background-color: #ff9800;
        }
        .restriction-type.total {
            background-color: #f44336;
        }
        .restriction-type.rodizio {
            background-color: #9c27b0;
        }

        /* Estilos para animação da rota */
        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
            }
        }
        .animated-path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawPath 3s ease-in-out forwards;
        }

        /* Botões de controle da visualização */
        .map-controls {
            position: absolute;
            bottom: 24px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .map-control-btn {
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Estilo para o spinner de carregamento */
        .spinner-border {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
        }
        
        /* Painel inferior animado para eventos e relatório */
        .bottom-panel {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            border-top: 1px solid #ddd;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, height 0.3s ease;
            z-index: 1000;
            height: 300px;
            transform: translateY(260px); /* Inicialmente mostrar só a aba */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .bottom-panel.expanded {
            transform: translateY(0);
        }
        
        .bottom-panel.collapsed {
            transform: translateY(260px);
        }
        
        .bottom-panel-tab {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1976D2;
            color: white;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            border-radius: 8px 8px 0 0;
            margin: 0 auto;
            padding: 0 20px;
            width: auto;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        }
        
        .bottom-panel-tab:hover {
            background-color: #1565C0;
        }
        
        .bottom-panel-toggle {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.3s;
        }
        
        .bottom-panel.expanded .bottom-panel-toggle {
            transform: translateY(-50%) rotate(180deg);
        }
        
        .bottom-panel-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 15px;
        }
        
        .panel-column {
            flex: 1;
            padding: 0 15px;
            overflow-y: auto;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        .panel-column + .panel-column {
            border-left: 1px solid #eee;
        }
        
        .panel-column-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .panel-column-header i {
            margin-right: 10px;
            color: #1976D2;
        }
        
        .panel-column-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
            font-weight: 600;
        }
        
        /* Animações */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fadeIn {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        /* Ajustar margin para sidebar */
        .sidebar.with-bottom-panel {
            margin-bottom: 40px;
        }
        
        /* Ajustar altura do mapa quando o painel está expandido */
        .map-container.with-bottom-panel {
            height: calc(100% - 300px);
            transition: height 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar para controles e informações -->
        <div class="sidebar" id="sidebar">
            <h2 class="mb-4">Otimizador de Rotas</h2>
            <button type="button" class="btn-close sidebar-close" aria-label="Close"></button>
            
            <!-- Container de abas -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="locations">Locais</button>
                </div>
                
                <!-- Aba de Locais -->
                <div class="tab-content active" id="locations-tab">
                    <!-- Filtro de eventos por data (sem botão filtrar) -->
                    <div class="form-group">
                        <label>Filtrar eventos por data:</label>
                        <div class="date-range-container">
                            <input type="date" id="start-date" class="form-control">
                            <input type="date" id="end-date" class="form-control">
                        </div>
                        <!-- Botão de filtrar removido - filtro aplicado automaticamente -->
                    </div>
                
                    <!-- Origem fixa -->
                    <div class="form-group mt-3">
                        <label for="origin">Origem:</label>
                        <input type="text" id="origin" class="form-control" value="Dois Córregos, SP" readonly>
                    </div>
                    
                    <!-- Campo de busca para adicionar novo local -->
                    <div class="form-group">
                        <label for="location-search">Adicionar local:</label>
                        <input type="text" id="location-search" class="form-control" placeholder="Digite um endereço">
                    </div>
                    
                    <!-- Seleção de veículo removida, agora usa caminhão padrão automaticamente -->
                    
                    <!-- Upload de arquivo melhorado -->
                    <div class="file-upload" id="upload-area">
                        <i class="file-upload-icon fas fa-cloud-upload-alt" aria-hidden="true"></i>
                        <p>Importe múltiplos endereços via arquivo</p>
                        <div class="file-format-example">CEP,Nome do Local</div>
                        <span class="file-upload-text">Arraste e solte seu arquivo aqui ou clique para selecionar</span>
                        <input type="file" id="file-upload" accept=".txt,.csv">
                    </div>
                    
                    <!-- Lista de locais adicionados -->
                    <h5 class="mt-4">Locais adicionados:</h5>
                    <div class="location-list" id="locations-list">
                        <!-- Locais serão adicionados aqui dinamicamente -->
                    </div>
                    
                    <!-- Botão para otimizar rota -->
                    <div class="optimize-btn-container">
                        <button id="optimize-route" class="btn btn-primary">
                            Otimizar Rota
                        </button>
                    </div>
                </div>
                
                <!-- Não há mais abas de Eventos e Relatório, elas foram movidas para o painel inferior -->
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar">☰</button>
            <div id="map"></div>
            <div id="loading-spinner">Calculando rota...</div>
            
            <!-- Controles do mapa -->
            <div class="map-controls">
                <button class="map-control-btn" id="zoom-to-fit" title="Ajustar zoom para ver todos os pontos">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z"/>
                    </svg>
                </button>
                <button class="map-control-btn" id="toggle-poi" title="Mostrar/ocultar pontos de interesse">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Painel inferior para Eventos e Relatório -->
    <div class="bottom-panel" id="bottom-panel">
        <!-- Aba do painel -->
        <div class="bottom-panel-tab" id="bottom-panel-tab">
            Eventos e Relatório do Percurso
            <span class="bottom-panel-toggle">▲</span>
        </div>
        
        <!-- Conteúdo do painel -->
        <div class="bottom-panel-content">
            <!-- Coluna de Eventos -->
            <div class="panel-column">
                <div class="panel-column-header">
                    <i class="fas fa-calendar-alt"></i>
                    <h3>Eventos na Rota</h3>
                </div>
                
                <div class="events-list fadeIn" id="events-list">
                    <p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                </div>
            </div>
            
            <!-- Coluna de Restrições -->
            <div class="panel-column">
                <div class="panel-column-header">
                    <i class="fas fa-truck"></i>
                    <h3>Restrições para Caminhões</h3>
                </div>
                
                <p class="small text-muted mb-2">Filtrando para: caminhão de 1 eixo, 2 eixos, truck, comercial e toco</p>
                <div class="restrictions-list fadeIn" id="restrictions-list">
                    <p class="text-muted">Nenhuma restrição encontrada. Adicione locais e otimize a rota para ver restrições nas cidades do percurso.</p>
                </div>
            </div>
            
            <!-- Coluna de Relatório -->
            <div class="panel-column">
                <div class="panel-column-header">
                    <i class="fas fa-file-alt"></i>
                    <h3>Relatório de Rota</h3>
                </div>
                
                <div id="route-summary" class="mb-3 fadeIn">
                    <p class="text-muted">Otimize uma rota para ver o relatório detalhado.</p>
                </div>
                
                <!-- Seleção de Rota Alternativa -->
                <div id="route-alternatives" class="mb-3 fadeIn" style="display: none;">
                    <h5>Rotas Alternativas</h5>
                    <p class="text-muted">Selecione uma rota alternativa para visualizar diferentes ordenações de pontos:</p>
                    <div class="form-group">
                        <select id="alternative-routes" class="form-select">
                            <option value="0">Rota Otimizada (Padrão)</option>
                            <!-- Opções de rotas alternativas serão adicionadas dinamicamente -->
                        </select>
                    </div>
                    <div class="mt-2">
                        <small class="text-muted">Cada rota usa um algoritmo diferente para ordenar os pontos, com diferentes trade-offs entre distância e tempo.</small>
                    </div>
                </div>
                
                <div class="form-group mt-3">
                    <label for="report-route-name">Nome da rota:</label>
                    <input type="text" id="report-route-name" class="form-control" placeholder="Ex: Entrega Região Sul">
                </div>
                
                <div class="mt-3">
                    <button id="save-route" class="btn btn-outline-success" disabled>Salvar Rota</button>
                    <button id="print-route" class="btn btn-outline-primary ms-2" disabled>Imprimir</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts externos -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <script src="cep-database.js"></script>
    <script src="geocode-fix.js"></script>
    
    <script>
    // Dados de amostra para a aplicação standalone
    const mockData = {
        // Origem (Dois Córregos)
        origin: {
            id: 1,
            name: "Dois Córregos",
            address: "Dois Córregos, SP, Brasil",
            zipCode: "17300-000",
            latitude: -22.3673,
            longitude: -48.3822,
            isOrigin: true
        },
        
        // Tipos de veículos
        vehicleTypes: [
            { id: 1, name: "Caminhão 1 eixo", type: "truck1", costPerKm: 3.5, fuelConsumption: 4.5, averageSpeed: 75 },
            { id: 2, name: "Caminhão 2 eixos", type: "truck2", costPerKm: 4.2, fuelConsumption: 5.2, averageSpeed: 70 },
            { id: 3, name: "Caminhão truck", type: "truck3", costPerKm: 5.0, fuelConsumption: 6.0, averageSpeed: 65 },
            { id: 4, name: "Caminhão comercial", type: "truck4", costPerKm: 4.0, fuelConsumption: 5.0, averageSpeed: 80 },
            { id: 5, name: "Caminhão toco", type: "truck5", costPerKm: 6.5, fuelConsumption: 8.0, averageSpeed: 55 }
        ],
        
        // Pontos de interesse
        pointsOfInterest: [
            { id: 1, name: "Pedágio SP-225 (Brotas)", type: "toll", latitude: -22.2544, longitude: -48.1247, highway: "SP-225", cityName: "Brotas", cost: 11.30 },
            { id: 2, name: "Pedágio SP-225 (Jaú)", type: "toll", latitude: -22.2877, longitude: -48.5325, highway: "SP-225", cityName: "Jaú", cost: 7.90 },
            { id: 3, name: "Pedágio SP-300 (Botucatu)", type: "toll", latitude: -22.8932, longitude: -48.4521, highway: "SP-300", cityName: "Botucatu", cost: 9.50 },
            { id: 4, name: "Balança SP-225 (Dois Córregos)", type: "weighStation", latitude: -22.3532, longitude: -48.3301, highway: "SP-225", cityName: "Dois Córregos", isActive: true },
            { id: 5, name: "Balança SP-300 (Botucatu)", type: "weighStation", latitude: -22.9011, longitude: -48.4402, highway: "SP-300", cityName: "Botucatu", isActive: true },
            { id: 6, name: "Posto de combustível Shell (Dois Córregos)", type: "gasStation", latitude: -22.3673, longitude: -48.3900, highway: "SP-225", cityName: "Dois Córregos", services: ["food", "rest", "shower"] },
            { id: 7, name: "Posto de combustível BR (Jaú)", type: "gasStation", latitude: -22.2870, longitude: -48.5400, highway: "SP-225", cityName: "Jaú", services: ["food", "mechanic"] },
            { id: 8, name: "Borracharia 24h (Botucatu)", type: "mechanic", latitude: -22.8900, longitude: -48.4500, highway: "SP-300", cityName: "Botucatu", services: ["tire"] }
        ],
        
        // Eventos de cidades (com aniversários atualizados para 2025)
        cityEvents: [
            // Aniversários das principais cidades (eventos fixos - feriados municipais)
            { id: 1, cityName: "Dois Córregos", name: "Aniversário da Cidade", startDate: "2025-02-04", endDate: "2025-02-04", isHoliday: true, description: "Feriado municipal do aniversário de Dois Córregos (fundação: 04/02/1883)", restrictionLevel: "low" },
            { id: 2, cityName: "Jaú", name: "Aniversário da Cidade", startDate: "2025-08-15", endDate: "2025-08-15", isHoliday: true, description: "Feriado municipal do aniversário de Jaú (fundação: 15/08/1853)", restrictionLevel: "low" },
            { id: 3, cityName: "Botucatu", name: "Aniversário da Cidade", startDate: "2025-04-14", endDate: "2025-04-14", isHoliday: true, description: "Feriado municipal do aniversário de Botucatu (fundação: 14/04/1855)", restrictionLevel: "low" },
            { id: 4, cityName: "Bauru", name: "Aniversário da Cidade", startDate: "2025-08-01", endDate: "2025-08-01", isHoliday: true, description: "Feriado municipal do aniversário de Bauru (fundação: 01/08/1896)", restrictionLevel: "low" },
            { id: 5, cityName: "Ribeirão Preto", name: "Aniversário da Cidade", startDate: "2025-06-19", endDate: "2025-06-19", isHoliday: true, description: "Feriado municipal do aniversário de Ribeirão Preto (fundação: 19/06/1856)", restrictionLevel: "low" },
            { id: 6, cityName: "São Paulo", name: "Aniversário da Cidade", startDate: "2025-01-25", endDate: "2025-01-25", isHoliday: true, description: "Feriado municipal do aniversário de São Paulo (fundação: 25/01/1554)", restrictionLevel: "high" },
            { id: 7, cityName: "Campinas", name: "Aniversário da Cidade", startDate: "2025-07-14", endDate: "2025-07-14", isHoliday: true, description: "Feriado municipal do aniversário de Campinas (fundação: 14/07/1774)", restrictionLevel: "medium" },
            { id: 8, cityName: "São Carlos", name: "Aniversário da Cidade", startDate: "2025-11-04", endDate: "2025-11-04", isHoliday: true, description: "Feriado municipal do aniversário de São Carlos (fundação: 04/11/1857)", restrictionLevel: "low" },
            
            // Eventos regulares
            { id: 9, cityName: "Jaú", name: "Festa do Rodeio", startDate: "2025-06-10", endDate: "2025-06-20", isHoliday: false, description: "Evento com grande circulação de veículos", restrictionLevel: "medium" },
            { id: 10, cityName: "Botucatu", name: "Festival de Inverno", startDate: "2025-07-15", endDate: "2025-07-30", isHoliday: false, description: "Evento cultural e gastronômico", restrictionLevel: "low" },
            { id: 11, cityName: "Bauru", name: "Exposição Agropecuária", startDate: "2025-08-05", endDate: "2025-08-15", isHoliday: false, description: "Feira agropecuária com shows", restrictionLevel: "high" },
            { id: 12, cityName: "Ribeirão Preto", name: "Agrishow", startDate: "2025-04-27", endDate: "2025-05-01", isHoliday: false, description: "Feira internacional de tecnologia agrícola", restrictionLevel: "high" },
            { id: 13, cityName: "São Paulo", name: "Virada Cultural", startDate: "2025-05-17", endDate: "2025-05-18", isHoliday: false, description: "Festival de 24 horas com eventos culturais pela cidade", restrictionLevel: "medium" }
        ],
        
        // Restrições para caminhões
        truckRestrictions: [
            { id: 1, cityName: "Dois Córregos", dayType: "weekday", startTime: "07:00", endTime: "09:00", restrictionType: "partial", description: "Restrição parcial para caminhões de grande porte no centro", affectedVehicles: ["truck1", "truck5", "truck6", "truck7", "truck9"] },
            { id: 2, cityName: "Jaú", dayType: "weekday", startTime: "17:00", endTime: "20:00", restrictionType: "partial", description: "Restrição parcial para todos os caminhões no centro", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 3, cityName: "Botucatu", dayType: "weekend", startTime: "08:00", endTime: "18:00", restrictionType: "total", description: "Proibição total para caminhões na área central", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 4, cityName: "Bauru", dayType: "all", startTime: "07:00", endTime: "22:00", restrictionType: "rodizio", description: "Sistema de rodízio para todos os caminhões", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 5, cityName: "Campinas", dayType: "all", startTime: "06:00", endTime: "20:00", restrictionType: "total", description: "Zona de Máxima Restrição de Circulação (ZMRC) - proibição total para caminhões", affectedVehicles: ["truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 6, cityName: "Campinas", dayType: "weekday", startTime: "07:00", endTime: "10:00", restrictionType: "partial", description: "Restrição adicional para todos os tipos de caminhões nas vias principais", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 7, cityName: "São Paulo", dayType: "all", startTime: "04:00", endTime: "22:00", restrictionType: "total", description: "Zona de Máxima Restrição de Circulação - proibição total", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 8, cityName: "Ribeirão Preto", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição de circulação no centro expandido", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 9, cityName: "Piracicaba", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição na região central", affectedVehicles: ["truck3", "truck4", "truck5", "truck7"] },
            { id: 10, cityName: "São Carlos", dayType: "all", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição no centro comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 11, cityName: "Sorocaba", dayType: "weekday", startTime: "08:00", endTime: "17:00", restrictionType: "partial", description: "Restrição para veículos pesados na área central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 12, cityName: "Americana", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição na zona comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 13, cityName: "Limeira", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição no perímetro central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 14, cityName: "Rio Claro", dayType: "weekday", startTime: "07:30", endTime: "18:30", restrictionType: "partial", description: "Restrição na área central", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 15, cityName: "Araraquara", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição para veículos pesados no centro", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] }
        ]
    };

    // Variáveis globais
    let map;
    let directionsService;
    let directionsRenderer;
    let autocomplete;
    let markers = [];
    let currentOptimizedPath = []; // Array para armazenar os IDs do caminho otimizado atual
    let poiMarkers = [];
    let eventMarkers = [];
    let locationId = 2; // Começa em 2 porque 1 é reservado para a origem
    let locations = [mockData.origin];
    let activeInfoWindow = null;
    let routePath = null;
    let routeAnimationTimeout = null;
    let showPOIs = true;
    let customTooltip = null;
    let directionsRendererInitialized = false; // Flag para rastrear inicialização correta do renderer
    // Variáveis para rotas alternativas
    let alternativeRoutes = [];
    let currentRouteIndex = 0;
    let currentDisplayedRoute = null; // Guarda referência à rota atualmente exibida
    let allRoutePolylines = []; // Armazena referências a todas as polylines criadas
    let tspSolver = null; // Instância do solver TSP
    
    // Função para processar CEP em formato x.y.z.w-abcd
    function formatCEP(cep) {
        // Remover qualquer caracter não numérico
        let numericCEP = cep.replace(/\D/g, '');
        
        // Formatar como xxxxx-xxx
        if (numericCEP.length >= 8) {
            return numericCEP.substring(0, 5) + '-' + numericCEP.substring(5, 8);
        }
        
        return cep; // Retornar original se não for possível formatar
    }
    
    // Função global auxiliar para exibir notificações de forma segura
    function showNotification(message, type = 'info', targetSelector = '.route-controls', autoRemove = true, duration = 5000) {
        console.log(`Notificação [${type}]: ${message}`);
        
        // Criar elemento de notificação
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} mt-2`;
        notification.innerHTML = message;
        
        // Tentar diferentes locais na ordem de prioridade
        const possibleTargets = [
            targetSelector,
            '.route-controls',
            '#sidebar',
            '.sidebar-content',
            '.tab-content:first-child',
            'body'
        ];
        
        let targetElement = null;
        
        // Tentar cada seletor até encontrar um elemento válido
        for (const selector of possibleTargets) {
            try {
                const element = document.querySelector(selector);
                if (element) {
                    targetElement = element;
                    break;
                }
            } catch (err) {
                console.warn(`Erro ao buscar seletor ${selector}:`, err);
            }
        }
        
        // Anexar notificação se encontrou um elemento válido
        if (targetElement) {
            try {
                targetElement.appendChild(notification);
                
                // Auto-remover após um tempo, se solicitado
                if (autoRemove) {
                    setTimeout(() => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        } catch (err) {
                            console.warn("Erro ao remover notificação:", err);
                        }
                    }, duration);
                }
                
                return notification;
            } catch (err) {
                console.error("Erro ao adicionar notificação:", err);
            }
        } else {
            console.warn("Não foi possível exibir notificação, nenhum elemento alvo encontrado");
        }
        
        return null;
    }

    // Inicialização
    document.addEventListener("DOMContentLoaded", function() {
        initMap();
        initAutocomplete();
        initTabNavigation();
        initEventListeners();
        initBottomPanel(); // Inicializar o novo painel inferior
        
        // Exibir a origem no mapa
        addMarkerForLocation(mockData.origin, 0);
        
        // Definir data inicial como a data atual por padrão
        const today = new Date();
        const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
        
        // Calcular a data final (hoje + 7 dias)
        const endDate = new Date();
        endDate.setDate(today.getDate() + 7);
        const formattedEndDate = endDate.toISOString().split('T')[0];
        
        // Definir os valores dos campos de data
        document.getElementById('start-date').value = formattedToday;
        document.getElementById('end-date').value = formattedEndDate;
        
        console.log(`Datas definidas automaticamente: de ${formattedToday} até ${formattedEndDate}`);
        
        // Inicializar currentOptimizedPath com a origem para mostrar eventos/restrições iniciais
        currentOptimizedPath = [mockData.origin.id];
        
        // Chamar funções para mostrar eventos e restrições para a origem com base nas datas atuais
        filterEventsByDate();
        
        // Mostrar mensagem de ajuda
        console.log("Campos de data inicializados com datas atuais e eventos/restrições para origem configurados");
    });

    // Inicializa o mapa
    function initMap() {
        // Inicializar com a data atual e data atual + 30 dias
        const today = new Date();
        const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
        
        // Calcular a data final (hoje + 30 dias)
        const endDate = new Date();
        endDate.setDate(today.getDate() + 30);
        const formattedEndDate = endDate.toISOString().split('T')[0];
        
        // Definir os valores dos campos de data
        document.getElementById('start-date').value = formattedToday;
        document.getElementById('end-date').value = formattedEndDate;
        
        console.log(`Datas definidas automaticamente na inicialização do mapa: de ${formattedToday} até ${formattedEndDate}`);
        
        // Opções do mapa
        const mapOptions = {
            center: { lat: -22.3673, lng: -48.3822 }, // Dois Córregos
            zoom: 8,
            mapTypeControl: true,
            fullscreenControl: true,
            streetViewControl: true,
            zoomControl: true,
            gestureHandling: 'greedy' // Permite zoom com scroll sem precionar Ctrl
        };
        
        // Criar o mapa
        map = new google.maps.Map(document.getElementById("map"), mapOptions);
        
        // Inicializar o serviço de direções
        directionsService = new google.maps.DirectionsService();
        
        try {
            console.log("Inicializando DirectionsRenderer...");
            directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true, // Não mostrar marcadores padrão do Google
                preserveViewport: true,
                polylineOptions: {
                    strokeColor: '#1976D2',
                    strokeOpacity: 0.7,
                    strokeWeight: 4
                }
            });
            directionsRenderer.setMap(map);
            directionsRendererInitialized = true;
            console.log("DirectionsRenderer inicializado com sucesso");
        } catch (err) {
            console.error("Erro ao inicializar DirectionsRenderer:", err);
            showNotification("Erro ao inicializar o sistema de rotas. Recarregue a página.", "danger");
        }
        
        // Criar o tooltip personalizado
        createCustomTooltip();
    }

    // Inicializa o autocomplete
    function initAutocomplete() {
        const input = document.getElementById('location-search');
        const options = {
            types: ['geocode'],
            componentRestrictions: { country: 'br' }
        };
        
        autocomplete = new google.maps.places.Autocomplete(input, options);
        
        // Quando um local é selecionado no autocomplete
        autocomplete.addListener('place_changed', function() {
            const place = autocomplete.getPlace();
            
            if (!place.geometry) {
                // Substituir alert por notificação inline mais suave
                const notifyWarning = document.createElement('div');
                notifyWarning.className = 'alert alert-warning mt-2';
                notifyWarning.innerHTML = `Não foi possível encontrar o endereço selecionado.`;
                document.querySelector('#location-form').appendChild(notifyWarning);
                
                // Remover a notificação após alguns segundos
                setTimeout(() => {
                    if (notifyWarning && notifyWarning.parentNode) {
                        notifyWarning.parentNode.removeChild(notifyWarning);
                    }
                }, 5000);
                return;
            }
            
            // Adicionar o local à lista
            const newLocation = {
                id: locationId++,
                name: formatLocationName(place.name),
                address: formatLocationName(place.formatted_address),
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            locations.push(newLocation);
            
            // Adicionar marcador e atualizar a lista
            addMarkerForLocation(newLocation, locations.length - 1);
            updateLocationsList();
            
            // Limpar o campo de busca
            input.value = '';
        });
    }

    // Inicializa a navegação por abas
    function initTabNavigation() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Desativar todas as abas
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Ativar a aba clicada
                button.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });
    }

    // Inicializa o painel inferior animado
    function initBottomPanel() {
        const bottomPanel = document.getElementById('bottom-panel');
        const bottomPanelTab = document.getElementById('bottom-panel-tab');
        const mapContainer = document.querySelector('.map-container');
        
        if (!bottomPanel || !bottomPanelTab) {
            console.error("Elementos do painel inferior não encontrados");
            return;
        }
        
        // Estado inicial: painel colapsado (apenas aba visível)
        let isPanelExpanded = false;
        
        // Função para alternar o estado do painel
        function toggleBottomPanel() {
            if (isPanelExpanded) {
                // Colapsar o painel
                bottomPanel.classList.remove('expanded');
                bottomPanel.classList.add('collapsed');
                mapContainer.classList.remove('with-bottom-panel');
            } else {
                // Expandir o painel
                bottomPanel.classList.add('expanded');
                bottomPanel.classList.remove('collapsed');
                mapContainer.classList.add('with-bottom-panel');
            }
            
            // Inverter o estado
            isPanelExpanded = !isPanelExpanded;
        }
        
        // Adicionar evento de clique na aba
        bottomPanelTab.addEventListener('click', toggleBottomPanel);
        
        // Também atualiza o painel quando uma rota é otimizada
        document.addEventListener('routeOptimized', function() {
            // Se o painel ainda não foi expandido, expandir automaticamente
            if (!isPanelExpanded) {
                toggleBottomPanel();
            }
            
            // Animar as colunas do painel com efeito escalonado
            const columns = document.querySelectorAll('.panel-column');
            columns.forEach((column, index) => {
                setTimeout(() => {
                    column.classList.add('fadeIn');
                }, index * 150);
            });
        });
        
        console.log("Painel inferior inicializado com sucesso");
    }
    
    function initEventListeners() {
        // Toggle para mostrar/esconder a sidebar
        document.getElementById('toggle-sidebar').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('sidebar-hidden');
        });
        
        // Botão para fechar a sidebar em telas pequenas
        document.querySelector('.sidebar-close').addEventListener('click', function() {
            document.getElementById('sidebar').classList.add('sidebar-hidden');
        });
        
        // Upload de arquivo com suporte para drag and drop
        const fileUploadInput = document.getElementById('file-upload');
        const uploadArea = document.getElementById('upload-area');
        
        // Evento para quando o arquivo é selecionado pelo input
        fileUploadInput.addEventListener('change', handleFileUpload);
        
        // Eventos de drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Adicionar classe visual quando o arquivo está sendo arrastado sobre a área
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('dragover');
            }, false);
        });
        
        // Remover classe visual quando o arquivo sai da área ou é solto
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('dragover');
            }, false);
        });
        
        // Processar o arquivo quando for solto na área
        uploadArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length) {
                fileUploadInput.files = files;
                handleFileUpload({target: fileUploadInput});
            }
        }, false);
        
        // Botão para otimizar rota
        document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
        
        // Filtrar eventos automaticamente ao mudar as datas
        document.getElementById('start-date').addEventListener('change', filterEventsByDate);
        document.getElementById('end-date').addEventListener('change', filterEventsByDate);
        
        // Botões de controle do mapa
        document.getElementById('zoom-to-fit').addEventListener('click', zoomToFitAllMarkers);
        document.getElementById('toggle-poi').addEventListener('click', togglePointsOfInterest);
        
        // Botões da aba de relatório
        document.getElementById('save-route').addEventListener('click', saveRoute);
        document.getElementById('print-route').addEventListener('click', printRoute);
        
        // Seletor de rotas alternativas
        document.getElementById('alternative-routes').addEventListener('change', function(e) {
            const selectedIndex = parseInt(e.target.value);
            if (alternativeRoutes && alternativeRoutes.length > selectedIndex) {
                const selectedRoute = alternativeRoutes[selectedIndex];
                
                console.log("Selecionando rota alternativa:", selectedIndex);
                console.log("Caminho da rota selecionada:", selectedRoute.path);
                
                // Informar sobre a troca de rota
                console.log("Alternando para rota: " + selectedIndex + ", reconstruindo elementos...");
                showNotification("Alternando para rota " + (selectedIndex + 1) + "...", "info");
                
                // Salvar o caminho selecionado para uso após a limpeza
                const pathToUse = selectedRoute.path;
                
                // Parar qualquer animação em andamento
                if (routeAnimationTimeout) {
                    clearTimeout(routeAnimationTimeout);
                    routeAnimationTimeout = null;
                }
                
                // Limpar TUDO - todas as rotas, marcadores, eventos, e estado
                clearRoute();
                clearAllPolylines();
                clearPOIMarkers();
                clearEventMarkers();
                
                // Resetar o mapa para forçar atualização
                if (map) {
                    try {
                        const mapCenter = map.getCenter();
                        map.setCenter(mapCenter);
                    } catch (e) {
                        console.error("Erro ao recentrar mapa:", e);
                    }
                }
                
                // Delay maior para garantir limpeza completa antes de reconstruir
                setTimeout(() => {
                    console.log("Reconstruindo a rota...");
                    
                    // Resetar DirectionsRenderer para garantir um estado limpo
                    if (directionsRenderer) {
                        try {
                            directionsRenderer.setMap(null);
                            directionsRenderer = new google.maps.DirectionsRenderer({
                                suppressMarkers: true,
                                preserveViewport: true,
                                polylineOptions: {
                                    strokeColor: '#1976D2',
                                    strokeOpacity: 0.7,
                                    strokeWeight: 4
                                }
                            });
                            directionsRenderer.setMap(map);
                            directionsRenderer.setDirections({routes: []});
                        } catch (e) {
                            console.error("Erro ao resetar directionsRenderer:", e);
                        }
                    }
                    
                    // Reordenar marcadores
                    reorderMarkers(pathToUse);
                    
                    // Desenhar nova rota com delay adicional para garantir que o mapa está pronto
                    setTimeout(() => {
                        console.log("Desenhando nova rota: ", selectedIndex);
                        
                        // Atualizar índice atual de rota
                        currentRouteIndex = selectedIndex;
                        currentDisplayedRoute = pathToUse;
                        
                        // Desenhar nova rota
                        drawRouteOnMap(pathToUse, "truck1");
                        
                        // Mostrar pontos de interesse e eventos somente após desenhar a rota
                        setTimeout(() => {
                            showPointsOfInterestOnRoute(pathToUse);
                            showEventsForCitiesOnRoute(pathToUse);
                        }, 200);
                    }, 200);
                }, 400);
                
                // Atualizar restrições
                showTruckRestrictionsForCitiesOnRoute(selectedRoute.path, null); // null para mostrar todos os tipos
                
                // Atualizar rota atual
                currentRouteIndex = selectedIndex;
            }
        });
    }

    // Função para tratar o upload de arquivo
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            parseCEPFile(content);
        };
        reader.readAsText(file);
    }

    // Formatar texto para iniciar com maiúscula e resto minúscula
    function formatLocationName(name) {
        // Se o nome for vazio, retornar
        if (!name) return name;
        
        // Dividir o nome em palavras
        return name.split(' ').map(word => {
            if (!word) return '';
            // Primeira letra maiúscula, resto minúscula
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }).join(' ');
    }
    
    // Função para processar o arquivo de CEPs
    function parseCEPFile(content) {
        // Verificar se content é válido
        if (!content || typeof content !== 'string') {
            console.error('Conteúdo do arquivo inválido:', content);
            return;
        }
        
        const lines = content.split('\n');
        let newLocations = [];
        
        // CEPs com coordenadas conhecidas para as principais cidades paulistas
        const knownCEPs = {
            '14020-260': {name: 'Ribeirão Preto', lat: -21.1767, lng: -47.8208},
            '17560-000': {name: 'Vera Cruz', lat: -22.2205, lng: -49.8233},
            '17580-000': {name: 'Pompéia', lat: -22.1075, lng: -50.1764},
            '17280-000': {name: 'Pederneiras', lat: -22.3518, lng: -48.7780},
            '17220-000': {name: 'Itapuí', lat: -22.2323, lng: -48.7186},
            '17340-000': {name: 'Barra Bonita', lat: -22.4910, lng: -48.5582},
            '17380-000': {name: 'Brotas', lat: -22.2794, lng: -48.1251},
            '17200-000': {name: 'Jaú', lat: -22.2936, lng: -48.5592},
            '18600-000': {name: 'Botucatu', lat: -22.8837, lng: -48.4437},
            '17120-000': {name: 'Agudos', lat: -22.4696, lng: -48.9870},
            '17210-000': {name: 'Igaraçu do Tietê', lat: -22.5092, lng: -48.5597},
            '17040-001': {name: 'Bauru', lat: -22.3246, lng: -49.0871},
            '17400-000': {name: 'Garça', lat: -22.2132, lng: -49.6546},
            '17480-000': {name: 'Marília', lat: -22.2171, lng: -49.9501},
            '17300-000': {name: 'Dois Córregos', lat: -22.3673, lng: -48.3822},
            '18430-035': {name: 'Ribeirão Branco', lat: -24.2231, lng: -48.7635} // Coordenadas corretas para Ribeirão Branco-SP
        };
        
        // Geocodificador para CEPs desconhecidos
        const geocoder = new google.maps.Geocoder();
        let geocodeQueue = [];
        
        for (const line of lines) {
            if (!line.trim()) continue;
            
            const parts = line.split(',');
            if (parts.length < 2) continue;
            
            const cep = parts[0].trim();
            let name = parts[1].trim();
            
            // Formatar nome (primeira letra maiúscula, resto minúscula)
            name = formatLocationName(name);
            
            if (cep && name) {
                // Formatar CEP para garantir consistência no formato xxxxx-xxx
                const formattedCEP = formatCEP(cep);
                
                // Verificar se é um CEP conhecido (tentando com o formato fornecido ou com formato padronizado)
                if (knownCEPs[cep] || knownCEPs[formattedCEP]) {
                    // Usar o CEP que for encontrado no banco de dados
                    const knownLocation = knownCEPs[cep] || knownCEPs[formattedCEP];
                    const formattedCityName = formatLocationName(knownLocation.name);
                    
                    // Log para depuração
                    console.log(`CEP ${cep} encontrado na base de dados: ${knownLocation.name}, coordenadas: ${knownLocation.lat}, ${knownLocation.lng}`);
                    
                    newLocations.push({
                        id: locationId++,
                        name: name,
                        address: `${name}, ${formattedCityName}, SP, Brasil`,
                        zipCode: cep,
                        latitude: knownLocation.lat,
                        longitude: knownLocation.lng,
                        isOrigin: false
                    });
                } else {
                    // Adicionar à fila para geocodificação
                    geocodeQueue.push({
                        cep: cep,
                        name: name // Nome já formatado
                    });
                }
            }
        }
        
        // Processar os CEPs conhecidos imediatamente
        if (newLocations.length > 0) {
            // Para cada novo local, adicionar à lista e ao mapa
            newLocations.forEach((location, index) => {
                locations.push(location);
                addMarkerForLocation(location, locations.length - 1);
            });
            
            // Atualizar a lista de locais
            updateLocationsList();
            
            // Ajustar o zoom para mostrar todos os pontos
            zoomToFitAllMarkers();
        }
        
        // Processar a fila de geocodificação para CEPs desconhecidos
        if (geocodeQueue.length > 0) {
            // Adicionar uma notificação inline sobre o processo de geocodificação
            const fileUploadElement = document.querySelector('.file-upload');
            if (fileUploadElement) {
                const statusElement = document.createElement('div');
                statusElement.className = 'alert alert-info mt-3';
                statusElement.id = 'geocode-status';
                statusElement.innerHTML = `Processando ${geocodeQueue.length} endereços adicionais...`;
                fileUploadElement.appendChild(statusElement);
            }
            
            let processedCount = 0;
            
            // Função para processar a fila de geocodificação
            function processGeocodingQueue() {
                if (geocodeQueue.length === 0) {
                    // Todos os geocodes foram processados
                    const statusElement = document.getElementById('geocode-status');
                    if (statusElement && statusElement.parentNode) {
                        statusElement.parentNode.removeChild(statusElement);
                    }
                    return;
                }
                
                const item = geocodeQueue.shift();
                const address = `${item.cep}, Brasil`;
                
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const location = results[0].geometry.location;
                        
                        const newLocation = {
                            id: locationId++,
                            name: item.name, // Já vem formatado de antes
                            address: `${item.name}, ${formatLocationName(address)}`,
                            zipCode: item.cep,
                            latitude: location.lat(),
                            longitude: location.lng(),
                            isOrigin: false
                        };
                        
                        locations.push(newLocation);
                        addMarkerForLocation(newLocation, locations.length - 1);
                        
                        // Atualizar a lista de locais
                        updateLocationsList();
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Ajustar o zoom
                        zoomToFitAllMarkers();
                        
                        // Continuar com o próximo após um curto delay (para evitar limites de API)
                        setTimeout(processGeocodingQueue, 200);
                    } else {
                        // CORREÇÃO: Não adicionar CEPs que não puderam ser geocodificados
                        console.warn(`CEP não encontrado: ${item.cep} - ${item.name}. Este local não será adicionado.`);
                        
                        // Mostrar notificação para o usuário sobre o CEP não encontrado
                        const notifyError = document.createElement('div');
                        notifyError.className = 'alert alert-warning mt-2';
                        notifyError.innerHTML = `CEP não encontrado: ${item.cep} - ${item.name}`;
                        document.querySelector('.file-upload').appendChild(notifyError);
                        
                        // Remover a notificação após alguns segundos
                        setTimeout(() => {
                            if (notifyError && notifyError.parentNode) {
                                notifyError.parentNode.removeChild(notifyError);
                            }
                        }, 5000);
                        
                        // Atualizar o status sem adicionar o local
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Continuar com o próximo após um curto delay
                        setTimeout(processGeocodingQueue, 200);
                    }
                });
            }
            
            // Iniciar o processamento da fila
            processGeocodingQueue();
        }
        
        // Limpar o campo de upload
        document.getElementById('file-upload').value = '';
        
        // Contar as linhas válidas do arquivo original
        const validLines = lines.filter(line => {
            if (!line.trim()) return false;
            const parts = line.split(',');
            return parts.length >= 2 && parts[0].trim() && parts[1].trim();
        }).length;
        
        // Feedback para o usuário com notificação mais moderna
        const uploadArea = document.getElementById('upload-area');
        
        // Salvar o conteúdo original do componente de upload
        const originalContent = uploadArea.innerHTML;
        
        // Substituir com a mensagem de sucesso
        uploadArea.innerHTML = `
            <div class="upload-success">
                <i class="fas fa-check-circle upload-success-icon"></i>
                <h5 class="mt-2">Arquivo processado com sucesso!</h5>
                <p class="upload-success-text">${validLines} ${validLines === 1 ? 'local adicionado' : 'locais adicionados'}</p>
            </div>
        `;
        
        // Adicionar classes para animação
        uploadArea.classList.add('success');
        
        // Restaurar o componente original após alguns segundos
        setTimeout(() => {
            // Fade out
            uploadArea.classList.add('fading');
            
            setTimeout(() => {
                // Restaurar conteúdo original
                uploadArea.innerHTML = originalContent;
                uploadArea.classList.remove('success', 'fading');
            }, 300);
        }, 2500);
    }

    // Função para extrair CEP de um objeto Place
    function getZipCodeFromPlace(place) {
        if (!place.address_components) return "";
        
        for (let component of place.address_components) {
            if (component.types.includes('postal_code')) {
                return component.long_name;
            }
        }
        return "";
    }

    // Adiciona um marcador no mapa para um local
    // targetArray permite especificar onde o marcador será armazenado (para reordenação segura)
    function addMarkerForLocation(location, index, targetArray = null) {
        // Verificar se o local já tem um marcador existente antes de criar um novo
        const existingMarker = markers.find(m => String(m.location.id) === String(location.id));
        
        if (existingMarker) {
            console.log(`Reutilizando marcador existente para ${location.name} (ID: ${location.id})`);
            // Atualizar apenas o número de sequência no marcador existente
            existingMarker.marker.setLabel({
                text: index === 0 ? 'O' : (index).toString(),
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            });
            existingMarker.marker.setMap(map); // Garantir que está visível no mapa
            
            // Se for para adicionar a outro array, fazer isso
            if (targetArray) {
                targetArray.push(existingMarker);
            }
            
            return existingMarker;
        }
        
        // Caso não exista marcador, criar um novo
        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id})`);
        
        // Verificar se está na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        const isSameCityAsOrigin = origin && isSameCity(location, origin);
        
        // Ícone personalizado com número de sequência
        const markerLabel = index === 0 ? 'O' : (index).toString();
        
        // Cor específica para a origem e pontos na mesma cidade
        let markerColor = '#1976D2'; // Cor padrão (azul)
        if (index === 0) {
            markerColor = '#FF0000'; // Origem (vermelho)
        } else if (isSameCityAsOrigin) {
            markerColor = '#FF9800'; // Ponto na mesma cidade (laranja)
        }
        
        // Verificar se deve animar o marcador (apenas pontos na mesma cidade)
        const animation = isSameCityAsOrigin && !location.isOrigin ? 
                         google.maps.Animation.BOUNCE : null;
        
        console.log(`Configurando marcador para ${location.name} - Mesma cidade da origem: ${isSameCityAsOrigin}`);
        
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: location.name,
            label: {
                text: markerLabel,
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: markerColor,
                fillOpacity: 1,
                strokeWeight: 0,
                scale: 12
            },
            animation: animation,
            zIndex: index === 0 ? 1000 : (isSameCityAsOrigin ? 500 : 100) // Ordem: Origem > Mesma cidade > Outros
        });
        
        // Infowindow com detalhes do local
        const infowindow = new google.maps.InfoWindow({
            content: `
                <div>
                    <h5>${location.name}</h5>
                    <p>${location.address}</p>
                    ${location.zipCode ? `<p>CEP: ${location.zipCode}</p>` : ''}
                    ${!location.isOrigin ? `<button onclick="removeLocation('${location.id}')" class="btn btn-sm btn-danger">Remover</button>` : ''}
                </div>
            `
        });
        
        // Event listener para abrir o infowindow
        marker.addListener('click', function() {
            if (activeInfoWindow) {
                activeInfoWindow.close();
            }
            infowindow.open(map, marker);
            activeInfoWindow = infowindow;
            
            // Se o local estiver na mesma cidade da origem, destacar visualmente
            if (isSameCity(location, locations.find(loc => loc.isOrigin))) {
                marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(() => marker.setAnimation(null), 1500);
            }
        });
        
        // Criar objeto do marcador
        const markerObj = { marker, location, infowindow };
        
        // Armazenar o marcador na array principal ou na array alvo, se fornecida
        if (targetArray) {
            targetArray.push(markerObj);
        } else {
            markers.push(markerObj);
        }
        
        return markerObj;
    }

    // Atualiza a lista de locais no sidebar com base na ordem dos marcadores
    function updateLocationsList() {
        const container = document.getElementById('locations-list');
        if (!container) {
            console.error("Elemento 'locations-list' não encontrado!");
            return;
        }
        container.innerHTML = '';
        
        // Extrair os locais não-origem dos marcadores para preservar a ordem
        const orderedLocations = markers
            .map(m => m.location)
            .filter(loc => !loc.isOrigin);
        
        // Adicionar cada local à lista na ordem dos marcadores
        orderedLocations.forEach((location, index) => {
            const locationItem = document.createElement('div');
            locationItem.className = 'location-item';
            locationItem.innerHTML = `
                <div>
                    <div><span class="badge bg-primary">${index + 1}</span> ${location.name}</div>
                    <div class="location-address">${location.address}</div>
                </div>
                <button class="btn btn-sm btn-danger" onclick="removeLocation('${location.id}')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                </button>
            `;
            container.appendChild(locationItem);
        });
    }

    // Remove um local da lista e do mapa
    function removeLocation(id) {
        console.log("Removendo localização com ID:", id, "Tipo:", typeof id);
        
        // Converter para string para garantir consistência na comparação
        const idStr = String(id);
        
        // Remover o local da lista
        locations = locations.filter(loc => String(loc.id) !== idStr);
        
        // Remover o marcador do mapa - usar String para garantir comparação consistente
        const markerIndex = markers.findIndex(m => String(m.location.id) === idStr);
        if (markerIndex !== -1) {
            console.log(`Marcador encontrado no índice ${markerIndex} e será removido`);
            markers[markerIndex].marker.setMap(null);
            markers.splice(markerIndex, 1);
        } else {
            console.log(`Nenhum marcador encontrado para o ID ${idStr}`);
        }
        
        // Atualizar a lista e reindexar os marcadores
        updateLocationsList();
        reindexMarkers();
        
        // Se houver uma rota atual, limpá-la
        clearRoute();
    }

    // Reindexar os marcadores após remoção
    function reindexMarkers() {
        markers.forEach((markerObj, index) => {
            if (!markerObj.location.isOrigin) {
                markerObj.marker.setLabel({
                    text: index.toString(),
                    color: 'white',
                    fontSize: '14px',
                    fontWeight: 'bold'
                });
            }
        });
    }

    // Limpar rota atual e marcadores relacionados
    // Função para limpar todas as polylines do mapa
    function clearAllPolylines() {
        console.log("Limpando todas as polylines do mapa...");
        
        // Limpar todas as polylines registradas
        if (allRoutePolylines.length > 0) {
            console.log(`Limpando ${allRoutePolylines.length} polylines registradas`);
            allRoutePolylines.forEach(polyline => {
                try {
                    if (polyline) polyline.setMap(null);
                } catch (e) {
                    console.error("Erro ao limpar polyline:", e);
                }
            });
            allRoutePolylines = [];
        }
        
        // Outras limpezas específicas de polylines
        if (routePath) {
            try {
                routePath.setMap(null);
                routePath = null;
                console.log("Polyline principal removida");
            } catch (e) {
                console.error("Erro ao remover polyline principal:", e);
            }
        }
        
        // Reset do mapa como medida adicional
        try {
            if (map) {
                const mapCenter = map.getCenter();
                map.setCenter(mapCenter);
                console.log("Mapa recentrado para forçar atualização");
            }
        } catch (e) {
            console.error("Erro ao recentrar mapa:", e);
        }
    }

    function clearRoute() {
        console.log("Limpando rota atual...");
        
        // Limpar o renderizador de direções
        if (directionsRendererInitialized && directionsRenderer) {
            try {
                // Limpar rotas existentes
                directionsRenderer.setDirections({ routes: [] });
                
                // Em alguns casos, pode ser necessário recriar o renderer
                directionsRenderer.setMap(null);
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: true,
                    preserveViewport: true,
                    polylineOptions: {
                        strokeColor: '#1976D2',
                        strokeOpacity: 0.7,
                        strokeWeight: 4
                    }
                });
                directionsRenderer.setMap(map);
                console.log("DirectionsRenderer recriado com sucesso");
            } catch (err) {
                console.error("Erro ao limpar direções:", err);
            }
        } else {
            console.warn("directionsRenderer não está disponível ou não inicializado");
        }
        
        // Limpar timeout de animação se existir
        if (routeAnimationTimeout) {
            clearTimeout(routeAnimationTimeout);
            routeAnimationTimeout = null;
            console.log("Animação de rota interrompida");
        }
        
        // Limpar todas as polylines
        clearAllPolylines();
        
        // Reset das variáveis de controle
        currentDisplayedRoute = null;
        
        // Limpar marcadores de POI
        clearPOIMarkers();
        
        // Limpar marcadores de eventos
        clearEventMarkers();
        
        // Resetar o resumo da rota - com verificação de segurança
        const routeSummary = document.getElementById('route-summary');
        if (routeSummary) {
            routeSummary.style.display = 'none';
        }
        document.getElementById('save-route').disabled = true;
        document.getElementById('print-route').disabled = true;
    }

    // Limpar marcadores de pontos de interesse
    function clearPOIMarkers() {
        poiMarkers.forEach(marker => marker.setMap(null));
        poiMarkers = [];
    }

    // Limpar marcadores de eventos
    function clearEventMarkers() {
        eventMarkers.forEach(marker => marker.setMap(null));
        eventMarkers = [];
    }

    // Otimizar a rota
    function optimizeRoute() {
        // Verificar se há pelo menos um destino além da origem
        if (locations.length <= 1) {
            // Usar função auxiliar para mostrar notificação
            showNotification('Adicione pelo menos um destino para calcular a rota.', 'warning', '.route-controls');
            return;
        }
        
        // Mostrar spinner de carregamento centralizado no mapa
        showLoadingSpinner();
        
        // Mostrar loading no botão também
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = '<span class="spinner-border" role="status" aria-hidden="true"></span> Calculando...';
            optimizeBtn.disabled = true;
        }
        
        // IMPORTANTE: Assegurar que os marcadores originais sejam preservados antes de limpar
        const currentMarkers = [...markers]; // Criar uma cópia dos marcadores atuais
        
        // Limpar rota anterior
        clearRoute();
        
        // Usar caminhão padrão como veículo
        const vehicleType = "truck1"; // Caminhão 1 eixo como padrão
        
        // Calcular a rota otimizada (versão simplificada do TSP)
        calculateOptimizedRoute(vehicleType, false, currentMarkers);
    }

    // Calcular rota otimizada pelo algoritmo TSP
    function calculateOptimizedRoute(vehicleType, includeOriginReturn, savedMarkers = null) {
        try {
            console.log("Calculando rota otimizada...");
            
            // Limpar rotas alternativas existentes
            alternativeRoutes = [];
            currentRouteIndex = 0;
            
            // Primeiro vamos resolver o TSP para encontrar a ordem ideal dos pontos
            const origin = locations.find(loc => loc.isOrigin);
            const destinations = locations.filter(loc => !loc.isOrigin);
            
            if (!origin || !destinations.length) {
                console.error("Origem ou destinos não encontrados:", origin, destinations);
                return;
            }
            
            console.log("Origem:", origin);
            console.log("Destinos:", destinations);
            console.log("Todas as localizações:", locations);
            
            // Calcular aproximadamente a distância em linha reta total para verificação
            let straightLineDistance = 0;
            for (let i = 0; i < destinations.length; i++) {
                straightLineDistance += calculateDistance(
                    origin.latitude, origin.longitude,
                    destinations[i].latitude, destinations[i].longitude
                );
            }
            console.log("Distância aproximada em linha reta:", straightLineDistance.toFixed(1), "km");
            
            // Gerar rotas alternativas usando diferentes algoritmos
            generateAlternativeRoutes(origin, destinations, includeOriginReturn);
            
            if (alternativeRoutes.length === 0) {
                console.error("Nenhuma rota alternativa foi gerada!");
                // Substituir alert por notificação inline mais suave
                const notifyError = document.createElement('div');
                notifyError.className = 'alert alert-danger mt-2';
                notifyError.innerHTML = `Erro ao calcular a rota: nenhuma rota foi gerada`;
                document.querySelector('.route-controls').appendChild(notifyError);
                
                // Remover a notificação após alguns segundos
                setTimeout(() => {
                    if (notifyError && notifyError.parentNode) {
                        notifyError.parentNode.removeChild(notifyError);
                    }
                }, 5000);
                return;
            }
            
            // Verificar se temos rotas disponíveis
            if (!alternativeRoutes || alternativeRoutes.length === 0) {
                console.error("Nenhuma rota alternativa disponível. Criando uma rota padrão.");
                // Criar uma rota padrão com os pontos disponíveis
                alternativeRoutes = [{
                    path: locations.map(loc => loc.id),
                    distance: straightLineDistance * 1.3,
                    time: (straightLineDistance * 1.3 / 80) * 60 // tempo em minutos a 80km/h
                }];
            }
            
            // Usar a primeira rota (otimizada) como padrão
            const tspResult = alternativeRoutes[0];
            console.log("Resultado TSP:", tspResult);
            
            // Verificar se o resultado tem todos os dados necessários
            if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path)) {
                console.error("Resultado TSP inválido:", tspResult);
                return; // Interromper o processamento para evitar erros futuros
            }
            
            // Verificar se o resultado tem uma distância válida
            if (typeof tspResult.distance !== 'number' || isNaN(tspResult.distance) || tspResult.distance <= 0) {
                console.error("Distância TSP inválida:", tspResult.distance);
                // Assumir uma distância aproximada baseada na linha reta
                const safeDistance = straightLineDistance > 0 ? straightLineDistance * 1.3 : 50; // Valor default seguro
                tspResult.distance = safeDistance;
                console.log("Corrigido para:", tspResult.distance.toFixed(1), "km");
            }
            
            // IMPORTANTE: Método direto para processar a rota padrão 
            // em vez de usar o seletor que está causando problemas
            
            console.log("Tratando a rota padrão DIRETAMENTE (sem usar o event handler)...");
            
            // Salvar uma cópia de quais locais temos antes de iniciar
            const locationsBeforeRoute = [...locations];
            console.log("Locais antes de processar rota:", locationsBeforeRoute.map(l => `${l.name} (ID: ${l.id})`));
            
            // Limpar as rotas no mapa, mas não os marcadores
            if (directionsRenderer) {
                directionsRenderer.setMap(null);
            }
            
            // Criar um novo array para os marcadores reordenados
            const reorderedMarkers = [];
            
            // Verificar e corrigir possíveis problemas com os IDs da rota
            const fixedPath = tspResult.path.map(locationId => {
                if (typeof locationId === 'object' && locationId !== null) {
                    // Se for um objeto, extrair o ID
                    return locationId.id || locationId;
                }
                return locationId;
            });
            
            // Substituir o caminho original pelo caminho com IDs corrigidos
            tspResult.path = fixedPath;
            
            console.log("Caminho da rota após correção:", tspResult.path);
            
            // Processar a rota em ordem correta
            tspResult.path.forEach((locationId, index) => {
                // Garantir que o ID é uma string para comparação
                const locationIdStr = String(locationId);
                console.log(`Processando ID: ${locationIdStr}, tipo original: ${typeof locationId}, valor:`, locationId);
                
                const location = locations.find(loc => String(loc.id) === locationIdStr);
                
                if (!location) {
                    console.error(`Marcador não encontrado para localização ID: ${locationIdStr}`);
                    return;
                }
                
                console.log(`Processando ponto ${index} da rota: ${location.name} (ID: ${location.id})`);
                
                // Verificar se é a origem para garantir que o número de sequência seja 0
                const markerIndex = location.isOrigin ? 0 : index;
                
                // Verificar se já existe um marcador para este local
                const existingMarkerObj = markers.find(m => String(m.location.id) === locationIdStr);
                
                if (existingMarkerObj) {
                    // Atualizar rótulo do marcador com a nova sequência
                    existingMarkerObj.marker.setLabel({
                        text: markerIndex === 0 ? 'O' : markerIndex.toString(),
                        color: 'white',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    });
                    
                    // Garantir que o marcador esteja visível no mapa
                    existingMarkerObj.marker.setMap(map);
                    
                    // Adicionar à lista de marcadores reordenados
                    reorderedMarkers.push(existingMarkerObj);
                } else {
                    // Se o marcador não existir, criar um novo
                    const newMarkerObj = addMarkerForLocation(location, markerIndex, reorderedMarkers);
                    console.log(`Criado novo marcador para ${location.name} (ID: ${location.id})`);
                }
            });
            
            // Atualizar o array principal de marcadores com os reordenados
            if (reorderedMarkers.length > 0) {
                console.log(`Substituindo array de marcadores (${markers.length}) pelos reordenados (${reorderedMarkers.length})`);
                markers = [...reorderedMarkers];
            }
            
            // Verificar se temos localizações suficientes para desenhar a rota
            if (tspResult.path.length >= 2) {
                // Coletar localizações na ordem da rota para desenhar no mapa
                // Usamos os IDs já normalizados
                const pathLocations = [];
                
                // Adicionar cada localização verificando antes
                tspResult.path.forEach(id => {
                    const idStr = String(id);
                    
                    // Verificar que não é um objeto antes de pesquisar
                    if (typeof id === 'object') {
                        console.log(`ID de tipo objeto encontrado: ${JSON.stringify(id)}`);
                        return; // pular este ID
                    }
                    
                    const location = locations.find(loc => String(loc.id) === idStr);
                    if (!location) {
                        console.error(`Localização não encontrada para ID: ${idStr} durante o desenho da rota`);
                    } else {
                        // Só adicionar se encontrou a localização
                        pathLocations.push(location);
                    }
                });
                
                // Desenhar a rota no mapa usando as direções do Google
                // Usamos drawRouteOnMap que é a função correta definida no código
                drawRouteOnMap(tspResult.path, vehicleType);
                
                // Mostrar pontos de interesse e eventos ao longo da rota
                showPointsOfInterestOnRoute(tspResult.path);
                showEventsForCitiesOnRoute(tspResult.path);
                showTruckRestrictionsForCitiesOnRoute(tspResult.path, null); // null para mostrar todos os tipos
                
                // Atualizar a sequência de rota no relatório
                // A função não existe, então implementamos diretamente aqui
                const routeSequenceElement = document.getElementById('route-sequence');
                if (routeSequenceElement) {
                    // Limpar qualquer conteúdo anterior
                    routeSequenceElement.innerHTML = '';
                    
                    // Obter localizações na ordem da rota
                    // Garantir que todos os IDs já foram normalizados na etapa anterior
                    const routeLocations = tspResult.path.map(id => {
                        const idStr = String(id);
                        const location = locations.find(loc => String(loc.id) === idStr);
                        if (!location) {
                            console.error(`Localização não encontrada para ID: ${idStr} ao montar sequência`);
                        }
                        return location;
                    }).filter(loc => loc !== undefined);
                    
                    // Criar lista com a sequência de locais
                    const sequenceList = document.createElement('ol');
                    sequenceList.className = 'route-sequence-list';
                    
                    routeLocations.forEach((location, index) => {
                        const item = document.createElement('li');
                        // Destacar a origem
                        if (location.isOrigin) {
                            item.className = 'origin-point';
                            item.innerHTML = `<strong>${location.name}</strong> (Origem)`;
                        } else {
                            item.innerHTML = location.name;
                        }
                        sequenceList.appendChild(item);
                    });
                    
                    routeSequenceElement.appendChild(sequenceList);
                }
                
                // Adicionar também informações de distância e tempo estimado ao relatório
                const routeInfoElement = document.getElementById('route-summary');
                if (routeInfoElement) {
                    const distance = tspResult.distance ? tspResult.distance.toFixed(1) : "N/A";
                    const hours = Math.floor(tspResult.time / 60);
                    const minutes = Math.round(tspResult.time % 60);
                    const timeStr = hours > 0 ? `${hours}h ${minutes}min` : `${minutes}min`;
                    
                    routeInfoElement.innerHTML = `
                        <h3>Resumo da Rota</h3>
                        <p><strong>Distância total:</strong> ${distance} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeStr}</p>
                    `;
                }
                
                // Imprimir diagnóstico de marcadores após o processamento
                console.log(`Após processar rota: ${markers.length} marcadores principais, ${reorderedMarkers.length} marcadores reordenados`);
            } else {
                console.error("Número insuficiente de pontos para desenhar uma rota");
            }
            
            // Mostrar restrições para caminhões nas cidades da rota
            showTruckRestrictionsForCitiesOnRoute(tspResult.path, null); // null para mostrar todos os tipos
            
            // Atualizar o resumo da rota
            updateRouteSummary(tspResult, vehicleType);
        } catch (error) {
            console.error("Erro ao calcular rota otimizada:", error);
            // Substituir alert por notificação inline mais suave
            const notifyError = document.createElement('div');
            notifyError.className = 'alert alert-danger mt-2';
            notifyError.innerHTML = `Ocorreu um erro ao calcular a rota. Tente novamente.`;
            document.querySelector('.route-controls').appendChild(notifyError);
            
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyError && notifyError.parentNode) {
                    notifyError.parentNode.removeChild(notifyError);
                }
            }, 5000);
        }
        
        // Habilitar botões de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
        
        // Esconder o spinner de carregamento
        hideLoadingSpinner();
        
        // Restaurar o botão de otimizar
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
        }
        
        // Navegar para a aba de relatório
        document.querySelector('.tab-button[data-tab="report"]').click();
    }
    
    // Reordenar os marcadores para corresponder à sequência otimizada
    function reorderMarkers(optimizedPathIds) {
        console.log("Reordenando marcadores para caminho:", optimizedPathIds);
        
        // Atualizar a variável global com o caminho otimizado
        currentOptimizedPath = [...optimizedPathIds];
        
        // Atualizar eventos e restrições para o novo caminho otimizado
        filterEventsByDate(); // Isso também atualizará as restrições
        console.log("Quantidade de marcadores antes:", markers.length);
        
        // Preservar os marcadores originais
        const originalMarkers = [...markers];
        
        // Remover os marcadores existentes do mapa (sem destruí-los)
        markers.forEach(markerObj => {
            markerObj.marker.setMap(null);
        });
        
        // Criar uma cópia vazia para novos marcadores
        const newMarkers = [];
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = optimizedPathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.",
                "IDs da rota:", optimizedPathIds.map(id => String(id)));
            // Continuar mesmo com algumas localizações faltando
            // return;
        }
        
        // Verificar se é possível reutilizar marcadores existentes
        if (originalMarkers.length > 0) {
            console.log("Tentando reutilizar marcadores existentes");
            
            // Tentar reutilizar marcadores originais na nova ordem
            pathLocations
                .filter(loc => loc) // Remover localizações nulas
                .forEach((location, index) => {
                    // Encontrar o marcador original correspondente a esta localização
                    const originalMarker = originalMarkers.find(m => 
                        String(m.location.id) === String(location.id));
                    
                    if (originalMarker) {
                        // Reutilizar o marcador, atualizando apenas seu número de sequência
                        const marker = originalMarker.marker;
                        
                        // Garantir que a origem tenha sempre índice 0
                        const markerIndex = location.isOrigin ? 0 : (index);
                        const markerLabel = markerIndex === 0 ? 'O' : markerIndex.toString();
                        
                        console.log(`Atualizando marcador para ${location.name} (ID: ${location.id}) - É origem: ${location.isOrigin}, Label: ${markerLabel}`);
                        
                        marker.setLabel({
                            text: markerLabel,
                            color: "#FFFFFF",
                            fontSize: '14px',
                            fontWeight: 'bold'
                        });
                        marker.setMap(map);
                        
                        // Adicionar à nova lista de marcadores
                        newMarkers.push({
                            marker: marker,
                            location: location
                        });
                    } else {
                        // Se não encontrou o marcador original, criar um novo
                        // Garantir que a origem tenha sempre índice 0
                        const markerIndex = location.isOrigin ? 0 : index;
                        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id}) - É origem: ${location.isOrigin}, Índice: ${markerIndex}`);
                        addMarkerForLocation(location, markerIndex, newMarkers);
                    }
                });
                
            // Substituir o array de marcadores pelo novo
            markers = newMarkers;
        } else {
            // Fallback para o comportamento original
            console.log("Não há marcadores originais para reutilizar, criando novos");
            
            // Adicionar marcadores novamente na ordem otimizada
            pathLocations
                .filter(loc => loc) // Remover localizações nulas
                .forEach((location, index) => {
                    addMarkerForLocation(location, index);
                });
        }
        
        console.log("Quantidade de marcadores após reordenação:", markers.length);
        
        // Atualizar a lista de locais
        updateLocationsList();
    }

    // Função auxiliar para verificar se dois locais estão na mesma cidade
    function isSameCity(loc1, loc2) {
        if (!loc1 || !loc2) return false;
        
        console.log(`Verificando se ${loc1.name} e ${loc2.name} estão na mesma cidade`);
        
        // Se o nome da cidade está explícito no objeto
        if (loc1.cityName && loc2.cityName) {
            const result = loc1.cityName === loc2.cityName;
            console.log(`Comparação por cityName: ${loc1.cityName} vs ${loc2.cityName} = ${result}`);
            return result;
        }
        

        
        // Extrair cidade dos endereços (normalmente o primeiro componente após o nome)
        const address1Parts = loc1.address ? loc1.address.split(',') : [];
        const address2Parts = loc2.address ? loc2.address.split(',') : [];
        
        // Verificar se os endereços têm pelo menos duas partes (nome, cidade)
        if (address1Parts.length > 0 && address2Parts.length > 0) {
            const city1 = address1Parts[0].trim().toLowerCase();
            const city2 = address2Parts[0].trim().toLowerCase();
            
            if (city1 === city2) {
                console.log(`Mesma cidade encontrada nos endereços: ${city1}`);
                return true;
            }
        }
        
        // Verificar se ambos os nomes contêm a mesma cidade
        if (loc1.name && loc2.name) {
            // Removemos acentos e convertemos para minúsculas para comparação
            const name1 = loc1.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            const name2 = loc2.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            
            // Lista de cidades comuns do interior de São Paulo
            const cities = [
                "dois corregos", "dois córregos", "jau", "jaú", "botucatu", "bauru", 
                "pederneiras", "brotas", "barra bonita", "igaracu", "igaraçu", 
                "agudos", "lencois", "lençóis", "itapui", "itapuí"
            ];
            
            // Verificar se ambos os nomes contêm a mesma cidade
            for (const city of cities) {
                if (name1.includes(city) && name2.includes(city)) {
                    console.log(`Mesma cidade encontrada nos nomes: "${city}"`);
                    return true;
                }
            }
        }
        
        console.log("Não estão na mesma cidade");
        return false;
    }
    
    // Funções para controlar o spinner de carregamento
    function showLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'block';
        }
    }
    
    function hideLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    }
    
    // Traçar a rota no mapa
    function drawRouteOnMap(pathIds, vehicleType) {
        console.log("Desenhando rota para IDs:", pathIds);
        
        // Mostrar spinner durante o carregamento
        showLoadingSpinner();
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de caminho inválidos ou vazios:", pathIds);
            hideLoadingSpinner();
            return; // Interromper execução para evitar erros
        }
        
        // Verificar se há uma rota já desenhada e removê-la para evitar sobreposições
        if (routePath) {
            console.log("Removendo rota anterior antes de desenhar nova rota");
            try {
                routePath.setMap(null);
                routePath = null;
            } catch (e) {
                console.error("Erro ao remover rota anterior:", e);
            }
        }
        
        console.log("Localizações disponíveis:", locations);
        
        // Converter ids para objetos de localização
        const pathLocations = [];
        for (let i = 0; i < pathIds.length; i++) {
            const id = pathIds[i];
            // Garantir que a comparação de IDs seja feita como string
            const lookupId = String(typeof id === 'object' ? (id.id || id) : id);
            console.log("Procurando localização com ID:", lookupId, "Tipo:", typeof lookupId);
            
            const location = locations.find(loc => String(loc.id) === lookupId);
            if (!location) {
                console.error(`Localização ID ${lookupId} não encontrada!`);
            } else {
                console.log(`Localização ID ${lookupId} encontrada:`, location);
                pathLocations.push(location);
            }
        }
        
        // Verificar se todos os ids foram encontrados
        if (pathLocations.length !== pathIds.length) {
            // Usar String para garantir comparação consistente
            const missingIds = pathIds.filter(id => {
                const idStr = String(id);
                return !pathLocations.find(loc => String(loc.id) === idStr);
            });
            
            console.error("Algumas localizações não foram encontradas:", missingIds);
            // Usar função auxiliar para mostrar notificação
            showNotification('Erro ao traçar rota: algumas localizações não foram encontradas', 'danger', '.route-controls');
            return;
        }
        
        // Verificar e destacar pontos na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        
        if (origin) {
            pathLocations.forEach(location => {
                if (!location.isOrigin && isSameCity(location, origin)) {
                    console.log(`Ponto ${location.name} está na mesma cidade da origem (${origin.name})`);
                    
                    // Encontrar o marcador correspondente e destacá-lo
                    const locationId = location.id;
                    console.log("Buscando marcador para ID:", locationId, "Tipo:", typeof locationId);
                    
                    // Depuração de todos os markers para diagnóstico
                    console.log("Todos os marcadores disponíveis:", markers.map(m => ({
                        name: m.location.name,
                        id: m.location.id,
                        idType: typeof m.location.id
                    })));
                    
                    // Busca do marcador com conversão de string consistente
                    const markerIdString = String(locationId);
                    console.log(`Procurando marcador com ID string "${markerIdString}"`);
                    
                    const marker = markers.find(m => {
                        if (!m || !m.location) {
                            console.log("Marcador inválido encontrado na lista");
                            return false;
                        }
                        
                        try {
                            const mLocationIdString = String(m.location.id);
                            const isMatch = mLocationIdString === markerIdString;
                            console.log(`Comparando IDs: "${mLocationIdString}" === "${markerIdString}" = ${isMatch}`);
                            return isMatch;
                        } catch (err) {
                            console.error("Erro ao comparar IDs:", err);
                            return false;
                        }
                    });
                    
                    if (marker) {
                        marker.marker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#FF4500', // Cor mais destacada
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#000',
                            scale: 12
                        });
                    } else {
                        console.log(`Marcador não encontrado para localização ${location.name} (ID: ${locationId})`);
                    }
                }
            });
        }
        
        // Criar waypoints para o serviço de direções
        console.log("Criando waypoints para o serviço de direções com " + pathLocations.length + " pontos");
        
        // Debug para verificar que temos todos os pontos necessários
        pathLocations.forEach((location, idx) => {
            console.log(`Ponto ${idx}: ${location.name} (${location.latitude}, ${location.longitude}) - isOrigin: ${location.isOrigin}`);
        });
        
        const waypoints = pathLocations.slice(1, -1).map(location => ({
            location: new google.maps.LatLng(location.latitude, location.longitude),
            stopover: true
        }));
        
        const originPoint = new google.maps.LatLng(
            pathLocations[0].latitude,
            pathLocations[0].longitude
        );
        
        const destinationPoint = new google.maps.LatLng(
            pathLocations[pathLocations.length - 1].latitude,
            pathLocations[pathLocations.length - 1].longitude
        );
        
        const request = {
            origin: originPoint,
            destination: destinationPoint,
            waypoints: waypoints,
            optimizeWaypoints: false, // Não otimizar, já temos a ordem do TSP
            travelMode: google.maps.TravelMode.DRIVING,
            avoidTolls: false
        };
        
        directionsService.route(request, (result, status) => {
            // Esconder indicador de progresso
            hideLoadingSpinner();
            
            if (status === google.maps.DirectionsStatus.OK) {
                // Verificar se o DirectionsRenderer foi inicializado corretamente
                if (!directionsRendererInitialized || !directionsRenderer) {
                    console.error("DirectionsRenderer não está disponível ou inicializado");
                    showNotification("Erro no serviço de rotas. Tente recarregar a página.", "danger");
                    return;
                }
                
                // Limpar todas as polylines antigas para evitar sobreposições
                clearAllPolylines();
                
                try {
                    // Limpar renderizador antes de aplicar novas direções
                    directionsRenderer.setMap(null);
                    
                    // Recriar o renderizador para garantir que não haja sobreposições
                    directionsRenderer = new google.maps.DirectionsRenderer({
                        suppressMarkers: true, // Usamos nossos próprios marcadores
                        preserveViewport: true, // Não muda o zoom/centro do mapa
                        polylineOptions: {
                            strokeColor: '#1976D2',
                            strokeOpacity: 0.7,
                            strokeWeight: 4
                        }
                    });
                    directionsRenderer.setMap(map);
                    
                    // Aplicar as direções ao renderizador
                    directionsRenderer.setDirections(result);
                    console.log("Direções aplicadas com sucesso");
                    
                    // Registrar esta rota como a atual
                    currentDisplayedRoute = pathIds;
                    
                    // Capturar referências às polylines para limpeza futura
                    setTimeout(() => {
                        try {
                            const mapDiv = document.getElementById('map');
                            if (mapDiv) {
                                const polylines = mapDiv.querySelectorAll('path');
                                console.log(`Encontradas ${polylines.length} polylines no mapa`);
                            }
                        } catch (e) {
                            console.error("Erro ao contar polylines:", e);
                        }
                    }, 500);
                    
                } catch (err) {
                    console.error("Erro ao aplicar direções:", err);
                    showNotification("Erro ao exibir rota no mapa: " + err.message, "warning");
                    return;
                }
                
                // Animar a rota (opcional)
                console.log("Resultado da rota:", result);
                
                // Verificar se os dados da rota estão disponíveis
                if (result && result.routes && result.routes.length > 0 && result.routes[0].overview_path) {
                    console.log("Iniciando animação da rota com", result.routes[0].overview_path.length, "pontos");
                    
                    // Pequeno atraso para garantir que o DirectionsRenderer esteja pronto
                    setTimeout(() => {
                        try {
                            // Verifica se os pontos são objetos de LatLng ou precisam ser convertidos
                            const routePoints = result.routes[0].overview_path.map(point => {
                                // Se já for um objeto LatLng, retorne-o diretamente
                                if (point instanceof google.maps.LatLng) {
                                    return point;
                                } 
                                // Se for um objeto com lat/lng como métodos
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    return new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    return new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Formato desconhecido
                                else {
                                    console.error("Formato de ponto desconhecido:", point);
                                    return null;
                                }
                            }).filter(p => p !== null);
                            
                            console.log("Pontos da rota preparados para animação:", routePoints.length);
                            animateRoute(routePoints);
                        } catch (err) {
                            console.error("Erro ao preparar pontos para animação da rota:", err);
                            showNotification("Não foi possível animar a rota: " + err.message, "warning");
                        }
                    }, 1000);
                    
                } else {
                    console.error("Dados da rota incompletos, não é possível animar:", result);
                    showNotification("Não foi possível visualizar a rota animada. Tente novamente.", "warning");
                }
                
                // Ajustar o mapa para mostrar toda a rota
                const bounds = new google.maps.LatLngBounds();
                pathLocations.forEach(location => {
                    bounds.extend(new google.maps.LatLng(location.latitude, location.longitude));
                });
                map.fitBounds(bounds);
            } else {
                // Substituir alert por notificação inline mais suave
                console.error(`Erro ao calcular rota: ${status}`);
                
                // Preparar mensagem de erro mais amigável baseada no tipo de erro
                let errorMsg = '';
                
                if (status === 'ZERO_RESULTS') {
                    errorMsg = 'Não foi possível encontrar uma rota entre os pontos selecionados. ' +
                              'Isto pode ocorrer se um dos pontos estiver em uma área inacessível ' +
                              'ou se houver uma grande barreira natural (como um rio ou oceano) entre eles.';
                } else if (status === 'MAX_WAYPOINTS_EXCEEDED') {
                    errorMsg = 'Número máximo de destinos excedido. Tente dividir sua rota em partes menores.';
                } else if (status === 'MAX_ROUTE_LENGTH_EXCEEDED') {
                    errorMsg = 'A rota é muito longa. Tente dividir sua rota em partes menores.';
                } else if (status === 'OVER_QUERY_LIMIT') {
                    errorMsg = 'Limite de consultas excedido. Aguarde alguns minutos e tente novamente.';
                } else {
                    errorMsg = `Não foi possível calcular a rota: ${status}`;
                }
                
                // Usar função auxiliar para exibir notificação
                showNotification(errorMsg, 'danger');
                console.error("Directions request failed due to " + status);
            }
        });
    }

    // Animar a rota desenhando progressivamente
    function animateRoute(path) {
        console.log("Iniciando animação da rota...");
        
        // Logging para diagnóstico
        try {
            if (path && path.length > 0) {
                const firstPoint = path[0];
                console.log("Primeiro ponto da rota:", firstPoint);
                console.log("Tipo do primeiro ponto:", 
                    firstPoint instanceof google.maps.LatLng ? "LatLng" :
                    typeof firstPoint.lat === 'function' ? "Com métodos lat/lng" :
                    firstPoint.lat !== undefined ? "Com propriedades lat/lng" :
                    firstPoint.latitude !== undefined ? "Com propriedades latitude/longitude" :
                    "Desconhecido"
                );
            }
        } catch (e) {
            console.error("Erro ao analisar formato dos pontos:", e);
        }
        
        try {
            // Limpar qualquer animação existente
            if (routeAnimationTimeout) {
                clearTimeout(routeAnimationTimeout);
                routeAnimationTimeout = null;
            }
            
            // Se já existir uma rota, removê-la
            if (routePath) {
                try {
                    routePath.setMap(null);
                } catch (err) {
                    console.error("Erro ao limpar rota anterior:", err);
                }
                routePath = null;
            }
            
            // Forçar limpeza de qualquer polyline restante no mapa
            try {
                if (directionsRendererInitialized && directionsRenderer) {
                    directionsRenderer.setDirections({ routes: [] });
                }
                
                // Este é um "truque" para forçar a limpeza de todas as polylines
                if (map) {
                    const mapCenter = map.getCenter();
                    map.setCenter(mapCenter);
                }
            } catch (err) {
                console.error("Erro ao fazer limpeza extra do mapa:", err);
            }
            
            // Verificar se o caminho é válido
            if (!path) {
                console.error("Caminho nulo para animação");
                showNotification("Não foi possível animar a rota: dados ausentes", "warning");
                return;
            }
            
            if (!Array.isArray(path)) {
                console.error("Tipo de caminho inválido para animação:", typeof path);
                showNotification("Não foi possível animar a rota: formato de dados incorreto", "warning");
                return;
            }
            
            if (path.length === 0) {
                console.error("Caminho vazio para animação");
                showNotification("Não foi possível animar a rota: caminho vazio", "warning");
                return;
            }
        } catch (err) {
            console.error("Erro na inicialização da animação:", err);
            return;
        }
        
        // Limpar todas as polylines anteriores antes de criar nova
        clearAllPolylines();
        
        // Criar uma nova polyline para a rota
        routePath = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: '#1976D2',
            strokeOpacity: 1.0,
            strokeWeight: 5,
            map: map
        });
        
        // Registrar esta polyline para limpeza futura
        allRoutePolylines.push(routePath);
        
        console.log(`Animando rota com ${path.length} pontos...`);
        
        // Animação step-by-step
        let index = 0;
        const interval = 20; // ms entre cada ponto
        const batchSize = 3; // número de pontos a adicionar por vez (para animação mais suave)
        
        function animate() {
            // Verificar se o caminho da rota ainda está disponível
            if (!routePath) {
                console.error("routePath foi removido antes do início da animação");
                return;
            }
            
            if (index < path.length) {
                try {
                    // Adicionar um lote de pontos por vez para animação mais suave
                    for (let i = 0; i < batchSize && index < path.length; i++) {
                        if (routePath && routePath.getPath) {
                            try {
                                const point = path[index];
                                
                                // Criar um objeto LatLng válido, independente do formato do ponto
                                let latLng;
                                
                                // Se já for um objeto LatLng válido
                                if (point instanceof google.maps.LatLng) {
                                    latLng = point;
                                }
                                // Se for um objeto com métodos lat/lng
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    latLng = new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    latLng = new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Se for um objeto com propriedades latitude/longitude
                                else if (point.latitude !== undefined && point.longitude !== undefined) {
                                    latLng = new google.maps.LatLng(point.latitude, point.longitude);
                                }
                                // Formato desconhecido - usar um ponto padrão para evitar erros
                                else {
                                    console.error("Formato de ponto desconhecido na animação:", point);
                                    // Pular este ponto e continuar
                                    index++;
                                    continue;
                                }
                                
                                // Adicionar o ponto ao caminho
                                routePath.getPath().push(latLng);
                            } catch (pointErr) {
                                console.error("Erro ao processar ponto específico:", pointErr, "Índice:", index);
                                // Continuar para o próximo ponto mesmo em caso de erro
                            }
                        } else {
                            console.error("routePath foi removido durante a animação");
                            return; // Sair para evitar erros
                        }
                        index++;
                    }
                    
                    // Mostrar progresso da animação para depuração
                    if (index % 20 === 0 || index === path.length) {
                        console.log(`Animação da rota: ${Math.round((index / path.length) * 100)}% concluída (${index}/${path.length} pontos)`);
                    }
                    
                    // Agendar próximo batch da animação
                    routeAnimationTimeout = setTimeout(animate, interval);
                } catch (err) {
                    console.error("Erro durante a animação da rota:", err);
                    showNotification("Erro na animação da rota: " + err.message, "warning");
                }
            } else {
                console.log("Animação da rota concluída com sucesso.");
                showNotification("Rota calculada e animada com sucesso!", "success");
            }
        }
        
        // Iniciar animação com breve atraso
        console.log("Agendando início da animação da rota...");
        setTimeout(animate, 100);
    }

    // Mostrar pontos de interesse ao longo da rota
    function showPointsOfInterestOnRoute(pathIds) {
        console.log("Mostrando pontos de interesse para rota com IDs:", pathIds);
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inválidos ou vazios para pontos de interesse:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar pontos de interesse:", pathIds);
            } else {
                console.error("Impossível encontrar até mesmo a origem. Abortando exibição de pontos de interesse.");
                return;
            }
        }
        
        // Limpar marcadores anteriores
        clearPOIMarkers();
        
        // Se a opção de mostrar POIs estiver desativada, retornar
        if (!showPOIs) return;
        
        console.log("showPointsOfInterestOnRoute recebeu IDs:", pathIds);
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.", 
                "IDs da rota:", pathIds.map(id => String(id)),
                "Localizações:", locations);
            // Continuar mesmo com algumas localizações faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (versão melhorada)
        const citiesOnRoute = []; // Array para armazenar as cidades detectadas
        
        // Lista de cidades importantes para melhor detecção
        const knownCities = [
            "Campinas", "Ribeirão Preto", "São Carlos", "Piracicaba", "São Paulo", 
            "Sorocaba", "Americana", "Limeira", "Rio Claro", "Araraquara", "Bauru", 
            "Botucatu", "Jaú", "Dois Córregos", "Santos", "Guarulhos", "Osasco",
            "Jundiaí", "Franca", "Marília", "Presidente Prudente", "Araçatuba"
        ];
        
        // Para cada localização na rota
        pathLocations.filter(loc => loc).forEach(loc => {
            if (!loc.address) {
                // Se não tiver endereço, usar o nome da localização
                if (loc.name && !citiesOnRoute.includes(loc.name)) {
                    citiesOnRoute.push(loc.name);
                }
                return;
            }
            
            // 1. Verificar se o endereço contém alguma cidade conhecida
            const addressLower = loc.address.toLowerCase();
            let cityFound = false;
            
            knownCities.forEach(city => {
                if (addressLower.includes(city.toLowerCase())) {
                    if (!citiesOnRoute.includes(city)) {
                        console.log(`Cidade conhecida encontrada: ${city} em "${loc.address}"`);
                        citiesOnRoute.push(city);
                        cityFound = true;
                    }
                }
            });
            
            // 2. Se não encontrou nenhuma cidade conhecida, extrair a primeira parte do endereço
            if (!cityFound) {
                const parts = loc.address.split(',');
                const extractedCity = parts[0].trim();
                
                if (extractedCity && !citiesOnRoute.includes(extractedCity)) {
                    console.log(`Cidade extraída do endereço: ${extractedCity}`);
                    citiesOnRoute.push(extractedCity);
                }
            }
        });
        
        console.log("Cidades detectadas no percurso:", citiesOnRoute);
        
        // Filtrar POIs que estão nas cidades da rota
        const poisOnRoute = mockData.pointsOfInterest.filter(poi => 
            citiesOnRoute.some(city => poi.cityName.includes(city))
        );
        
        // Adicionar marcadores para os POIs
        poisOnRoute.forEach(poi => {
            let icon;
            
            // Ícone baseado no tipo de POI
            switch (poi.type) {
                case 'toll':
                    icon = {
                        path: 'M-2,-2 L2,-2 L2,2 L-2,2 Z', // Quadrado
                        fillColor: '#4caf50',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#007700',
                        scale: 6,
                        labelOrigin: new google.maps.Point(0, 0)
                    };
                    break;
                case 'weighStation':
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#ff9800',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#b26a00',
                        scale: 6
                    };
                    break;
                case 'gasStation':
                    icon = {
                        path: 'M-2,-2 L2,-2 L0,2 Z', // Triângulo
                        fillColor: '#2196f3',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#0069c0',
                        scale: 6
                    };
                    break;
                default:
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#9c27b0',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#6a0080',
                        scale: 6
                    };
            }
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: { lat: poi.latitude, lng: poi.longitude },
                map: map,
                title: poi.name,
                icon: icon,
                zIndex: 50
            });
            
            // Adicionar listener para mostrar tooltip ao passar o mouse
            marker.addListener('mouseover', function() {
                showTooltip(marker, poi);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Armazenar o marcador
            poiMarkers.push(marker);
        });
    }

    // Mostrar eventos para as cidades na rota
    function showEventsForCitiesOnRoute(pathIds) {
        console.log("Mostrando eventos para rota com IDs:", pathIds);
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inválidos ou vazios:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar eventos:", pathIds);
            } else {
                console.error("Impossível encontrar até mesmo a origem. Abortando exibição de eventos.");
                return;
            }
        }
        
        // Limpar a lista de eventos
        const eventsListContainer = document.getElementById('events-list');
        eventsListContainer.innerHTML = '';
        
        // Log para diagnóstico
        console.log("Eventos disponíveis:", mockData.cityEvents);
        
        if (!pathIds || pathIds.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos.</p>';
            return;
        }
        
        // CORREÇÃO: Converter IDs para objetos de localização de forma mais robusta
        const pathLocations = [];
        for (const id of pathIds) {
            const idStr = String(id);
            const location = locations.find(loc => String(loc.id) === idStr);
            if (location) {
                pathLocations.push(location);
                console.log(`Localização encontrada para ID ${idStr}:`, location);
            }
        }
        
        if (pathLocations.length === 0) {
            console.error("Nenhuma localização válida encontrada na rota");
            eventsListContainer.innerHTML = '<p class="text-muted">Erro ao encontrar localizações na rota.</p>';
            return;
        }
        
        // EXTRAÇÃO MELHORADA DE CIDADES DO PERCURSO
        // Array para armazenar os nomes das cidades que estão REALMENTE na rota
        const citiesOnRoute = [];
        
        // Cidade de origem (sempre incluir Dois Córregos)
        citiesOnRoute.push("Dois Córregos");
        console.log(`[ROTA] Adicionada cidade de origem: Dois Córregos`);
        
        // Processar CADA destino na rota para extrair nomes de cidades
        for (const location of pathLocations) {
            // Apenas adicionar se tivermos um nome válido
            if (location && location.name) {
                // Verificar se o nome é uma cidade conhecida (estratégia 1)
                const knownCities = [
                    "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                    "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                    "Americana", "Sorocaba", "Limeira", "Rio Claro"
                ];
                
                // Se o nome exato da localização é uma cidade conhecida
                if (knownCities.includes(location.name) && !citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionada cidade conhecida: ${location.name}`);
                    continue; // Ir para o próximo local
                }
                
                // Estratégia 2: Usar o nome da localização diretamente
                if (!citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionado local como possível cidade: ${location.name}`);
                }
            }
        }
        
        console.log(`[ROTA] Cidades encontradas no percurso (${citiesOnRoute.length}): ${citiesOnRoute.join(', ')}`);
        
        console.log("APENAS ESTAS CIDADES ESTÃO NA ROTA REAL:", citiesOnRoute);
        
        // Obter datas do filtro
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        
        // NOVA IMPLEMENTAÇÃO DE FILTRAGEM DE EVENTOS
        console.log("NOVA IMPLEMENTAÇÃO: Filtragem estrita de eventos por cidade e data");
        console.log(`Filtrando eventos para cidades: ${citiesOnRoute.join(', ')}`);
        console.log(`Filtro de data: ${startDate || 'sem data inicial'} a ${endDate || 'sem data final'}`);
        
        // Array para armazenar eventos filtrados
        let eventsOnRoute = [];
        
        // Para cada evento nos dados...
        mockData.cityEvents.forEach(event => {
            let includeEvent = false;
            
            // ETAPA 1: FILTRAR POR CIDADE - CORRESPONDÊNCIA EXATA APENAS (REGRA RÍGIDA)
            const cityMatch = citiesOnRoute.includes(event.cityName);
            
            // Se a cidade não estiver no percurso, não inclua este evento
            if (!cityMatch) {
                console.log(`[CIDADE] Evento '${event.name}' em '${event.cityName}' REJEITADO - cidade não está no percurso`);
                return; // Pular para o próximo evento
            }
            
            // ETAPA 2: FILTRAR POR DATA (APÓS VERIFICAÇÃO DA CIDADE)
            if (!startDate && !endDate) {
                // Nenhum filtro de data especificado, e a cidade já está verificada
                console.log(`[DATA] Evento '${event.name}' em '${event.cityName}' ACEITO - nenhum filtro de data especificado`);
                includeEvent = true;
            } 
            else {
                // Filtro de data especificado, verificar se o evento está dentro do intervalo
                try {
                    // Criar objetos de data para comparação
                    const eventStartObj = new Date(event.startDate);
                    const eventEndObj = new Date(event.endDate);
                    
                    // Formatação para diagnóstico
                    const eventStartStr = eventStartObj.toLocaleDateString('pt-BR');
                    const eventEndStr = eventEndObj.toLocaleDateString('pt-BR');
                    
                    // Se ambas as datas do filtro foram especificadas
                    if (startDate && endDate) {
                        const filterStartObj = new Date(startDate);
                        const filterEndObj = new Date(endDate);
                        
                        const filterStartStr = filterStartObj.toLocaleDateString('pt-BR');
                        const filterEndStr = filterEndObj.toLocaleDateString('pt-BR');
                        
                        console.log(`[DATA] Verificando se evento ${event.name} (${eventStartStr} a ${eventEndStr}) está no período ${filterStartStr} a ${filterEndStr}`);
                        
                        // Um evento corresponde se:
                        // 1. O evento começa dentro do intervalo do filtro, OU
                        // 2. O evento termina dentro do intervalo do filtro, OU
                        // 3. O evento abrange completamente o intervalo do filtro
                        if (
                            // Começa no intervalo
                            (eventStartObj >= filterStartObj && eventStartObj <= filterEndObj) ||
                            // Termina no intervalo
                            (eventEndObj >= filterStartObj && eventEndObj <= filterEndObj) ||
                            // Abrange o intervalo completo
                            (eventStartObj <= filterStartObj && eventEndObj >= filterEndObj)
                        ) {
                            console.log(`[DATA] Evento '${event.name}' ACEITO - está no intervalo de datas especificado`);
                            includeEvent = true;
                        } else {
                            console.log(`[DATA] Evento '${event.name}' REJEITADO - fora do intervalo de datas especificado`);
                        }
                    }
                    // Se apenas a data inicial foi especificada
                    else if (startDate) {
                        const filterStartObj = new Date(startDate);
                        const filterStartStr = filterStartObj.toLocaleDateString('pt-BR');
                        
                        console.log(`[DATA] Verificando se evento ${event.name} (${eventStartStr} a ${eventEndStr}) ocorre após ${filterStartStr}`);
                        
                        if (eventEndObj >= filterStartObj) {
                            console.log(`[DATA] Evento '${event.name}' ACEITO - termina após a data inicial especificada`);
                            includeEvent = true;
                        } else {
                            console.log(`[DATA] Evento '${event.name}' REJEITADO - termina antes da data inicial especificada`);
                        }
                    }
                    // Se apenas a data final foi especificada
                    else if (endDate) {
                        const filterEndObj = new Date(endDate);
                        const filterEndStr = filterEndObj.toLocaleDateString('pt-BR');
                        
                        console.log(`[DATA] Verificando se evento ${event.name} (${eventStartStr} a ${eventEndStr}) ocorre antes de ${filterEndStr}`);
                        
                        if (eventStartObj <= filterEndObj) {
                            console.log(`[DATA] Evento '${event.name}' ACEITO - começa antes da data final especificada`);
                            includeEvent = true;
                        } else {
                            console.log(`[DATA] Evento '${event.name}' REJEITADO - começa após a data final especificada`);
                        }
                    }
                } catch (e) {
                    console.error(`[ERRO] Falha ao processar datas para evento ${event.name}:`, e);
                    includeEvent = false; // Em caso de erro, não incluir o evento
                }
            }
            
            // Se passou por todos os filtros, incluir o evento
            if (includeEvent) {
                console.log(`[FINAL] Evento '${event.name}' em '${event.cityName}' - INCLUÍDO NA LISTA FINAL`);
                eventsOnRoute.push(event);
            }
        });
        
        // Se não houver eventos, mostrar mensagem
        if (eventsOnRoute.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado para o período e cidades selecionados.</p>';
            return;
        }
        
        // Limpar marcadores anteriores
        clearEventMarkers();
        
        // Ordenar eventos por data
        eventsOnRoute.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        
        // Adicionar cada evento à lista
        eventsOnRoute.forEach(event => {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Formatar datas
            const startDate = new Date(event.startDate);
            const endDate = new Date(event.endDate);
            const formattedStartDate = startDate.toLocaleDateString('pt-BR');
            const formattedEndDate = endDate.toLocaleDateString('pt-BR');
            const dateText = formattedStartDate === formattedEndDate ? 
                            formattedStartDate : 
                            `${formattedStartDate} - ${formattedEndDate}`;
            
            // Definir classe baseada no tipo de evento
            const eventTypeClass = event.isHoliday ? 'holiday' : 'event';
            
            eventItem.innerHTML = `
                <div class="event-name">${event.name} 
                    <span class="event-type ${eventTypeClass}">${event.isHoliday ? 'Feriado' : 'Evento'}</span>
                    <span class="restriction-level ${event.restrictionLevel}">${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</span>
                </div>
                <div class="event-date">${event.cityName} | ${dateText}</div>
                <div class="event-description">${event.description}</div>
            `;
            
            eventsListContainer.appendChild(eventItem);
            
            // Adicionar marcador no mapa para o evento
            // Para simplificar, vamos usar a posição da cidade (primeiro local que corresponde ao nome da cidade)
            const cityLocation = pathLocations.find(loc => loc.address.includes(event.cityName));
            if (cityLocation) {
                addEventMarker(event, cityLocation);
            }
        });
    }

    // Adicionar marcador para um evento
    function addEventMarker(event, location) {
        // Seletor de ícone com base no tipo de evento
        const markerColor = event.isHoliday ? '#f44336' : '#ff9800';
        const markerIcon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: markerColor,
            fillOpacity: 1,
            strokeWeight: 1,
            strokeColor: '#000',
            scale: 8
        };
        
        // Criar o marcador
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: event.name,
            icon: markerIcon,
            zIndex: 30
        });
        
        // Conteúdo do tooltip
        const tooltipContent = `
            <div class="tooltip-title">${event.name}</div>
            <div>${event.cityName}</div>
            <div>${new Date(event.startDate).toLocaleDateString('pt-BR')} - ${new Date(event.endDate).toLocaleDateString('pt-BR')}</div>
            <div>${event.description}</div>
            <div>Nível de restrição: ${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</div>
        `;
        
        // Adicionar listener para mostrar tooltip ao passar o mouse
        marker.addListener('mouseover', function() {
            showTooltip(marker, { tooltipContent });
        });
        
        marker.addListener('mouseout', function() {
            hideTooltip();
        });
        
        // Armazenar o marcador
        eventMarkers.push(marker);
    }

    // Mostrar restrições para caminhões nas cidades da rota
    function showTruckRestrictionsForCitiesOnRoute(pathIds, vehicleType) {
        console.log("DEBUG: Acionando função para mostrar restrições de caminhões das cidades do percurso");
        console.log("Mostrando restrições de caminhões para rota com IDs:", pathIds);
        
        // Adicionar timestamp ao log para debug
        console.log("Timestamp:", new Date().toISOString());
        
        // Verificar se estamos no GitHub Pages
        const isGitHubPages = window.location.href.includes('github.io');
        
        if (isGitHubPages) {
            console.warn("GITHUB PAGES DETECTADO - Usando método adaptado para mostrar cidades na rota");
            
            // No GitHub Pages, vamos obter todas as cidades da rota
            // Esta é a parte crucial: capturar as cidades da rota atual
            const citiesInRoute = [];
            
            // Se tivermos um caminho otimizado válido, usá-lo
            if (window.currentOptimizedPath && window.currentOptimizedPath.length > 0) {
                console.log("Usando rota otimizada para identificar cidades", window.currentOptimizedPath);
                
                // Adicionar origem primeiro
                const origin = locations.find(loc => loc.isOrigin);
                if (origin) {
                    citiesInRoute.push({
                        cityName: extractCityName(origin.address || origin.name),
                        position: 1,
                        originalLocation: origin,
                        displayName: origin.name // Nome para mostrar na interface
                    });
                }
                
                // Adicionar as demais cidades da rota otimizada
                for (let i = 0; i < window.currentOptimizedPath.length; i++) {
                    const locationId = window.currentOptimizedPath[i];
                    const location = locations.find(loc => String(loc.id) === String(locationId));
                    
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: i + 2, // +2 porque origem é 1 e arrays começam em 0
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                }
            } else {
                // Fallback para pathIds passados para a função
                console.log("Usando pathIds como fallback para identificar cidades");
                
                // Usar os IDs de caminho fornecidos para obter as cidades
                pathIds.forEach((id, index) => {
                    const location = locations.find(loc => String(loc.id) === String(id));
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: index + 1,
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                });
            }
            
            // Garantir que temos cidades para mostrar
            if (citiesInRoute.length === 0) {
                console.warn("Nenhuma cidade encontrada na rota atual, usando cidades padrão");
                // Usar lista de cidades padrão como último recurso
                citiesInRoute.push(
                    { cityName: "Dois Córregos", position: 1, displayName: "Dois Córregos (origem)" },
                    { cityName: "Jaú", position: 2, displayName: "Jaú" },
                    { cityName: "Bauru", position: 3, displayName: "Bauru" }
                );
            }
            
            console.log("Cidades detectadas na rota:", citiesInRoute);
            
            // Limpar a lista
            const restrictionsListContainer = document.getElementById('restrictions-list');
            restrictionsListContainer.innerHTML = '';
            
            // Adicionar título explicativo
            const titleElement = document.createElement('div');
            titleElement.style.padding = '10px';
            titleElement.style.margin = '0 0 15px 0';
            titleElement.style.backgroundColor = '#1976D2';
            titleElement.style.color = 'white';
            titleElement.style.borderRadius = '4px';
            titleElement.style.fontWeight = 'bold';
            titleElement.style.textAlign = 'center';
            
            // Construir nome das cidades para o título
            const citiesSequence = citiesInRoute.map(c => c.cityName).join(' → ');
            titleElement.innerHTML = 'Restrições para caminhões na rota<br>' + 
                                    '<span style="font-size: 0.8em; font-weight: normal;">' +
                                    citiesSequence +
                                    '</span>';
            
            restrictionsListContainer.appendChild(titleElement);
            
            // Para cada cidade na rota, gerar uma restrição representativa
            citiesInRoute.forEach(city => {
                // Gerar uma restrição para esta cidade
                // Vamos variar o tipo de restrição com base na posição para diversidade visual
                const restrictionType = city.position % 3 === 0 ? "rodizio" : (city.position % 2 === 0 ? "total" : "partial");
                const dayType = city.position % 2 === 0 ? "weekday" : "all";
                
                // Criar tipos diferentes de descrições conforme o tipo de restrição
                let description = "";
                if (restrictionType === "partial") {
                    description = "Restrição parcial para caminhões de grande porte no centro";
                } else if (restrictionType === "total") {
                    description = "Restrição total para caminhões acima de 2 eixos no centro";
                } else {
                    description = "Sistema de rodízio para todos os tipos de caminhões";
                }
                
                // Definir horários diferentes com base na posição para variedade
                const startHour = (city.position % 12) + 7; // Entre 7h e 18h
                const endHour = Math.min(startHour + 3, 22); // No máximo até 22h
                const startTime = `${startHour.toString().padStart(2, '0')}:00`;
                const endTime = `${endHour.toString().padStart(2, '0')}:00`;
                
                // Criar o elemento de restrição
                const restrictionItem = document.createElement('div');
                restrictionItem.className = 'restriction-item';
                
                // Determinar texto de dias
                let dayTypeText = 'Todos os dias';
                if (dayType === 'weekday') dayTypeText = 'Dias úteis';
                else if (dayType === 'weekend') dayTypeText = 'Finais de semana';
                
                // Estilo para a cidade com barra lateral colorida
                const cidadeStyle = 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px; display: flex; align-items: center; flex-wrap: wrap;';
                
                // Texto com a posição na rota e nome do local
                let posicaoNaRotaTexto = '';
                if (city.position === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">Origem</span>';
                    
                    // Adicionar nome do local se disponível
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                } else {
                    // Estilo para a posição com nome do local
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">#${city.position}</span>`;
                    
                    // Adicionar nome do local se disponível
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                }
                
                // Criar HTML da restrição
                restrictionItem.innerHTML = `
                    <div class="restriction-city" style="${cidadeStyle}">
                        ${posicaoNaRotaTexto}
                        ${city.cityName}
                        <span class="restriction-type ${restrictionType}">${restrictionType === 'partial' ? 'Parcial' : (restrictionType === 'total' ? 'Total' : 'Rodízio')}</span>
                    </div>
                    <div class="restriction-time">${dayTypeText} | ${startTime} - ${endTime}</div>
                    <div class="restriction-description">${description}</div>
                    <div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">✓ Esta cidade está no seu percurso</div>
                `;
                
                // Adicionar à lista
                restrictionsListContainer.appendChild(restrictionItem);
            });
            
            console.log(`GitHub Pages: Exibindo ${citiesInRoute.length} restrições para cidades na rota atual`);
            
            // Retornar para não continuar a execução da função original
            return;
        }
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.warn("IDs de rota inválidos ou vazios. Usando modo demonstração para exibir restrições relevantes");
            
            // No modo demonstração, mostrar restrições para cidades importantes
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando a origem e cidades importantes para mostrar restrições:", pathIds);
            } else {
                console.warn("Impossível encontrar a origem, usando um ID padrão");
                pathIds = [1]; // ID padrão para quando não há localização de origem
            }
        }
        console.log("Parâmetro vehicleType:", vehicleType, "- Isso será ignorado completamente");
        // Limpar a lista de restrições
        const restrictionsListContainer = document.getElementById('restrictions-list');
        restrictionsListContainer.innerHTML = '';
        
        // Log detalhado para diagnóstico
        console.log("Restrições disponíveis:", mockData.truckRestrictions);
        
        // DEBUG: Forçar a exibição de restrições para todas as cidades importantes
        console.warn("DIAGNÓSTICO DE RESTRIÇÕES: Forçando exibição para todas as cidades");
        
        // Verificar se estamos na versão GitHub Pages (já feito na função)
        // A variável isGitHubPages já foi declarada no início da função
        // Apenas registrar para diagnóstico
        console.log("Executando em GitHub Pages (verificação secundária):", isGitHubPages);
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.",
                "IDs da rota:", pathIds.map(id => String(id)));
            // Continuar mesmo com algumas localizações faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (ignorar localizações não encontradas)
        console.log("Detectando cidades na rota para restrições de caminhões...");
        
        // IMPORTANTE: Para debug e diagnóstico - Visualizar as restrições disponíveis
        console.table(mockData.truckRestrictions.map(r => ({
            cidade: r.cityName,
            tipo: r.restrictionType,
            afeta: r.affectedVehicles ? r.affectedVehicles.join(', ') : 'todos',
            desc: r.description
        })));
        
        // Obter todos os waypoints da rota, se disponíveis
        let citiesFromWaypoints = [];
        
        // Verificar se temos uma rota ativa com direções
        if (directionsRenderer && directionsRenderer.getDirections()) {
            const route = directionsRenderer.getDirections().routes[0];
            if (route && route.legs) {
                // Extrair cidades de todos os waypoints na rota
                route.legs.forEach(leg => {
                    if (leg.start_address) {
                        const startCity = extractCityFromAddress(leg.start_address);
                        if (startCity) citiesFromWaypoints.push(startCity);
                    }
                    if (leg.end_address) {
                        const endCity = extractCityFromAddress(leg.end_address);
                        if (endCity) citiesFromWaypoints.push(endCity);
                    }
                });
                console.log("Cidades extraídas de waypoints da rota:", citiesFromWaypoints);
            }
        }
        
        /**
         * Extrai o nome da cidade de um endereço completo
         * @param {string} address - Endereço completo
         * @returns {string|null} - Nome da cidade extraído ou null se não encontrado
         */
        function extractCityFromAddress(address) {
            if (!address) return null;
            
            // Lista de cidades conhecidas para detecção direta
            const knownCities = [
                "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                "Americana", "Sorocaba", "Limeira", "Rio Claro", "Lençóis Paulista"
            ];
            
            // Procurar cidades conhecidas no endereço
            for (const city of knownCities) {
                if (address.includes(city)) {
                    return city;
                }
            }
            
            // Tentar extrair a cidade do formato padrão de endereço
            // Padrão comum: "Rua X, Cidade - Estado, CEP"
            const parts = address.split(',');
            if (parts.length >= 2) {
                // A cidade geralmente está na segunda parte
                let cityPart = parts[1].trim();
                
                // Remover o estado e CEP se presente
                if (cityPart.includes('-')) {
                    cityPart = cityPart.split('-')[0].trim();
                }
                
                return cityPart;
            }
            
            return null;
        }
        
        /**
         * Função principal para extrair nome de cidade de um texto ou endereço
         * Utiliza várias estratégias para identificar a cidade
         * @param {string} addressOrName - Endereço completo ou nome de localização
         * @returns {string} - Nome da cidade extraído ou texto original como fallback
         */
        function extractCityName(addressOrName) {
            if (!addressOrName) return 'Desconhecido';
            
            // Tentar extrair cidade de endereço completo primeiro
            const cityFromAddress = extractCityFromAddress(addressOrName);
            if (cityFromAddress) return cityFromAddress;
            
            // Lista de cidades conhecidas para reconhecimento direto
            const knownCities = [
                "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                "Americana", "Sorocaba", "Limeira", "Rio Claro", "Lençóis Paulista"
            ];
            
            // Verificar se o nome já contém uma cidade conhecida
            for (const city of knownCities) {
                if (addressOrName.includes(city)) {
                    return city;
                }
            }
            
            // Se chegamos até aqui, retornar o nome como está
            return addressOrName;
        }
        
        const citiesOnRoute = pathLocations
            .filter(loc => loc) // Remover localizações nulas
            .map(loc => {
                if (!loc.address) {
                    console.log("Localização sem endereço:", loc);
                    return loc.name || "Desconhecido";
                }
                
                // Extrair cidade do endereço ou usar nome da localização
                const cityName = extractCityFromAddress(loc.address) || loc.name.trim();
                
                console.log(`DEBUG - Localização: ${loc.name}, Endereço: ${loc.address}, Cidade extraída: ${cityName}`);
                return cityName;
            });
        
        // Adicionar cidades detectadas dos waypoints
        citiesFromWaypoints.forEach(city => {
            if (city && !citiesOnRoute.includes(city)) {
                citiesOnRoute.push(city);
            }
        });
        
        // Garantir que a origem (Dois Córregos) esteja incluída
        if (!citiesOnRoute.includes("Dois Córregos")) citiesOnRoute.push("Dois Córregos");
        
        // Extrair o destino final corretamente
        const destinoFinal = pathLocations[pathLocations.length - 1];
        if (destinoFinal && destinoFinal.address) {
            const destinoCity = extractCityFromAddress(destinoFinal.address);
            if (destinoCity && !citiesOnRoute.includes(destinoCity)) {
                citiesOnRoute.push(destinoCity);
                console.log(`Destino adicionado à lista de restrições: ${destinoCity}`);
            }
        }
        
        // IMPORTANTE: Adicionar cidades específicas para garantir que restrições apareçam
        // Adicionamos as cidades mais importantes do percurso para demonstração
        const cidadesImportantes = [
            "Dois Córregos", "Jaú", "Bauru", "Botucatu", "São Paulo", 
            "Campinas", "Piracicaba", "São Carlos", "Araraquara", 
            "Ribeirão Preto", "Americana", "Limeira", "Rio Claro"
        ];
        
        // Adicionar cidades importantes que podem estar no percurso
        // Isso garante que o usuário veja restrições relevantes mesmo se a detecção automática falhar
        cidadesImportantes.forEach(cidade => {
            if (!citiesOnRoute.includes(cidade)) {
                console.log(`Adicionando cidade importante para restrições: ${cidade}`);
                citiesOnRoute.push(cidade);
            }
        });
        
        console.log("CIDADES NA ROTA PARA RESTRIÇÕES (inclui importantes):", citiesOnRoute);
        
        // SOLUÇÃO MELHORADA: Filtrar restrições para TODAS as cidades
        console.log(`Filtrando restrições para TODAS as cidades na rota`);
        
        // DEBUG: Mostrar todas as cidades disponíveis nas restrições para diagnóstico
        const todasCidadesComRestricoes = [...new Set(mockData.truckRestrictions.map(r => r.cityName))];
        console.log("TODAS AS CIDADES COM RESTRIÇÕES DISPONÍVEIS:", todasCidadesComRestricoes);
        
        // Verificar tipos de caminhões específicos a serem filtrados
        const tiposCaminhoesFiltrar = ['truck1', 'truck2', 'truck3', 'truck4', 'truck5']; // Caminhão 1 eixo, 2 eixos, truck, comercial, toco
        
        // DEBUG: Registrar todas as restrições disponíveis para diagnóstico
        console.log("Total de restrições disponíveis:", mockData.truckRestrictions.length);
        
        // SOLUÇÃO DIRETA: no GitHub Pages substituímos os dados de restrições diretamente
        // para garantir que apenas cidades da rota sejam mostradas
        let restrictionsOnRoute;
        
        // Verificar se estamos no GitHub Pages
        if (isGitHubPages) {
            console.warn("MODO GITHUB PAGES - Substituindo dados por versão controlada");
            
            // No GitHub Pages, vamos criar uma versão controlada dos dados
            // com APENAS as restrições das cidades que queremos mostrar
            
            // Sobrescrever completamente as restrições no modo GitHub Pages
            // para termos controle total sobre o que é exibido
            const restricoesControladasGitHubPages = [
                // Dois Córregos (origem)
                { 
                    id: 1, 
                    cityName: "Dois Córregos", 
                    dayType: "weekday", 
                    startTime: "07:00", 
                    endTime: "09:00", 
                    restrictionType: "partial", 
                    description: "Restrição parcial para caminhões de grande porte no centro", 
                    affectedVehicles: ["truck1", "truck5"] 
                },
                
                // Jaú (segunda cidade na rota)
                { 
                    id: 2, 
                    cityName: "Jaú", 
                    dayType: "weekday", 
                    startTime: "17:00", 
                    endTime: "20:00", 
                    restrictionType: "partial", 
                    description: "Restrição parcial para todos os caminhões no centro", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                },
                
                // Bauru (terceira cidade na rota)
                { 
                    id: 3, 
                    cityName: "Bauru", 
                    dayType: "all", 
                    startTime: "07:00", 
                    endTime: "22:00", 
                    restrictionType: "rodizio", 
                    description: "Sistema de rodízio para todos os caminhões", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                }
            ];
            
            // Usar nossa lista controlada
            restrictionsOnRoute = restricoesControladasGitHubPages;
            
            console.log(`Usando lista controlada de restrições: ${restrictionsOnRoute.length}`);
        } else {
            // Modo normal - filtrar apenas restrições das cidades na rota
            restrictionsOnRoute = mockData.truckRestrictions.filter(restriction => {
                // 1. Verificar se a cidade está no percurso (caso exato primeiro)
                const cidadeExata = citiesOnRoute.includes(restriction.cityName);
                
                // 2. Comparação flexível para nomes de cidades (ambos os lados em minúsculas)
                const restrictionCity = restriction.cityName.toLowerCase().trim();
                
                // Verificar se a cidade da restrição está em alguma cidade na rota
                let cityMatch = cidadeExata;
                
                // Se não encontrou correspondência exata, tentar correspondência parcial
                if (!cityMatch) {
                    for (const city of citiesOnRoute) {
                        if (!city) continue;
                        
                        const routeCity = city.toLowerCase().trim();
                        
                        // Verificar correspondência exata primeiro
                        if (restrictionCity === routeCity) {
                            console.log(`CORRESPONDÊNCIA EXATA: ${restriction.cityName} = ${city}`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da rota está contida na cidade da restrição
                        if (routeCity.length > 3 && restrictionCity.includes(routeCity)) {
                            console.log(`CORRESPONDÊNCIA PARCIAL: '${restriction.cityName}' contém '${city}'`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da restrição está contida na cidade da rota
                        if (restrictionCity.length > 3 && routeCity.includes(restrictionCity)) {
                            console.log(`CORRESPONDÊNCIA PARCIAL INVERSA: '${city}' contém '${restriction.cityName}'`);
                            cityMatch = true;
                            break;
                        }
                    }
                }
                
                // 3. Verificar se a restrição afeta algum dos tipos de caminhões que estamos filtrando
                const tiposCaminhoesAfetados = restriction.affectedVehicles || [];
                const afetaTiposFiltrados = tiposCaminhoesAfetados.some(tipo => tiposCaminhoesFiltrar.includes(tipo));
                
                // Para restrições que afetam TODOS os caminhões, também incluímos
                const afetaTodos = tiposCaminhoesAfetados.includes('all') || tiposCaminhoesAfetados.length === 0;
                
                // Log detalhado para debug
                if (cityMatch) {
                    console.log(`CIDADE CORRESPONDE: ${restriction.cityName} - ${restriction.description}`);
                    console.log(`Afeta caminhões: ${restriction.affectedVehicles ? restriction.affectedVehicles.join(', ') : 'todos'}`);
                    
                    if (afetaTiposFiltrados || afetaTodos) {
                        console.log(`✓ INCLUI RESTRIÇÃO: Afeta os tipos de caminhões filtrados`);
                    } else {
                        console.log(`✗ EXCLUI RESTRIÇÃO: Não afeta os tipos de caminhões filtrados`);
                    }
                }
                
                // Retorna true apenas se a cidade está na rota E a restrição afeta os tipos de caminhões filtrados
                return cityMatch && (afetaTiposFiltrados || afetaTodos);
            });
            
            console.log(`RESTRIÇÕES FILTRADAS: ${restrictionsOnRoute.length} restrições encontradas para as cidades na rota`);
        }
        
        // Adicionar título explicativo para a seção de restrições no GitHub Pages
        if (isGitHubPages) {
            try {
                // Limpar a lista primeiro e adicionar título depois
                const restrictionsListContainer = document.getElementById('restrictions-list');
                
                // Limpar o container para garantir que não há restrições remanescentes
                restrictionsListContainer.innerHTML = '';
                
                // Criar título destacado
                const titleElement = document.createElement('div');
                titleElement.className = 'restrictions-title';
                titleElement.style.padding = '10px';
                titleElement.style.margin = '0 0 15px 0';
                titleElement.style.backgroundColor = '#1976D2';
                titleElement.style.color = 'white';
                titleElement.style.borderRadius = '4px';
                titleElement.style.fontWeight = 'bold';
                titleElement.style.textAlign = 'center';
                titleElement.innerHTML = 'Restrições para caminhões na rota<br>' + 
                                        '<span style="font-size: 0.8em; font-weight: normal;">' +
                                        'Dois Córregos → Jaú → Bauru' +
                                        '</span>';
                
                // Adicionar título
                restrictionsListContainer.appendChild(titleElement);
                
                // Verificar o número de restrições
                console.log(`Exibindo ${restrictionsOnRoute.length} restrições na versão GitHub Pages`);
            } catch (e) {
                console.error("Erro ao adicionar título no GitHub Pages:", e);
            }
        }
        
        // Se não houver restrições, mostrar mensagem adaptada aos tipos de caminhões filtrados
        if (restrictionsOnRoute.length === 0) {
            // Formatar os tipos de caminhões para a mensagem
            const tiposCaminhoesTexto = [
                'caminhão de 1 eixo', 
                'caminhão de 2 eixos', 
                'caminhão truck',
                'caminhão comercial',
                'caminhão toco'
            ].join(', ');
            
            const mensagem = `<p class="text-muted">Nenhuma restrição encontrada para ${tiposCaminhoesTexto} nas cidades detectadas no percurso.</p>`;
            restrictionsListContainer.innerHTML = mensagem;
            return;
        }
        
        // Adicionar cada restrição à lista
        restrictionsOnRoute.forEach(restriction => {
            const restrictionItem = document.createElement('div');
            restrictionItem.className = 'restriction-item';
            
            // Texto para tipo de dia
            let dayTypeText = '';
            switch (restriction.dayType) {
                case 'weekday': dayTypeText = 'Dias úteis'; break;
                case 'weekend': dayTypeText = 'Fins de semana'; break;
                case 'all': dayTypeText = 'Todos os dias'; break;
            }
            
            // Criar exibição dos tipos de veículos afetados
            const vehiclesAffected = restriction.affectedVehicles || [];
            const vehiclesDisplay = vehiclesAffected.length > 0 
                ? `<div class="affected-vehicles">Afeta: ${vehiclesAffected.map(v => {
                    switch(v) {
                        case 'truck1': return 'Caminhão 1 eixo';
                        case 'truck2': return 'Caminhão 2 eixos';
                        case 'truck3': return 'Caminhão 3+ eixos';
                        case 'all': return 'Todos os caminhões';
                        default: return v;
                    }
                  }).join(', ')}</div>` 
                : '';
                
            // Verificar se a cidade está no percurso atual
            let estaNoPercurso = false;
            
            // No GitHub Pages, definimos diretamente a posição na rota com base no ID
            if (isGitHubPages) {
                // No GitHub Pages, todas as restrições estão no percurso
                estaNoPercurso = true;
                
                // Definir posição diretamente pelo ID da restrição
                // Isso é mais confiável porque nossas restrições controladas seguem essa ordem
                posicaoNaRota = restriction.id;
            } else {
                // Modo normal: verificar se a cidade está no percurso atual
                estaNoPercurso = citiesOnRoute.some(city => {
                    if (!city) return false;
                    return city.toLowerCase() === restriction.cityName.toLowerCase() ||
                           city.toLowerCase().includes(restriction.cityName.toLowerCase()) ||
                           restriction.cityName.toLowerCase().includes(city.toLowerCase());
                });
            }
            
            // Estilo especial para cidades que estão realmente no percurso
            const cidadeStyle = estaNoPercurso 
                ? 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px;' 
                : '';
            
            // No GitHub Pages, adicionamos informação da posição na rota
            let posicaoNaRotaTexto = '';
            let posicaoStyle = '';
            
            if (isGitHubPages && typeof posicaoNaRota !== 'undefined' && posicaoNaRota > 0) {
                // Gerar texto da posição na rota
                if (posicaoNaRota === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">Origem</span>';
                } else {
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">${posicaoNaRota}ª</span>`;
                }
                
                // Adicionar margem para o texto de posição
                posicaoStyle = 'display: flex; align-items: center;';
            }
            
            // Ícone para indicar se a cidade está no percurso
            const percursoIcon = estaNoPercurso && !isGitHubPages
                ? '<span style="color: #1976D2; margin-left: 5px;">✓</span>' 
                : '';
            
            restrictionItem.innerHTML = `
                <div class="restriction-city" style="${cidadeStyle} ${posicaoStyle}">
                    ${isGitHubPages ? posicaoNaRotaTexto : ''}
                    ${restriction.cityName} ${percursoIcon}
                    <span class="restriction-type ${restriction.restrictionType}">${restriction.restrictionType === 'partial' ? 'Parcial' : (restriction.restrictionType === 'total' ? 'Total' : 'Rodízio')}</span>
                </div>
                <div class="restriction-time">${dayTypeText} | ${restriction.startTime} - ${restriction.endTime}</div>
                <div class="restriction-description">${restriction.description}</div>
                ${vehiclesDisplay}
                ${estaNoPercurso && !isGitHubPages ? '<div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">✓ Esta cidade está no seu percurso</div>' : ''}
            `;
            
            restrictionsListContainer.appendChild(restrictionItem);
        });
    }

    // Alternar entre as rotas alternativas
    function switchAlternativeRoute(routeIndex) {
        if (routeIndex < 0 || routeIndex >= alternativeRoutes.length) {
            console.error("Índice de rota inválido:", routeIndex);
            return;
        }
        
        console.log(`Alternando para rota alternativa ${routeIndex}`);
        console.log("Rotas alternativas disponíveis:", alternativeRoutes);
        
        // Salvar o índice atual
        currentRouteIndex = routeIndex;
        
        // Limpar rota atual
        clearRoute();
        
        // Usar a rota selecionada
        const tspResult = alternativeRoutes[routeIndex];
        
        if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path)) {
            console.error("Rota alternativa inválida:", tspResult);
            // Substituir alert por notificação inline mais suave
            const notifyError = document.createElement('div');
            notifyError.className = 'alert alert-warning mt-2';
            notifyError.innerHTML = `Erro: a rota selecionada é inválida`;
            document.querySelector('.route-controls').appendChild(notifyError);
            
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyError && notifyError.parentNode) {
                    notifyError.parentNode.removeChild(notifyError);
                }
            }, 5000);
            return;
        }
        
        console.log("Usando rota com caminhos:", tspResult.path);
        
        // Reordenar os marcadores visualmente para corresponder à nova sequência
        reorderMarkers(tspResult.path);
            
        // Traçar a rota usando o Google Directions Service
        drawRouteOnMap(tspResult.path, "truck1");
            
        // Mostrar pontos de interesse ao longo da rota
        showPointsOfInterestOnRoute(tspResult.path);
            
        // Mostrar eventos nas cidades da rota
        showEventsForCitiesOnRoute(tspResult.path);
            
        // Mostrar restrições para caminhões nas cidades da rota
        showTruckRestrictionsForCitiesOnRoute(tspResult.path, null); // null para mostrar todos os tipos
            
        // Atualizar o resumo da rota
        updateRouteSummary(tspResult, "truck1", routeIndex);
        
        // Habilitar botões de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
    }
    
    // Função para gerar rotas alternativas
    function generateAlternativeRoutes(origin, destinations, includeOriginReturn) {
        // Limpar o array de rotas alternativas
        alternativeRoutes = [];
        
        // Limpar o seletor de rotas alternativas
        const alternativeSelect = document.getElementById('alternative-routes');
        alternativeSelect.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = "0";
        defaultOption.text = "Rota Otimizada (Padrão)";
        defaultOption.selected = true;
        alternativeSelect.appendChild(defaultOption);
        
        // 1. Rota principal (otimizada pelo algoritmo principal)
        console.log("Gerando rota principal otimizada...");
        const mainRoute = solveAdvancedTSP(origin, destinations, includeOriginReturn);
        alternativeRoutes.push(mainRoute);
        
        // Só criar rotas alternativas se houver mais de 2 destinos
        if (destinations.length >= 2) {
            try {
                // 2. Rota alternativa - Proximidade à origem
                console.log("Gerando rota alternativa 1: Proximidade à origem...");
                const originProximityRoute = solveOriginProximityTSP(origin, destinations, includeOriginReturn);
                alternativeRoutes.push(originProximityRoute);
                const option1 = document.createElement('option');
                option1.value = "1";
                option1.text = "Rota Alternativa 1 (Proximidade à Origem)";
                alternativeSelect.appendChild(option1);
            } catch (error) {
                console.error("Erro ao gerar rota por proximidade:", error);
            }
            
            try {
                // 3. Rota alternativa - Caminho em espiral (se tiver 3+ destinos)
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 2: Padrão espiral...");
                    const spiralRoute = solveSpiralTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(spiralRoute);
                    const option2 = document.createElement('option');
                    option2.value = "2";
                    option2.text = "Rota Alternativa 2 (Padrão Espiral)";
                    alternativeSelect.appendChild(option2);
                }
            } catch (error) {
                console.error("Erro ao gerar rota em espiral:", error);
            }
            
            try {
                // 4. Rota alternativa - Prioridade por cidade (se tiver 4+ destinos)
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 3: Agrupamento por cidade...");
                    const cityPriorityRoute = solveCityPriorityTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(cityPriorityRoute);
                    const routeIndex = alternativeRoutes.length - 1;
                    const cityOption = document.createElement('option');
                    cityOption.value = routeIndex.toString();
                    cityOption.text = `Rota Alternativa ${routeIndex} (Agrupamento por Cidade)`;
                    alternativeSelect.appendChild(cityOption);
                }
            } catch (error) {
                console.error("Erro ao gerar rota por cidade:", error);
            }
        }
        
        // Mostrar o seletor de rotas alternativas se houver mais de uma rota
        const routeAlternativesEl = document.getElementById('route-alternatives');
        if (routeAlternativesEl) {
            routeAlternativesEl.style.display = alternativeRoutes.length > 1 ? 'block' : 'none';
        }
        
        // Configurar o evento para alternar entre as rotas
        alternativeSelect.onchange = function() {
            switchAlternativeRoute(parseInt(this.value));
        };
        
        // Retornar a rota principal (a primeira no array)
        return alternativeRoutes[0];
    }
    
    // Algoritmo TSP baseado em proximidade à origem
    function solveOriginProximityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Ordenar destinos por distância à origem (do mais próximo ao mais distante)
            const sortedDestinations = [...destinations].sort((a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            });
            
            // Construir o caminho
            const path = [origin.id];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem de proximidade à origem
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP por proximidade à origem:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP em padrão espiral (norte, leste, sul, oeste)
    function solveSpiralTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por quadrante em relação à origem
            const northEast = [];
            const southEast = [];
            const southWest = [];
            const northWest = [];
            
            for (const dest of destinations) {
                if (dest.latitude >= origin.latitude) {
                    // Norte
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        northEast.push(dest);
                    } else {
                        // Oeste
                        northWest.push(dest);
                    }
                } else {
                    // Sul
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        southEast.push(dest);
                    } else {
                        // Oeste
                        southWest.push(dest);
                    }
                }
            }
            
            // Ordenar cada quadrante pela distância à origem
            const sortByDistanceToOrigin = (a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            };
            
            northEast.sort(sortByDistanceToOrigin);
            southEast.sort(sortByDistanceToOrigin);
            southWest.sort(sortByDistanceToOrigin);
            northWest.sort(sortByDistanceToOrigin);
            
            // Construir caminho em espiral: NE -> SE -> SW -> NW
            const sortedDestinations = [...northEast, ...southEast, ...southWest, ...northWest];
            
            // Construir o caminho
            const path = [origin.id];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem espiral
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP em padrão espiral:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP com prioridade por cidade (agrupar pontos da mesma cidade)
    function solveCityPriorityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por cidade
            const citiesMap = new Map();
            
            for (const dest of destinations) {
                const cityName = dest.address.split(',')[0].trim();
                if (!citiesMap.has(cityName)) {
                    citiesMap.set(cityName, []);
                }
                citiesMap.get(cityName).push(dest);
            }
            
            // Converter para array e ordenar cidades pela proximidade à origem
            const cities = Array.from(citiesMap.entries()).map(([cityName, cityDests]) => {
                // Calcular distância média da cidade à origem
                const avgDistance = cityDests.reduce((sum, dest) => {
                    return sum + calculateDistance(origin.latitude, origin.longitude, dest.latitude, dest.longitude);
                }, 0) / cityDests.length;
                
                return {
                    name: cityName,
                    destinations: cityDests,
                    avgDistanceToOrigin: avgDistance
                };
            });
            
            // Ordenar cidades pela distância média à origem
            cities.sort((a, b) => a.avgDistanceToOrigin - b.avgDistanceToOrigin);
            
            // Construir caminho visitando todas as cidades em ordem de proximidade
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("ID de origem usado no caminho:", originId, "Tipo:", typeof originId);
            
            const path = [originId];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Para cada cidade, visitar todos os seus pontos
            for (const city of cities) {
                // Ordenar pontos da cidade pelo mais próximo ao ponto atual
                city.destinations.sort((a, b) => {
                    const distA = calculateDistance(currentLocation.latitude, currentLocation.longitude, a.latitude, a.longitude);
                    const distB = calculateDistance(currentLocation.latitude, currentLocation.longitude, b.latitude, b.longitude);
                    return distA - distB;
                });
                
                // Adicionar pontos da cidade ao caminho
                for (const dest of city.destinations) {
                    // Converter o ID para string para consistência
                    const destId = String(dest.id);
                    console.log(`Adicionando destino ${dest.name} com ID:`, destId, "Tipo:", typeof destId);
                    
                    path.push(destId);
                    const dist = calculateDistance(
                        currentLocation.latitude, currentLocation.longitude,
                        dest.latitude, dest.longitude
                    );
                    totalDistance += dist;
                    currentLocation = dest;
                }
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP com prioridade por cidade:", error);
            return {
                path: [origin.id],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Atualizar o resumo da rota
    function updateRouteSummary(tspResult, vehicleType, routeIndex = 0) {
        try {
            console.log("Atualizando resumo da rota com:", tspResult);
            
            // Verificar se temos resultados válidos
            if (!tspResult || typeof tspResult.distance !== 'number' || isNaN(tspResult.distance)) {
                console.error("Dados incompletos ou inválidos do TSP:", tspResult);
                
                // Adicionar um valor padrão para distância se não for válido
                if (!tspResult.distance || isNaN(tspResult.distance)) {
                    console.log("Corrigindo valor de distância");
                    
                    // Calcular uma distância aproximada com base nos pontos
                    let approxDistance = 0;
                    if (tspResult && tspResult.path && tspResult.path.length > 1) {
                        for (let i = 0; i < tspResult.path.length - 1; i++) {
                            const p1 = tspResult.path[i];
                            const p2 = tspResult.path[i+1];
                            approxDistance += calculateDistance(
                                p1.latitude, p1.longitude,
                                p2.latitude, p2.longitude
                            );
                        }
                        tspResult.distance = approxDistance;
                        console.log("Distância recalculada:", approxDistance, "km");
                    } else {
                        tspResult.distance = 0;
                    }
                }
            }
            
            // Veículo fixo (caminhão 1 eixo)
            const selectedVehicle = {
                name: "Caminhão",
                averageSpeed: 80 // km/h - velocidade média ajustada para 80km/h conforme solicitado
            };
            
            // Tempo estimado (baseado na velocidade média padrão do caminhão)
            const estimatedTime = tspResult.distance / selectedVehicle.averageSpeed; // em horas
            
            // Atualizar o conteúdo do resumo
            const summaryContainer = document.getElementById('route-summary');
            if (!summaryContainer) {
                console.error("Elemento 'route-summary' não encontrado");
                return;
            }
            
            summaryContainer.style.display = 'block';
            
            // Formatar o tempo em horas e minutos
            const hours = Math.floor(estimatedTime);
            const minutes = Math.round((estimatedTime - hours) * 60);
            const timeFormatted = hours > 0 ? 
                                `${hours}h ${minutes}min` : 
                                `${minutes}min`;
            
            console.log("Distância calculada:", tspResult.distance.toFixed(1), "km");
            console.log("Tempo estimado:", timeFormatted);
            
            // Construir a lista de cidades na rota
            let locationsList = '';
            
            // Verificar se temos path válido
            if (tspResult.path && tspResult.path.length > 0) {
                // Criar a lista de locais na ordem da rota
                // Primeiro, obter objetos completos de location para cada ID no path
                const orderedLocations = [];
                tspResult.path.forEach(locationId => {
                    const id = String(locationId);
                    const location = locations.find(loc => String(loc.id) === id);
                    if (location) {
                        orderedLocations.push(location);
                    } else {
                        console.error(`Localização não encontrada para ID: ${id}`);
                    }
                });
                
                // Agora criar a lista formatada com as localizações ordenadas
                locationsList = orderedLocations.map(location => {
                    // Garantir que os nomes estão formatados corretamente
                    const locationName = formatLocationName(location.name || '');
                    const locationAddress = formatLocationName(location.address || '');
                    
                    // Verificar se é origem para destacar
                    if (location.isOrigin) {
                        return `<li class="origin-point"><strong>${locationName}</strong> ${locationAddress ? `(${locationAddress})` : ''} (Origem)</li>`;
                    } else {
                        return `<li><strong>${locationName}</strong> ${locationAddress ? `(${locationAddress})` : ''}</li>`;
                    }
                }).join('');
            } else {
                locationsList = '<li>Nenhum local encontrado na rota</li>';
            }
        
            // Determinar rótulo da rota alternativa
            let routeLabel = "";
            if (routeIndex > 0) {
                routeLabel = ` (Alternativa ${routeIndex})`;
            }
            
            summaryContainer.innerHTML = `
                <div class="summary-header">Resumo da Rota${routeLabel}</div>
                <div class="row">
                    <div class="col-12">
                        <p><strong>Distância total:</strong> ${tspResult.distance.toFixed(1)} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeFormatted}</p>
                    </div>
                </div>
                
                <div class="mt-3">
                    <div class="summary-header">Sequência da Rota</div>
                    <ol id="route-steps">
                        ${locationsList}
                    </ol>
                </div>
                
                <!-- Campo "Nome da rota" removido daqui para evitar duplicação, já existe na aba relatório -->
                
            `;
            
            // Habilitar botões de salvar e imprimir
            document.getElementById('save-route').disabled = false;
            document.getElementById('print-route').disabled = false;
            
            // Disparar evento para notificar que a rota foi otimizada
            const routeOptimizedEvent = new Event('routeOptimized');
            document.dispatchEvent(routeOptimizedEvent);
            
        } catch (error) {
            console.error("Erro ao atualizar resumo da rota:", error, error.stack);
            
            // Em caso de erro, mostrar mensagem simplificada
            const summaryContainer = document.getElementById('route-summary');
            if (summaryContainer) {
                summaryContainer.innerHTML = `
                    <div class="alert alert-danger">
                        Ocorreu um erro ao processar o resumo da rota. Por favor, tente novamente.
                    </div>
                `;
                summaryContainer.style.display = 'block';
            }
        }
    }

    // Filtrar eventos por data - atualiza automaticamente ao mudar datas
    function filterEventsByDate() {
        console.log("Filtrando eventos por datas e atualizando restrições para caminhões");
        
        // Obter valores atuais das datas para filtro
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        console.log(`Datas selecionadas: ${startDate || 'vazia'} até ${endDate || 'vazia'}`);
        
        let routeIds = [];
        
        // Se tivermos uma rota otimizada atual, usar os pontos dessa rota
        if (currentOptimizedPath && currentOptimizedPath.length > 0) {
            console.log("Usando rota otimizada atual:", currentOptimizedPath);
            routeIds = [...currentOptimizedPath]; // Clonar para não modificar o original
        } else if (directionsRenderer && directionsRenderer.getDirections()) {
            // Se tivermos uma rota no renderer mas não otimizada, usar locais atuais
            console.log("Usando locais atuais como rota");
            routeIds = locations.map(loc => loc.id);
        } else {
            // Se não tivermos rota, mostrar apenas para origem
            console.log("Sem rota, mostrando apenas para origem");
            // Mostrar notificação para indicar que é necessário calcular uma rota
            const notifyInfo = document.createElement('div');
            notifyInfo.className = 'alert alert-info mt-2';
            notifyInfo.innerHTML = `Calcule uma rota primeiro para ver os eventos e restrições no percurso.`;
            const tabContent = document.querySelector('.tab-content');
            if (tabContent) {
                tabContent.appendChild(notifyInfo);
                // Remover a notificação após alguns segundos
                setTimeout(() => {
                    if (notifyInfo && notifyInfo.parentNode) {
                        notifyInfo.parentNode.removeChild(notifyInfo);
                    }
                }, 5000);
            }
            
            routeIds = [mockData.origin.id];
        }
        
        // Mostrar eventos para as cidades da rota com filtro por data
        showEventsForCitiesOnRoute(routeIds);
        
        // Mostrar restrições para TODOS os tipos de caminhões nas cidades da rota
        // Passando null para indicar que queremos mostrar para todos os tipos
        showTruckRestrictionsForCitiesOnRoute(routeIds, null);
    }

    // Salvar a rota
    function saveRoute() {
        // Verificar primeiro o campo no relatório principal
        let routeName = document.getElementById('report-route-name').value;
        
        // Se estiver vazio, verificar o campo no modal
        if (!routeName) {
            routeName = document.getElementById('route-name-modal').value;
        }
        
        if (!routeName) {
            // Substituir alert por notificação inline mais suave
            const notifyWarning = document.createElement('div');
            notifyWarning.className = 'alert alert-warning mt-2';
            notifyWarning.innerHTML = `Por favor, dê um nome para a rota antes de salvar.`;
            document.querySelector('.route-controls').appendChild(notifyWarning);
            
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyWarning && notifyWarning.parentNode) {
                    notifyWarning.parentNode.removeChild(notifyWarning);
                }
            }, 5000);
            return;
        }
        
        // Substituir alert por notificação inline mais suave
        const notifySuccess = document.createElement('div');
        notifySuccess.className = 'alert alert-success mt-2';
        notifySuccess.innerHTML = `Rota "${routeName}" salva com sucesso!`;
        document.querySelector('.route-controls').appendChild(notifySuccess);
        
        // Remover a notificação após alguns segundos
        setTimeout(() => {
            if (notifySuccess && notifySuccess.parentNode) {
                notifySuccess.parentNode.removeChild(notifySuccess);
            }
        }, 5000);
    }

    // Imprimir a rota
    function printRoute() {
        window.print();
    }

    // Zoom para mostrar todos os marcadores
    function zoomToFitAllMarkers() {
        if (markers.length === 0) return;
        
        const bounds = new google.maps.LatLngBounds();
        markers.forEach(markerObj => {
            bounds.extend(markerObj.marker.getPosition());
        });
        
        map.fitBounds(bounds);
    }

    // Alternador para mostrar/esconder pontos de interesse
    function togglePointsOfInterest() {
        showPOIs = !showPOIs;
        
        // Ajustar visibilidade dos marcadores
        poiMarkers.forEach(marker => {
            marker.setVisible(showPOIs);
        });
        
        // Se tivermos uma rota ativa e quisermos mostrar POIs, recarregar os POIs
        if (showPOIs && directionsRenderer.getDirections()) {
            showPointsOfInterestOnRoute(locations);
        }
    }

    // Criar tooltip personalizado
    function createCustomTooltip() {
        try {
            // Criar elemento de tooltip
            customTooltip = document.createElement('div');
            customTooltip.className = 'custom-tooltip';
            customTooltip.style.display = 'none';
            
            // Verificar se o body existe antes de adicionar
            if (document.body) {
                document.body.appendChild(customTooltip);
                console.log("Tooltip personalizado criado com sucesso");
            } else {
                console.error("document.body não está disponível para adicionar o tooltip");
            }
        } catch (err) {
            console.error("Erro ao criar tooltip personalizado:", err);
        }
    }

    // Mostrar tooltip
    function showTooltip(marker, data) {
        // Se o dado tiver conteúdo de tooltip predefinido, usar esse
        if (data.tooltipContent) {
            customTooltip.innerHTML = data.tooltipContent;
        } else {
            // Caso contrário, construir baseado no tipo de ponto de interesse
            let content = `<div class="tooltip-title">${data.name}</div>`;
            
            if (data.type === 'toll') {
                content += `
                    <div>Pedágio na rodovia ${data.highway}</div>
                    <div>Valor: R$ ${data.cost.toFixed(2)}</div>
                `;
            } else if (data.type === 'weighStation') {
                content += `
                    <div>Balança na rodovia ${data.highway}</div>
                    <div>Status: ${data.isActive ? 'Ativa' : 'Inativa'}</div>
                `;
            } else if (data.type === 'gasStation') {
                content += `
                    <div>Posto de combustível</div>
                    <div>Serviços: ${formatServices(data.services)}</div>
                `;
            } else {
                content += `
                    <div>Ponto de interesse em ${data.cityName}</div>
                `;
            }
            
            customTooltip.innerHTML = content;
        }
        
        // Posicionar o tooltip acima do marcador
        const projection = map.getProjection();
        const position = marker.getPosition();
        const pixelOffset = overlay.getProjection().fromLatLngToDivPixel(position);
        
        customTooltip.style.left = pixelOffset.x + 'px';
        customTooltip.style.top = (pixelOffset.y - 120) + 'px'; // Posicionar acima do marcador
        customTooltip.style.display = 'block';
    }

    // Esconder tooltip
    function hideTooltip() {
        if (customTooltip) {
            customTooltip.style.display = 'none';
        }
    }

    // Formatar lista de serviços
    function formatServices(services) {
        if (!services || !Array.isArray(services)) return '';
        
        const serviceNames = {
            'food': 'Alimentação',
            'rest': 'Área de descanso',
            'shower': 'Chuveiro',
            'mechanic': 'Mecânico',
            'tire': 'Borracharia'
        };
        
        return services.map(s => serviceNames[s] || s).join(', ');
    }

    // Implementação avançada do algoritmo do Caixeiro Viajante (TSP)
    // Idêntico ao comportamento da versão Replit
    function solveAdvancedTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP avançado com", destinations.length, "destinos");
        
        // Se não houver destinos, retornar apenas a origem
        if (!destinations.length) {
            console.log("Sem destinos, retornando apenas origem");
            return {
                path: [origin],
                distance: 0
            };
        }
        
        // Verificar se os objetos têm as propriedades necessárias
        if (!origin.latitude || !origin.longitude) {
            console.error("Origem sem coordenadas:", origin);
            // Criar coordenadas padrão para Dois Córregos se não existirem
            origin.latitude = origin.latitude || -22.3673;
            origin.longitude = origin.longitude || -48.3822;
        }
        
        // Verificar e corrigir destinos sem coordenadas
        for (let i = 0; i < destinations.length; i++) {
            if (!destinations[i].latitude || !destinations[i].longitude) {
                console.error("Destino sem coordenadas:", destinations[i]);
                // Atribuir coordenadas aproximadas baseadas em Dois Córregos com deslocamento
                destinations[i].latitude = -22.3673 + (Math.random() - 0.5) * 0.1;
                destinations[i].longitude = -48.3822 + (Math.random() - 0.5) * 0.1;
            }
        }
        
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Verificar se há pontos na mesma cidade da origem
        // Se houver, devem ser visitados primeiro
        const sameCity = [];
        const otherCities = [];
        
        destinations.forEach(dest => {
            if (isSameCity(dest, origin)) {
                sameCity.push(dest);
            } else {
                otherCities.push(dest);
            }
        });
        
        // Se há pontos na mesma cidade, priorizá-los
        if (sameCity.length > 0) {
            // Colocar os pontos da mesma cidade primeiro, depois resolver o restante
            console.log(`Encontrado ${sameCity.length} pontos na mesma cidade da origem. Priorizando.`);
            
            // Calcular a distância para priorizar essa ordem
            let sameCityDist = 0;
            const sameCityPath = [origin, ...sameCity];
            
            for (let i = 0; i < sameCityPath.length - 1; i++) {
                const dist = calculateDistance(
                    sameCityPath[i].latitude, sameCityPath[i].longitude,
                    sameCityPath[i+1].latitude, sameCityPath[i+1].longitude
                );
                sameCityDist += dist;
                console.log(`Distância de ${sameCityPath[i].name} para ${sameCityPath[i+1].name}: ${dist.toFixed(1)} km`);
            }
            
            // Se não temos outros pontos, retornar apenas os da mesma cidade
            if (otherCities.length === 0) {
                console.log("Apenas pontos na mesma cidade, distância total:", sameCityDist.toFixed(1), "km");
                return {
                    path: sameCityPath,
                    distance: sameCityDist
                };
            }
            
            // Resolver o TSP para os outros pontos
            const otherResult = solveBasicTSP(sameCityPath[sameCityPath.length-1], otherCities, includeReturn);
            
            // Combinar os caminhos
            const fullPath = [...sameCityPath.slice(0, -1), ...otherResult.path];
            const fullDistance = sameCityDist + otherResult.distance;
            
            console.log("Combinando caminhos, distância na mesma cidade:", sameCityDist.toFixed(1), 
                       "km, distância para outras cidades:", otherResult.distance.toFixed(1), 
                       "km, total:", fullDistance.toFixed(1), "km");
            
            return {
                path: fullPath,
                distance: fullDistance
            };
        }
        
        const result = solveBasicTSP(origin, destinations, includeReturn);
        console.log("TSP básico, distância total:", result.distance.toFixed(1), "km");
        return result;
    }
    
    // Versão básica do TSP para cidades diferentes
    function solveBasicTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP básico com", destinations.length, "destinos");
        
        // Verificar se existem pontos na mesma cidade que o último ponto antes de iniciar
        const sameCityPoints = destinations.filter(dest => isSameCity(dest, origin));
        if (sameCityPoints.length > 0) {
            console.log(`Encontrados ${sameCityPoints.length} pontos na mesma cidade que o ponto de partida (${origin.name}). Eles serão priorizados.`);
        }
        
        // Ordenar os destinos por proximidade da origem para priorizar a ordem
        let sortedDestinations = [...destinations].sort((a, b) => {
            // Se um está na mesma cidade da origem e o outro não, o da mesma cidade vem primeiro
            const aInSameCity = isSameCity(a, origin);
            const bInSameCity = isSameCity(b, origin);
            
            if (aInSameCity && !bInSameCity) return -1;
            if (!aInSameCity && bInSameCity) return 1;
            
            // Se ambos estão ou não na mesma cidade, ordenar por distância
            const distA = calculateDistance(
                origin.latitude, origin.longitude, 
                a.latitude, a.longitude
            );
            
            const distB = calculateDistance(
                origin.latitude, origin.longitude, 
                b.latitude, b.longitude
            );
            
            return distA - distB;
        });
        
        // Log da ordem pré-calculada
        console.log("Destinos ordenados por proximidade:", 
                   sortedDestinations.map((d, i) => 
                                         `${i+1}. ${d.name} (${isSameCity(d, origin) ? "mesma cidade, " : ""}${calculateDistance(
                                             origin.latitude, origin.longitude,
                                             d.latitude, d.longitude
                                         ).toFixed(1)} km)`).join(", "));
        
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Matriz de distâncias entre todos os pontos
        const points = [origin, ...sortedDestinations];
        const numPoints = points.length;
        const distMatrix = Array(numPoints).fill().map(() => Array(numPoints).fill(0));
        
        // Preencher a matriz de distâncias
        for (let i = 0; i < numPoints; i++) {
            for (let j = i + 1; j < numPoints; j++) {
                const dist = calculateDistance(
                    points[i].latitude, points[i].longitude,
                    points[j].latitude, points[j].longitude
                );
                distMatrix[i][j] = dist;
                distMatrix[j][i] = dist; // A matriz é simétrica
            }
        }
        
        // Método Nearest Insertion: começamos com a rota origem -> ponto mais próximo -> origem
        // e iterativamente adicionamos o melhor ponto para inserir na rota atual
        
        // Inicializar com o ponto mais próximo da origem
        let bestDist = Infinity;
        let bestIdx = -1;
        
        for (let i = 1; i < numPoints; i++) {
            if (distMatrix[0][i] < bestDist) {
                bestDist = distMatrix[0][i];
                bestIdx = i;
            }
        }
        
        // Rota inicial: origem -> ponto mais próximo
        let tour = [0, bestIdx];
        let remaining = Array.from({length: numPoints - 1}, (_, i) => i + 1);
        remaining.splice(remaining.indexOf(bestIdx), 1);
        
        // Calcular a distância inicial
        totalDistance = bestDist;
        
        // Usar a função auxiliar para completar o algoritmo
        const result = finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn);
        tour = result.tour;
        totalDistance = result.totalDistance;
        
        // Se não for para incluir retorno, remover o último link (do último ponto de volta à origem)
        if (!includeReturn && tour.length > 1) {
            const last = tour[tour.length - 1];
            totalDistance -= distMatrix[last][0];
            // Não removemos a origem do início porque a rota deve começar na origem
        }
        
        // Converter os índices de tour de volta para os pontos reais
        const path = tour.map(idx => points[idx]);
        
        // Ajustar a rota se não for para incluir retorno à origem
        if (!includeReturn) {
            // Garante que a rota não termine voltando para a origem
            if (path[path.length - 1] === origin) {
                path.pop();
            }
        } else {
            // Garante que a rota termine na origem
            if (path[path.length - 1] !== origin) {
                path.push(origin);
                
                // Adicionar a distância de retorno
                const lastPoint = path[path.length - 2];
                const returnDistance = calculateDistance(
                    lastPoint.latitude, lastPoint.longitude,
                    origin.latitude, origin.longitude
                );
                totalDistance += returnDistance;
            }
        }
        
        return {
            path: path,
            distance: totalDistance
        };
    }
    
    // Manteremos a versão simples para compatibilidade
    function solveTSP(origin, destinations, includeReturn) {
        return solveAdvancedTSP(origin, destinations, includeReturn);
    }
    
    // Função para finalizar o algoritmo TSP básico
    function finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn) {
        // Enquanto houver pontos não visitados
        while (remaining.length > 0) {
            let bestInsertion = {
                point: -1,
                position: -1,
                cost: Infinity
            };
            
            // Para cada ponto restante
            for (let i = 0; i < remaining.length; i++) {
                const point = remaining[i];
                
                // Para cada possível posição de inserção no tour atual
                for (let j = 1; j <= tour.length; j++) {
                    const prev = tour[j-1];
                    const next = j < tour.length ? tour[j] : tour[0]; // Se estamos no final, o próximo é o início
                    
                    // Calcular o custo de inserção = dist(prev, point) + dist(point, next) - dist(prev, next)
                    const insertionCost = distMatrix[prev][point] + 
                                         distMatrix[point][next] -
                                         distMatrix[prev][next];
                    
                    if (insertionCost < bestInsertion.cost) {
                        bestInsertion = {
                            point: point,
                            position: j,
                            cost: insertionCost
                        };
                    }
                }
            }
            
            // Inserir o melhor ponto na melhor posição
            tour.splice(bestInsertion.position, 0, bestInsertion.point);
            remaining.splice(remaining.indexOf(bestInsertion.point), 1);
            
            // Atualizar a distância total
            totalDistance += bestInsertion.cost;
        }
        
        return { tour, totalDistance };
    }

    // Calcular distância entre dois pontos usando a fórmula de Haversine
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Raio da Terra em km
        const dLat = deg2rad(lat2 - lat1);
        const dLon = deg2rad(lon2 - lon1);
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
            Math.sin(dLon/2) * Math.sin(dLon/2); 
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        const distance = R * c; // Distância em km
        return distance;
    }

    // Converter graus para radianos
    function deg2rad(deg) {
        return deg * (Math.PI/180);
    }

    // Classe para projeção de overlay personalizado
    class OverlayProjection {
        fromLatLngToDivPixel(latLng) {
            const scale = Math.pow(2, map.getZoom());
            const proj = map.getProjection();
            const bounds = map.getBounds();
            
            if (!proj || !bounds) {
                return { x: 0, y: 0 };
            }
            
            const nw = proj.fromLatLngToPoint(
                new google.maps.LatLng(
                    bounds.getNorthEast().lat(),
                    bounds.getSouthWest().lng()
                )
            );
            
            const point = proj.fromLatLngToPoint(latLng);
            
            return {
                x: Math.floor((point.x - nw.x) * scale),
                y: Math.floor((point.y - nw.y) * scale)
            };
        }
        
        fromDivPixelToLatLng(pixel) {
            return null; // Não precisamos desta funcionalidade
        }
    }

    // Criar um overlay personalizado para a projeção
    const overlay = new google.maps.OverlayView();
    overlay.draw = function() {};
    overlay.setMap(map);
    overlay.getProjection = function() {
        return new OverlayProjection();
    };

    // Expor funções necessárias globalmente
    window.removeLocation = removeLocation;
    </script>
</body>
</html>