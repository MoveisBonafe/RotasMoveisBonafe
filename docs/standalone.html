<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ffc107">
    <meta name="description" content="Otimizador de Rotas Móveis Bonafé - Solução para logística e transporte, com suporte a cálculo de rotas entre múltiplos pontos, otimização de sequência, e visualização de eventos e restrições em cidades brasileiras." />
    <meta name="keywords" content="Bonafé, otimizador de rotas, problema do caixeiro viajante, logística, transporte, planejamento de rotas, otimização de entregas, Brasil, Google Maps, pedágios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas Móveis Bonafé" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas Móveis Bonafé</title>
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="apple-touch-icon" href="assets/icon-192.png">
    <link rel="manifest" href="assets/manifest.json">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            width: 100%;
            position: relative; /* Importante para posicionamento absoluto das abas */
        }
        
        .main-content-area {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
            height: calc(100vh - 60px); /* Ajuste de altura para abas minimizadas maiores */
            position: relative; /* Importante para posicionamento dos elementos filhos */
        }
        .sidebar {
            width: 380px;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            position: fixed; /* Fixar a sidebar no lado esquerdo */
            top: 0;
            left: 0;
            bottom: 0;
            max-height: 100vh; /* Garantir que não ultrapasse a altura da janela */
            scrollbar-width: thin; /* Para Firefox */
            scrollbar-color: #adb5bd #f8f9fa; /* Para Firefox */
        }
        
        /* Estilizar scrollbar para navegadores baseados em WebKit (Chrome, Safari) */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background-color: #adb5bd;
            border-radius: 10px;
            border: 2px solid #f8f9fa;
        }
        
        /* Melhorar layout da sidebar para GitHub Pages */
        .sidebar-header {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Estilização do título da aplicação */
        .app-title {
            display: flex;
            flex-direction: column;
            line-height: 1.1;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.5px;
            position: relative;
            padding: 8px 0;
        }
        
        .app-title::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            height: 100%;
            width: 3px;
            background: linear-gradient(to bottom, #000000, #ffc107);
            border-radius: 3px;
            animation: heightGrow 1.2s ease-in-out;
        }
        
        .app-title-text {
            font-size: 1.4rem;
            font-weight: 600;
            color: #000000;
            animation: fadeIn 1.5s ease-in-out;
        }
        
        .app-title-highlight {
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ffc107 0%, #ffab00 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: slideInRight 1s ease-in-out;
            margin-top: -5px;
            letter-spacing: -0.2px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideInRight {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes heightGrow {
            from { height: 0; }
            to { height: 100%; }
        }
        
        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .map-container {
            flex: 1;
            height: 100%;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        /* Botão toggle-sidebar removido */
        .form-group {
            margin-bottom: 15px;
        }
        .location-list {
            max-height: 250px; /* Reduzido para deixar espaço para rotas alternativas */
            overflow-y: auto;
            margin-top: 10px;
            margin-bottom: 10px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            background-color: #fff;
        }
        /* Spinner de carregamento */
        #loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            display: none;
            text-align: center;
        }
        
        #loading-spinner::after {
            content: "";
            display: block;
            width: 40px;
            height: 40px;
            margin: 10px auto;
            border-radius: 50%;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            animation: spin 2s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-address {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn-container {
            position: sticky;
            bottom: 0;
            background-color: #f8f9fa;
            padding: 15px 0;
            margin-top: 20px;
        }
        #optimize-route {
            width: 100%;
            padding: 10px 0;
            font-weight: 600;
            background-color: #ffc107;
            border-color: #ffab00;
            color: #000;
            transition: all 0.3s ease;
        }
        
        #optimize-route:hover {
            background-color: #ffab00;
            border-color: #ff9800;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 171, 0, 0.3);
        }
        
        .optimize-btn-container {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .marker-label {
            color: black;
            background-color: #ffc107;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 14px;
        }
        
        /* Estilo para o cartão de rotas alternativas */
        .route-option-card {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .route-option-card:hover {
            border-color: #ffc107;
            box-shadow: 0 3px 6px rgba(255, 193, 7, 0.2);
            transform: translateY(-2px);
        }
        .route-option-card.selected {
            border-color: #ffab00;
            background-color: #fff8e1;
        }
        
        /* Estilo para a seção de rotas alternativas na sidebar */
        .alternative-routes-section {
            margin-top: 5px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .alternative-routes-section h5 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            color: #495057;
        }
        .pac-container {
            z-index: 9999; /* Garantir que as sugestões apareçam acima de outros elementos */
        }
        .truck-icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
        }
        .truck-type {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .truck-type label {
            margin-left: 10px;
            cursor: pointer;
        }
        /* Estilos para rota personalizada */
        .draggable {
            cursor: move;
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .draggable:hover {
            background-color: #fffbeb;
        }
        
        .draggable:hover::before {
            content: '⇕';
            position: absolute;
            left: 5px;
            color: #ffc107;
        }
        
        .location-item.dragging {
            opacity: 0.7;
            background-color: #fffbeb;
            border: 1px dashed #ffc107;
        }
        
        .custom-route-active .location-item {
            position: relative;
            padding-left: 30px;
        }
        
        .custom-route-active .location-item::before {
            content: "≡";
            position: absolute;
            left: 10px;
            color: #6c757d;
            font-size: 18px;
        }
        
        .custom-route-active .location-item:hover {
            background-color: #f8f9fa;
        }

        #route-summary {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #fff8e1;
            border-radius: 8px;
            border: 1px solid #ffe082;
        }
        #route-steps {
            margin-top: 15px;
            padding-left: 15px;
        }
        .summary-header {
            font-weight: bold;
            margin-bottom: 10px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333333;
        }
        /* Estilos para a área de upload de arquivo */
        .file-upload {
            margin-top: 15px;
            border: 2px dashed #ffc107;
            padding: 15px 10px;
            text-align: center;
            border-radius: 8px;
            background-color: #fffbeb;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }
        .file-upload:hover, .file-upload.dragover {
            border-color: #ffab00;
            background-color: #fff8e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 171, 0, 0.15);
        }
        .file-upload p {
            margin-bottom: 10px;
            color: #444;
            font-weight: 500;
        }
        .file-upload-icon {
            display: block;
            margin: 0 auto 5px;
            font-size: 24px;
            color: #ffc107;
        }
        .file-format-example {
            background-color: #fff8e1;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            display: inline-block;
            margin: 4px auto;
            color: #2c3e50;
            border: 1px solid #bde0ff;
            font-size: 12px;
        }
        .file-upload input[type="file"] {
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .file-upload-text {
            display: block;
            margin-top: 5px;
            color: #5a5a5a;
            font-size: 13px;
        }
        /* Estilos para notificação de sucesso no upload */
        .upload-success {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            height: 100%;
        }
        .upload-success-icon {
            font-size: 48px;
            color: #ffc107;
            margin-bottom: 10px;
            animation: scale-in 0.3s ease-out;
        }
        .upload-success-text {
            color: #555;
            font-size: 16px;
            margin-top: 5px;
        }
        .file-upload.success {
            border-color: #2ecc71;
            background-color: #ebfaf0;
            transition: all 0.3s ease;
        }
        .file-upload.fading {
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        @keyframes scale-in {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            80% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        /* Botão para fechar o sidebar em telas pequenas */
        .sidebar-close {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        /* Estilo quando o sidebar está fechado */
        .sidebar-hidden {
            transform: translateX(-100%);
        }
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 100%;
                max-width: 320px;
            }
            .sidebar-close {
                display: block;
            }
            .toggle-sidebar {
                display: block;
            }
        }
        /* Estilo para o ponto de origem na lista da rota */
        .origin-point {
            font-weight: bold;
            border-bottom: 1px solid #ffc107;
            padding-bottom: 3px;
            margin-bottom: 5px;
            color: #333333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Estilo para os marcadores de pontos de interesse */
        .poi-marker {
            background-color: #ffc107;
            border-radius: 50%;
            color: black;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            font-size: 12px;
        }
        /* Estilos para animação de input */
        .input-animation-container {
            position: relative;
            overflow: hidden;
        }

        .input-animation-effect {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background-color: #ffc107;
            transition: width 0.3s ease;
        }

        .input-animation-container input:focus + .input-animation-effect {
            width: 100%;
        }
        
        /* Estilos para tooltip personalizado */
        .custom-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
        }
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        /* Estilos para abas - Nova versão com animação e layout inferior */
        .tab-container {
            width: 100%;
            margin-top: 40px;
            position: relative;
            transition: all 0.5s ease;
        }
        .tab-buttons {
            display: flex;
            justify-content: center;
            background: #fff8e1;
            border-top: 1px solid #ffe082;
            border-bottom: 1px solid #ffe082;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 -2px 10px rgba(255, 193, 7, 0.1);
        }
        .tab-button {
            padding: 10px 20px;
            margin: 0 5px;
            background-color: #f8f9fa;
            border: 1px solid #ffe082;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            color: #495057;
            position: relative;
            overflow: hidden;
        }
        .tab-button::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #ffc107;
            transform: translateY(3px);
            transition: transform 0.3s ease;
        }
        .tab-button:hover {
            background-color: #fff8e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.2);
        }
        .tab-button:hover::after {
            transform: translateY(0);
        }
        .tab-button.active {
            background-color: #ffc107;
            color: black;
            border-color: #ffab00;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 171, 0, 0.3);
        }
        .tab-button.active::after {
            background-color: white;
            transform: translateY(0);
        }
        .tab-content {
            display: none;
            padding: 25px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            margin-top: 20px;
            animation: fadeInUp 0.5s ease forwards;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        .tab-content.active {
            display: block;
            max-height: 2000px;
            overflow-y: auto;
        }
        
        /* Animações para as abas e conteúdo */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Estilo para datas */
        .date-range-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .date-range-container input {
            flex: 1;
            border: 1px solid #ffe082;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }
        .date-range-container input:focus {
            border-color: #ffc107;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
            outline: none;
        }
        .date-range-label {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #333;
            display: block;
        }
        
        /* Estilos para ícones de evento */
        .event-marker {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: black;
            font-size: 14px;
        }
        .event-marker.holiday {
            background-color: #ffc107; /* Amarelo Bonafé para feriados */
            color: black;
        }
        .event-marker.event {
            background-color: #ffab00; /* Amarelo escuro para eventos */
            color: black;
        }
        
        /* Estilo para lista de eventos */
        .events-list {
            margin-top: 15px;
            min-height: 300px; /* Altura mínima */
            overflow-y: auto;
            width: 100%; /* Garantir que ocupe toda a largura disponível */
            height: 100%; /* Garantir que ocupe toda a altura disponível */
            transition: all 0.3s ease; /* Transição suave ao expandir */
        }
        .event-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .event-name {
            font-weight: bold;
            color: #ffc107;
        }
        .event-date {
            font-size: 0.8em;
            color: #666;
        }
        .event-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .event-type.holiday {
            background-color: #f44336;
        }
        .event-type.event {
            background-color: #ff9800;
        }
        .restriction-level {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-level.low {
            background-color: #4caf50;
        }
        .restriction-level.medium {
            background-color: #ff9800;
        }
        .restriction-level.high {
            background-color: #f44336;
        }
        
        /* Estilos para restrições de caminhões */
        .restrictions-list {
            margin-top: 10px;
            min-height: 300px; /* Altura mínima */
            overflow-y: auto;
            width: 100%; /* Garantir que ocupe toda a largura disponível */
            height: 100%; /* Garantir que ocupe toda a altura disponível */
            transition: all 0.3s ease; /* Transição suave ao expandir */
        }
        .restriction-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .restriction-city {
            font-weight: bold;
            color: #ffc107;
        }
        .restriction-time {
            font-size: 0.8em;
            color: #666;
        }
        .restriction-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: black;
        }
        .restriction-type.partial {
            background-color: #ffc107;
        }
        .restriction-type.total {
            background-color: #ffab00;
        }
        .restriction-type.rodizio {
            background-color: #ffe082;
        }

        /* Estilos para animação da rota */
        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
            }
        }
        .animated-path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawPath 3s ease-in-out forwards;
        }

        /* Botões de controle da visualização */
        .map-controls {
            position: absolute;
            bottom: 24px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .map-control-btn {
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Estilo para o spinner de carregamento */
        .spinner-border {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
        }
        
        /* NOVO LAYOUT - Tabs na parte inferior do mapa (fixas) */
        .bottom-tabs-container {
            width: calc(100% - 380px); /* Ajustado para não sobrepor a sidebar */
            margin-top: 0;
            margin-bottom: 0;
            margin-left: 380px; /* Afastado para alinhar com a sidebar */
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.5s ease;
            background-color: #f9f9f9;
            border-top: 1px solid #ddd;
            overflow: auto; /* Alterado para auto para permitir rolagem */
            /* Inicialmente minimizada ao invés de oculta */
            display: flex;
            height: auto;
            /* Ajustes para expandir até o topo quando aberto */
            position: fixed; /* Alterado para fixed para cobrir toda a tela */
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000; /* Aumentado para ficar sobre todos os elementos */
            transition: height 0.3s ease-in-out;
            box-sizing: border-box; /* Garantir que padding e border não afetem o tamanho */
        }
        
        /* Media query para garantir que o layout permaneça estável em diferentes tamanhos de tela */
        @media (min-width: 1024px) {
            .bottom-tabs-container {
                width: calc(100% - 380px);
                margin-left: 380px;
            }
        }
        
        /* Estado minimizado para container de abas */
        .bottom-tabs-container.minimized {
            height: 60px; /* Altura quando minimizado */
            overflow: hidden;
        }
        
        /* Estado expandido para container de abas */
        .bottom-tabs-container:not(.minimized) {
            height: calc(100vh - 10px); /* Quase altura total da tela quando expandido */
            border-top: 2px solid #1976D2; /* Borda mais visível quando expandido */
            border-left: 2px solid #1976D2; /* Borda na lateral para separar da sidebar */
            box-shadow: -5px -5px 15px rgba(0,0,0,0.2); /* Sombra ajustada */
        }
        
        /* Botão de fechar removido - usando apenas os botões das abas para controlar expandir/minimizar */
        
        /* Ajuste para que o mapa ocupe todo o espaço disponível */
        .map-container {
            position: fixed !important; /* Posicionamento fixo para cobrir toda a área */
            top: 0 !important;
            right: 0 !important;
            bottom: 60px !important; /* Altura das abas minimizadas */
            left: 380px !important; /* Começa onde termina a sidebar */
            width: calc(100% - 380px) !important; /* Largura ajustada para alinhar com a sidebar */
            height: calc(100vh - 60px) !important; /* Altura total menos as abas minimizadas */
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
            z-index: 5; /* Garantir que fique acima do corpo da página, mas abaixo da sidebar e abas */
        }
        
        /* Garantir que o mapa ocupe 100% do container */
        #map {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Classe especial para forçar tamanho completo */
        .full-size-map {
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            max-height: none !important;
            display: block !important;
            position: absolute !important;
        }
        
        /* Estilo para garantir que a estrutura HTML permita que o mapa ocupe 100% */
        html, body {
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }
        
        /* Estilo para contêiner principal */
        .container-fluid {
            height: 100vh !important;
            width: 100% !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }
        
        /* Botão de expandir/minimizar removido - funcionalidade incorporada nos botões das abas */
        
        .bottom-tabs-nav {
            display: flex;
            justify-content: space-around; /* Espaçamento melhor distribuído */
            gap: 8px; /* Aumentado o espaço entre os botões */
            padding: 12px 0 6px; /* Aumentado padding vertical */
            background: linear-gradient(to bottom, #fff8e1, #ffffff);
            border-bottom: 1px solid #ffe082;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        
        .bottom-tab-btn {
            padding: 10px 20px; /* Aumentado o padding */
            background-color: #f8f9fa;
            border: 1px solid #ffe082;
            border-radius: 20px; /* Aumentado o arredondamento */
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            color: #495057;
            position: relative;
            overflow: hidden;
            font-size: 0.9rem; /* Texto um pouco maior */
            white-space: nowrap; /* Evita quebra de linha */
            min-width: 120px; /* Tamanho mínimo para botões maiores */
            text-align: center; /* Centralizar o texto */
        }
        
        .bottom-tab-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #ffc107;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .bottom-tab-btn:hover {
            background-color: #fff8e1;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.2);
        }
        
        .bottom-tab-btn:hover::before {
            opacity: 0.8;
            transform: scale(1.1);
        }
        
        .bottom-tab-btn.active {
            background-color: #ffc107;
            color: #000000;
            border-color: #ffab00;
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(255, 171, 0, 0.3);
            position: relative;
            overflow: hidden;
            font-weight: 600;
        }
        
        /* Adicionar indicador sob a aba ativa */
        .bottom-tab-btn.active::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: #ffeb3b;
            transform: scaleX(1);
            animation: pulseWidth 2s infinite;
        }
        
        @keyframes pulseWidth {
            0%, 100% { transform: scaleX(0.95); }
            50% { transform: scaleX(1.05); }
        }
        
        /* Adicione um ícone adequado a cada tab inferior */
        .bottom-tab-btn[data-tab="bottom-events"]::before {
            content: "🎉";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-restrictions"]::before {
            content: "🚫";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-report"]::before {
            content: "📊";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-content {
            display: none; /* Todas as abas começam ocultas */
            padding: 20px;
            background-color: white;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
            transform: translateY(20px);
            overflow-y: auto; /* Permite rolagem vertical para todos os conteúdos */
            width: 100%; /* Usa toda a largura disponível */
        }
        
        /* Mostra apenas o conteúdo ativo */
        .bottom-tab-content.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Ajustes para quando as abas estão minimizadas */
        .bottom-tabs-container.minimized .bottom-tab-content {
            height: 300px; /* Altura fixa quando minimizado */
        }
        
        /* Ajustes para quando as abas estão expandidas até o topo */
        .bottom-tabs-container:not(.minimized) .bottom-tab-content {
            height: calc(100vh - 140px); /* Quase altura total da tela quando expandido */
            padding: 25px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
            border-radius: 0 0 8px 8px;
            border: 1px solid #e0e0e0;
            margin: 0 15px 15px;
            flex: 1; /* Cresce para preencher o espaço disponível */
        }
        
        /* Para garantir que os containers internos preencham o espaço disponível */
        .bottom-tabs-container:not(.minimized) .events-container,
        .bottom-tabs-container:not(.minimized) .restrictions-container {
            flex: 1;
            height: 100%; /* Usa toda a altura disponível */
            min-height: 300px;
        }
        
        /* Ajustes específicos para a aba de restrições */
        #bottom-restrictions-content {
            overflow-y: auto;
        }
        
        .bottom-tab-content.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOutDown {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Ajustes para o layout responsivo */
        @media (max-width: 768px) {
            .bottom-tabs-nav {
                flex-wrap: wrap;
            }
            
            .bottom-tab-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="main-content-area">
            <!-- Sidebar para controles e informações -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2 class="m-0 app-title">
                    <span class="app-title-text">Otimizador de Rotas</span>
                    <span class="app-title-highlight">Móveis Bonafé</span>
                </h2>
                <button type="button" class="btn-close sidebar-close" aria-label="Close"></button>
            </div>
            <div class="sidebar-content">
            
            <!-- A aba de Locais fica no sidebar -->
            <div id="locations-content">
                    <!-- O conteúdo de locais fica no sidebar -->
                
                    <!-- Filtro de eventos por data (movido para cima da origem) -->
                    <div class="form-group mb-4">
                        <label class="date-range-label">Filtrar eventos por data:</label>
                        <div class="date-range-container">
                            <input type="date" id="start-date">
                            <input type="date" id="end-date">
                        </div>
                    </div>
                    
                    <!-- Origem fixa -->
                    <div class="form-group mb-4">
                        <label class="date-range-label">Origem:</label>
                        <input type="text" id="origin" class="form-control" value="Dois Córregos, SP" readonly 
                               style="background-color: #fff8e1; border: 1px solid #ffe082; border-radius: 8px; padding: 10px 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.03);">
                    </div>
                    
                    <!-- Campo de busca para adicionar novo local -->
                    <div class="form-group mb-4">
                        <label class="date-range-label">Adicionar local:</label>
                        <div class="input-animation-container position-relative">
                            <div class="position-relative">
                                <input type="text" id="location-search" placeholder="Digite um endereço"
                                       style="border: 1px solid #ffe082; border-radius: 8px; padding: 10px 12px; width: 100%; 
                                       box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: all 0.3s ease; padding-right: 35px;">
                                <span style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); 
                                       color: #444; opacity: 0.7;">
                                    <i class="bi bi-search"></i>
                                </span>
                            </div>
                            <div class="input-animation-effect"></div>
                        </div>
                    </div>
                    
                    <!-- Seleção de veículo removida, agora usa caminhão padrão automaticamente -->
                    
                    <!-- Upload de arquivo melhorado e compacto -->
                    <div class="file-upload" id="upload-area">
                        <i class="file-upload-icon fas fa-cloud-upload-alt" aria-hidden="true"></i>
                        <p style="margin: 0">Importar CEPs via arquivo</p>
                        <div class="file-format-example">CEP,Nome</div>
                        <span class="file-upload-text">Arraste arquivo ou clique aqui</span>
                        <input type="file" id="file-upload" accept=".txt,.csv">
                    </div>
                    
                    <!-- Lista de locais adicionados -->
                    <h5 class="mt-4">Locais adicionados:</h5>
                    <div class="location-list" id="locations-list">
                        <!-- Locais serão adicionados aqui dinamicamente -->
                    </div>
                    
                    <!-- Botões para gerenciar rota -->
                    <div class="optimize-btn-container">
                        <button id="optimize-route" class="btn mb-2" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00; width: 100%;">
                            Otimizar Rota
                        </button>
                        <button id="custom-route" class="btn" style="background-color: #f8f9fa; color: #000000; font-weight: 600; border-color: #ced4da; width: 100%;">
                            Rota Personalizada
                        </button>
                    </div>
                    
                    <!-- Seleção de Rota Alternativa na sidebar (redesenhada) -->
                    <div id="route-alternatives-sidebar" class="alternative-routes-section" style="display: none;">
                        <h5>Rotas Alternativas</h5>
                        <p class="text-muted small mb-3">Escolha a melhor opção para seu trajeto:</p>
                        
                        <div id="route-options-container">
                            <!-- Cards gerados dinamicamente -->
                            <div class="route-option-card selected" data-route="0" id="route-card-0">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Rota Otimizada</strong>
                                    <span class="badge bg-primary">Recomendada</span>
                                </div>
                                <div class="text-muted small" id="route-0-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Distância total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                            
                            <div class="route-option-card" data-route="1" id="route-card-1" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Alternativa 1</strong>
                                </div>
                                <div class="text-muted small" id="route-1-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Distância total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                            
                            <div class="route-option-card" data-route="2" id="route-card-2" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Alternativa 2</strong>
                                </div>
                                <div class="text-muted small" id="route-2-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Distância total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                        </div>
                        
                        <small class="text-muted d-block mt-3" style="font-size: 0.75rem;">
                            Cada rota usa um algoritmo diferente com trade-offs entre distância e tempo.
                        </small>
                        
                        <!-- Seletor escondido para compatibilidade com código existente -->
                        <select id="alternative-routes-sidebar" class="d-none">
                            <option value="0">Rota Otimizada (Padrão)</option>
                            <!-- Opções de rotas alternativas serão adicionadas dinamicamente -->
                        </select>
                    </div>
                </div>
                
                <!-- Conteúdo do sidebar apenas com a seção de Locais -->
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div class="map-container">
            <div id="map"></div>
            <div id="loading-spinner">Calculando rota...</div>
            
            <!-- Controles do mapa -->
            <div class="map-controls">
                <button class="map-control-btn" id="zoom-to-fit" title="Ajustar zoom para ver todos os pontos">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z"/>
                    </svg>
                </button>
                <button class="map-control-btn" id="toggle-poi" title="Mostrar/ocultar pontos de interesse">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                    </svg>
                </button>
            </div>
        </div>
        </div>
        
        <!-- NOVO: Tabs fixas na parte inferior do layout (inicialmente minimizadas) -->
        <div class="bottom-tabs-container minimized">
            <!-- Sem botão adicional - os próprios botões das abas controlam expandir/minimizar -->
            <!-- Navegação das abas inferiores -->
            <div class="bottom-tabs-nav">
                <button class="bottom-tab-btn" data-tab="bottom-events">Eventos na Rota</button>
                <button class="bottom-tab-btn" data-tab="bottom-restrictions">Restrições de Tráfego</button>
                <button class="bottom-tab-btn" data-tab="bottom-report">Relatório da Rota</button>
            </div>
            
            <!-- Conteúdo da aba Eventos -->
            <div class="bottom-tab-content" id="bottom-events-content">
                <h5 style="color: #000000;">Eventos nas cidades da rota:</h5>
                <!-- Container que se adapta à janela -->
                <div class="events-container" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex-grow: 1; color: #000000;">
                    <div class="events-list" id="events-list" style="height: 100%; color: #000000;">
                        <p class="text-muted" style="color: #666666;">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                    </div>
                </div>
            </div>
            
            <!-- Conteúdo da aba Restrições -->
            <div class="bottom-tab-content" id="bottom-restrictions-content">
                <h5>Restrições para caminhões do percurso:</h5>
                <p class="small text-muted mb-3">Filtrando para: caminhão de 1 eixo, 2 eixos, truck, comercial e toco</p>
                <!-- Container que se adapta à janela -->
                <div class="restrictions-container" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex-grow: 1;">
                    <div class="restrictions-list" id="restrictions-list" style="height: 100%;">
                        <p class="text-muted">Nenhuma restrição encontrada. Adicione locais e otimize a rota para ver restrições nas cidades do percurso.</p>
                    </div>
                </div>
            </div>
            
            <!-- Conteúdo da aba Relatório -->
            <div class="bottom-tab-content" id="bottom-report-content">
                <div id="route-summary" class="mb-4" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex: 1; background-color: #fff8e1; border-radius: 8px; border: 1px solid #ffe082; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.03);">
                    <p class="text-muted">Otimize uma rota para ver o relatório detalhado.</p>
                </div>
                
                <!-- Seção de Rotas Alternativas removida - movida para a sidebar -->
                
                <div class="form-group">
                    <label class="date-range-label">Nome da rota:</label>
                    <div class="input-animation-container position-relative">
                        <input type="text" id="report-route-name" placeholder="Ex: Entrega Região Sul" 
                               style="border: 1px solid #ffe082; border-radius: 8px; padding: 10px 12px; 
                               width: 100%; max-width: 400px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
                               transition: all 0.3s ease;">
                        <div class="input-animation-effect"></div>
                    </div>
                </div>
                
                <div class="mt-3">
                    <button id="save-route" class="btn" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00;" disabled>Salvar Rota</button>
                    <button id="print-route" class="btn ms-2" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00;" disabled>Imprimir</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts externos -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="cep-database.js"></script>
    <script src="geocode-fix.js"></script>
    <script src="remove-duplicates.js"></script>
    <script src="solucao-final.js"></script>
    
    <!-- Script para remover botões duplicados -->
    <script>
    console.log("Inicializando limpeza de botões duplicados...");
    
    // Função para remover botões duplicados
    function limparBotoesDuplicados() {
        // Array de IDs de botões para manter apenas um
        const botoesParaLimpar = [
            {
                // Diferentes IDs/classes para o mesmo botão "Ativar Reordenação"
                seletores: [
                    '#custom-route', 
                    '#botao-reordenar-github', 
                    'button:contains("Ativar Reordenação")',
                    'button:contains("Rota Personalizada")',
                    '.ativar-reordenacao'
                ],
                // Manter apenas o com ID 'botao-reordenar-direto'
                manter: '#botao-reordenar-direto'
            }
        ];
        
        // Extensão do seletor :contains para jQuery
        jQuery.expr[':'].contains = function(a, i, m) {
            return jQuery(a).text().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;
        };
        
        // Processar cada grupo de botões
        botoesParaLimpar.forEach(grupo => {
            const botaoManter = document.querySelector(grupo.manter);
            
            // Se o botão que queremos manter existe
            if (botaoManter) {
                // Iterar sobre os seletores e remover exceto o que queremos manter
                grupo.seletores.forEach(seletor => {
                    try {
                        const botoes = document.querySelectorAll(seletor);
                        botoes.forEach(botao => {
                            // Não remover o botão que queremos manter
                            if (botao.id !== botaoManter.id) {
                                console.log("Removendo botão duplicado:", botao.textContent?.trim());
                                botao.remove();
                            }
                        });
                    } catch (e) {
                        // Seletores :contains podem falhar em navegadores antigos
                        console.log("Erro ao processar seletor:", seletor, e);
                    }
                });
            } else {
                console.log("Botão principal não encontrado:", grupo.manter);
            }
        });
    }
    
    // Executar limpeza várias vezes para garantir
    setTimeout(limparBotoesDuplicados, 1000);
    setTimeout(limparBotoesDuplicados, 2000);
    setTimeout(limparBotoesDuplicados, 3000);
    setTimeout(limparBotoesDuplicados, 5000);
    
    // Aplicar limpeza quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', limparBotoesDuplicados);
    </script>
    
    <script>
    // Dados de amostra para a aplicação standalone
    const mockData = {
        // Origem (Dois Córregos)
        origin: {
            id: 1,
            name: "Dois Córregos",
            address: "Dois Córregos, SP, Brasil",
            zipCode: "17300-000",
            latitude: -22.3673,
            longitude: -48.3822,
            isOrigin: true
        },
        
        // Tipos de veículos
        vehicleTypes: [
            { id: 1, name: "Caminhão 1 eixo", type: "truck1", costPerKm: 3.5, fuelConsumption: 4.5, averageSpeed: 75 },
            { id: 2, name: "Caminhão 2 eixos", type: "truck2", costPerKm: 4.2, fuelConsumption: 5.2, averageSpeed: 70 },
            { id: 3, name: "Caminhão truck", type: "truck3", costPerKm: 5.0, fuelConsumption: 6.0, averageSpeed: 65 },
            { id: 4, name: "Caminhão comercial", type: "truck4", costPerKm: 4.0, fuelConsumption: 5.0, averageSpeed: 80 },
            { id: 5, name: "Caminhão toco", type: "truck5", costPerKm: 6.5, fuelConsumption: 8.0, averageSpeed: 55 }
        ],
        
        // Pontos de interesse
        pointsOfInterest: [
            { id: 1, name: "Pedágio SP-225 (Brotas)", type: "toll", latitude: -22.2544, longitude: -48.1247, highway: "SP-225", cityName: "Brotas", cost: 11.30 },
            { id: 2, name: "Pedágio SP-225 (Jaú)", type: "toll", latitude: -22.2877, longitude: -48.5325, highway: "SP-225", cityName: "Jaú", cost: 7.90 },
            { id: 3, name: "Pedágio SP-300 (Botucatu)", type: "toll", latitude: -22.8932, longitude: -48.4521, highway: "SP-300", cityName: "Botucatu", cost: 9.50 },
            { id: 4, name: "Balança SP-225 (Dois Córregos)", type: "weighStation", latitude: -22.3532, longitude: -48.3301, highway: "SP-225", cityName: "Dois Córregos", isActive: true },
            { id: 5, name: "Balança SP-300 (Botucatu)", type: "weighStation", latitude: -22.9011, longitude: -48.4402, highway: "SP-300", cityName: "Botucatu", isActive: true },
            { id: 6, name: "Posto de combustível Shell (Dois Córregos)", type: "gasStation", latitude: -22.3673, longitude: -48.3900, highway: "SP-225", cityName: "Dois Córregos", services: ["food", "rest", "shower"] },
            { id: 7, name: "Posto de combustível BR (Jaú)", type: "gasStation", latitude: -22.2870, longitude: -48.5400, highway: "SP-225", cityName: "Jaú", services: ["food", "mechanic"] },
            { id: 8, name: "Borracharia 24h (Botucatu)", type: "mechanic", latitude: -22.8900, longitude: -48.4500, highway: "SP-300", cityName: "Botucatu", services: ["tire"] }
        ],
        
        // Eventos de cidades (com aniversários atualizados para 2025)
        cityEvents: [
            // Aniversários das principais cidades (eventos fixos - feriados municipais)
            { id: 99, cityName: "Dois Córregos", name: "Festival de Verão", startDate: "2025-01-01", endDate: "2025-12-31", isHoliday: false, description: "Festival com atividades durante todo o ano", restrictionLevel: "low" },
            { id: 1, cityName: "Dois Córregos", name: "Aniversário da Cidade", startDate: "2025-02-04", endDate: "2025-02-04", isHoliday: true, description: "Aniversário de fundação de Dois Córregos em 04/02/1883", restrictionLevel: "low" },
            { id: 2, cityName: "Jaú", name: "Aniversário da Cidade", startDate: "2025-08-15", endDate: "2025-08-15", isHoliday: true, description: "Aniversário de fundação de Jaú em 15/08/1853", restrictionLevel: "low" },
            { id: 3, cityName: "Botucatu", name: "Aniversário da Cidade", startDate: "2025-04-14", endDate: "2025-04-14", isHoliday: true, description: "Aniversário de fundação de Botucatu em 14/04/1855", restrictionLevel: "low" },
            { id: 4, cityName: "Bauru", name: "Aniversário da Cidade", startDate: "2025-08-01", endDate: "2025-08-01", isHoliday: true, description: "Aniversário de fundação de Bauru em 01/08/1896", restrictionLevel: "low" },
            { id: 5, cityName: "Ribeirão Preto", name: "Aniversário da Cidade", startDate: "2025-06-19", endDate: "2025-06-19", isHoliday: true, description: "Aniversário de fundação de Ribeirão Preto em 19/06/1856", restrictionLevel: "low" },
            { id: 6, cityName: "São Paulo", name: "Aniversário da Cidade", startDate: "2025-01-25", endDate: "2025-01-25", isHoliday: true, description: "Aniversário de fundação de São Paulo em 25/01/1554", restrictionLevel: "high" },
            { id: 7, cityName: "Campinas", name: "Aniversário da Cidade", startDate: "2025-07-14", endDate: "2025-07-14", isHoliday: true, description: "Aniversário de fundação de Campinas em 14/07/1774", restrictionLevel: "medium" },
            { id: 8, cityName: "São Carlos", name: "Aniversário da Cidade", startDate: "2025-11-04", endDate: "2025-11-04", isHoliday: true, description: "Aniversário de fundação de São Carlos em 04/11/1857", restrictionLevel: "low" },
            
            // Eventos regulares
            { id: 9, cityName: "Jaú", name: "Festa do Rodeio", startDate: "2025-06-10", endDate: "2025-06-20", isHoliday: false, description: "Evento com grande circulação de veículos", restrictionLevel: "medium" },
            { id: 10, cityName: "Botucatu", name: "Festival de Inverno", startDate: "2025-07-15", endDate: "2025-07-30", isHoliday: false, description: "Evento cultural e gastronômico", restrictionLevel: "low" },
            { id: 11, cityName: "Bauru", name: "Exposição Agropecuária", startDate: "2025-08-05", endDate: "2025-08-15", isHoliday: false, description: "Feira agropecuária com shows", restrictionLevel: "high" },
            { id: 12, cityName: "Ribeirão Preto", name: "Agrishow", startDate: "2025-04-25", endDate: "2025-04-29", isHoliday: false, description: "Maior feira de agronegócio da América Latina com forte impacto no tráfego local", restrictionLevel: "high" },
            { id: 13, cityName: "São Paulo", name: "Virada Cultural", startDate: "2025-05-17", endDate: "2025-05-18", isHoliday: false, description: "Festival de 24 horas com eventos culturais pela cidade", restrictionLevel: "medium" },
            { id: 14, cityName: "Ribeirão Preto", name: "Feira Tecnológica", startDate: "2025-05-15", endDate: "2025-05-18", isHoliday: false, description: "Exposição de novas tecnologias agrícolas", restrictionLevel: "medium" }
        ],
        
        // Restrições para caminhões
        truckRestrictions: [
            { id: 1, cityName: "Dois Córregos", dayType: "weekday", startTime: "07:00", endTime: "09:00", restrictionType: "partial", description: "Restrição parcial para caminhões de grande porte no centro", affectedVehicles: ["truck1", "truck5", "truck6", "truck7", "truck9"] },
            { id: 2, cityName: "Jaú", dayType: "weekday", startTime: "17:00", endTime: "20:00", restrictionType: "partial", description: "Restrição parcial para todos os caminhões no centro", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 3, cityName: "Botucatu", dayType: "weekend", startTime: "08:00", endTime: "18:00", restrictionType: "total", description: "Proibição total para caminhões na área central", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 4, cityName: "Bauru", dayType: "all", startTime: "07:00", endTime: "22:00", restrictionType: "rodizio", description: "Sistema de rodízio para todos os caminhões", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 5, cityName: "Campinas", dayType: "all", startTime: "06:00", endTime: "20:00", restrictionType: "total", description: "Zona de Máxima Restrição de Circulação (ZMRC) - proibição total para caminhões", affectedVehicles: ["truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 6, cityName: "Campinas", dayType: "weekday", startTime: "07:00", endTime: "10:00", restrictionType: "partial", description: "Restrição adicional para todos os tipos de caminhões nas vias principais", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 7, cityName: "São Paulo", dayType: "all", startTime: "04:00", endTime: "22:00", restrictionType: "total", description: "Zona de Máxima Restrição de Circulação - proibição total", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 8, cityName: "Ribeirão Preto", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição de circulação no centro expandido", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 9, cityName: "Piracicaba", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição na região central", affectedVehicles: ["truck3", "truck4", "truck5", "truck7"] },
            { id: 10, cityName: "São Carlos", dayType: "all", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição no centro comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 11, cityName: "Sorocaba", dayType: "weekday", startTime: "08:00", endTime: "17:00", restrictionType: "partial", description: "Restrição para veículos pesados na área central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 12, cityName: "Americana", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restrição na zona comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 13, cityName: "Limeira", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição no perímetro central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 14, cityName: "Rio Claro", dayType: "weekday", startTime: "07:30", endTime: "18:30", restrictionType: "partial", description: "Restrição na área central", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 15, cityName: "Araraquara", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restrição para veículos pesados no centro", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] }
        ]
    };

    // Variáveis globais
    let map;
    let directionsService;
    let directionsRenderer;
    let autocomplete;
    let markers = [];
    let currentOptimizedPath = []; // Array para armazenar os IDs do caminho otimizado atual
    let poiMarkers = [];
    let eventMarkers = [];
    let locationId = 2; // Começa em 2 porque 1 é reservado para a origem
    let locations = [mockData.origin];
    let activeInfoWindow = null;
    let routePath = null;
    let routeAnimationTimeout = null;
    let showPOIs = true;
    let customTooltip = null;
    let directionsRendererInitialized = false; // Flag para rastrear inicialização correta do renderer
    // Variáveis para rotas alternativas
    let alternativeRoutes = [];
    let currentRouteIndex = 0;
    let currentDisplayedRoute = null; // Guarda referência à rota atualmente exibida
    let allRoutePolylines = []; // Armazena referências a todas as polylines criadas
    let tspSolver = null; // Instância do solver TSP
    
    // Função para processar CEP em formato x.y.z.w-abcd
    function formatCEP(cep) {
        // Remover qualquer caracter não numérico
        let numericCEP = cep.replace(/\D/g, '');
        
        // Formatar como xxxxx-xxx
        if (numericCEP.length >= 8) {
            return numericCEP.substring(0, 5) + '-' + numericCEP.substring(5, 8);
        }
        
        return cep; // Retornar original se não for possível formatar
    }
    
    // Função global auxiliar para exibir notificações de forma segura
    function showNotification(message, type = 'info', targetSelector = '.route-controls', autoRemove = true, duration = 5000) {
        console.log(`Notificação [${type}]: ${message}`);
        
        // Criar elemento de notificação
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} mt-2`;
        notification.innerHTML = message;
        
        // Tentar diferentes locais na ordem de prioridade
        const possibleTargets = [
            targetSelector,
            '.route-controls',
            '#sidebar',
            '.sidebar-content',
            '.tab-content:first-child',
            'body'
        ];
        
        let targetElement = null;
        
        // Tentar cada seletor até encontrar um elemento válido
        for (const selector of possibleTargets) {
            try {
                const element = document.querySelector(selector);
                if (element) {
                    targetElement = element;
                    break;
                }
            } catch (err) {
                console.warn(`Erro ao buscar seletor ${selector}:`, err);
            }
        }
        
        // Anexar notificação se encontrou um elemento válido
        if (targetElement) {
            try {
                targetElement.appendChild(notification);
                
                // Auto-remover após um tempo, se solicitado
                if (autoRemove) {
                    setTimeout(() => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        } catch (err) {
                            console.warn("Erro ao remover notificação:", err);
                        }
                    }, duration);
                }
                
                return notification;
            } catch (err) {
                console.error("Erro ao adicionar notificação:", err);
            }
        } else {
            console.warn("Não foi possível exibir notificação, nenhum elemento alvo encontrado");
        }
        
        return null;
    }

    // Inicialização
    document.addEventListener("DOMContentLoaded", function() {
        console.log("DOM carregado - inicializando aplicação");
        
        // Event listener para o botão de toggle das abas removido
        // A funcionalidade de toggle agora está incorporada nos próprios botões das abas
        
        // Inicializar conteúdo das abas com a origem
        // NÃO ativar nenhuma aba automaticamente - deixar para o usuário decidir qual aba abrir
        
        // Mostrar informações iniciais nas abas
        showInitialTabsContent();
        
        // Verificar se temos acesso ao Google Maps
        if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
            console.error("Google Maps API não carregada corretamente");
            showNotification("Não foi possível carregar o Google Maps. Verifique sua conexão ou se há bloqueadores ativos no navegador.", "error");
        } else {
            console.log("Google Maps API disponível");
        }
        
        // Inicializar componentes principais
        try {
            initMap();
            initAutocomplete();
            initTabNavigation();
            initEventListeners();
            
            // Verificar se estamos no GitHub Pages para ajustes adicionais
            if (window.location.href.includes('github.io')) {
                console.log("Detectado GitHub Pages - aplicando ajustes especiais de layout");
                
                // Aplicar correções específicas para GitHub Pages após um breve atraso
                setTimeout(() => {
                    const mapContainer = document.querySelector('.map-container');
                    const mapElement = document.getElementById('map');
                    
                    if (mapContainer && mapElement) {
                        // Forçar tamanhos explicitamente
                        mapContainer.style.height = 'calc(100vh - 60px)';
                        mapElement.style.height = '100%';
                        
                        // Forçar redesenho do mapa
                        if (typeof google !== 'undefined' && google.maps && map) {
                            google.maps.event.trigger(map, 'resize');
                        }
                        
                        console.log("Ajustes de layout para GitHub Pages aplicados");
                    }
                }, 500);
            }
        } catch (initError) {
            console.error("Erro ao inicializar a aplicação:", initError);
        }
        
        // Exibir a origem no mapa
        addMarkerForLocation(mockData.origin, 0);
        
        // Definir data inicial como a data atual por padrão
        const today = new Date();
        const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
        
        // Calcular a data final (hoje + 7 dias)
        const endDate = new Date();
        endDate.setDate(today.getDate() + 7);
        const formattedEndDate = endDate.toISOString().split('T')[0];
        
        // Definir os valores dos campos de data
        document.getElementById('start-date').value = formattedToday;
        document.getElementById('end-date').value = formattedEndDate;
        
        console.log(`Datas definidas automaticamente: de ${formattedToday} até ${formattedEndDate}`);
        
        // Inicializar currentOptimizedPath com a origem para mostrar eventos/restrições iniciais
        currentOptimizedPath = [mockData.origin.id];
        
        // Chamar funções para mostrar eventos e restrições para a origem com base nas datas atuais
        filterEventsByDate();
        
        // Mostrar mensagem de ajuda
        console.log("Campos de data inicializados com datas atuais e eventos/restrições para origem configurados");
    });

    // Inicializa o mapa
    function initMap() {
        // Definir valores iniciais aos campos de data
        initDatePickers();
        
        // Invocar a filtragem de eventos inicial para exibir eventos para a origem
        filterEventsByDate();
    }
    
    // Função centralizada para inicializar os campos de data
    function initDatePickers() {
        try {
            console.log("Inicializando campos de data...");
            
            // Verificar se os campos existem
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            
            if (!startDateInput || !endDateInput) {
                console.error("Campos de data não encontrados. Tentando encontrar container...");
                
                // Tentar criar os campos se não existirem
                const dateContainer = document.querySelector('.date-filters');
                if (dateContainer) {
                    if (!startDateInput) {
                        const newStart = document.createElement('input');
                        newStart.type = 'date';
                        newStart.id = 'start-date';
                        newStart.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newStart);
                        console.log("Campo de data inicial criado");
                    }
                    
                    if (!endDateInput) {
                        const newEnd = document.createElement('input');
                        newEnd.type = 'date';
                        newEnd.id = 'end-date';
                        newEnd.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newEnd);
                        console.log("Campo de data final criado");
                    }
                } else {
                    console.error("Container de datas não encontrado!");
                    return;
                }
            }
            
            // Referenciar os elementos (originais ou recém-criados)
            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');
            
            // Verificar novamente
            if (!startDate || !endDate) {
                console.error("Impossível criar ou localizar campos de data");
                return;
            }
            
            // Inicializar com a data atual e data atual + 7 dias
            const today = new Date();
            const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
            
            // Calcular a data final (hoje + 7 dias)
            const futureDate = new Date();
            futureDate.setDate(today.getDate() + 7);
            const formattedFuture = futureDate.toISOString().split('T')[0];
            
            // Definir os valores apenas se estiverem vazios
            if (!startDate.value) {
                startDate.value = formattedToday;
                console.log("Data inicial definida:", formattedToday);
            }
            
            if (!endDate.value) {
                endDate.value = formattedFuture;
                console.log("Data final definida:", formattedFuture);
            }
            
            console.log(`Datas inicializadas: de ${startDate.value} até ${endDate.value}`);
            
            // Adicionar listeners para atualizar os eventos quando as datas mudarem
            startDate.addEventListener('change', function() {
                console.log("Data de início alterada para:", this.value);
                filterEventsByDate();
            });
            
            endDate.addEventListener('change', function() {
                console.log("Data de fim alterada para:", this.value);
                filterEventsByDate();
            });
            
            // Chamar o filtro de eventos inicialmente para aplicar as datas padrão
            setTimeout(filterEventsByDate, 500);
        } catch (error) {
            console.error("Erro ao inicializar seletores de data:", error);
        }
        
        // Ajustar a altura do container e do mapa para preencher todo o espaço disponível
        function resizeMap() {
            const mapContainer = document.querySelector('.map-container');
            const mapElement = document.getElementById('map');
            
            if (mapContainer && mapElement) {
                const windowHeight = window.innerHeight;
                console.log('Redimensionando mapa para altura da janela:', windowHeight);
                
                // Ajustar posição e tamanho do container
                mapContainer.style.position = 'fixed';
                mapContainer.style.top = '0';
                mapContainer.style.right = '0';
                mapContainer.style.bottom = '60px'; // Altura das abas minimizadas
                mapContainer.style.left = '380px'; // Começa onde termina a sidebar
                mapContainer.style.width = 'calc(100% - 380px)';
                mapContainer.style.height = 'calc(100vh - 60px)'; // Toda a altura menos as abas
                
                // Forçar tamanho do elemento do mapa para ocupar todo o container
                mapElement.style.position = 'absolute';
                mapElement.style.top = '0';
                mapElement.style.left = '0';
                mapElement.style.right = '0';
                mapElement.style.bottom = '0';
                mapElement.style.width = '100%';
                mapElement.style.height = '100%';
                
                // Adicionar classe para forçar tamanho completo
                mapElement.classList.add('full-size-map');
                
                // Forçar renderização do mapa
                if (typeof google !== 'undefined' && google.maps && map) {
                    google.maps.event.trigger(map, 'resize');
                }
            }
        }
        
        // Opções do mapa
        const mapOptions = {
            center: { lat: -22.3673, lng: -48.3822 }, // Dois Córregos
            zoom: 8,
            mapTypeControl: true,
            fullscreenControl: true,
            streetViewControl: true,
            zoomControl: true,
            gestureHandling: 'greedy' // Permite zoom com scroll sem precionar Ctrl
        };
        
        // Criar o mapa
        map = new google.maps.Map(document.getElementById("map"), mapOptions);
        
        // Redimensionar o mapa agora e quando a janela for redimensionada
        resizeMap();
        window.addEventListener('resize', resizeMap);
        
        // Inicializar o serviço de direções
        directionsService = new google.maps.DirectionsService();
        
        try {
            console.log("Inicializando DirectionsRenderer...");
            directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true, // Não mostrar marcadores padrão do Google
                preserveViewport: true,
                polylineOptions: {
                    strokeColor: '#1976D2',
                    strokeOpacity: 0.7,
                    strokeWeight: 4
                }
            });
            directionsRenderer.setMap(map);
            directionsRendererInitialized = true;
            console.log("DirectionsRenderer inicializado com sucesso");
        } catch (err) {
            console.error("Erro ao inicializar DirectionsRenderer:", err);
            showNotification("Erro ao inicializar o sistema de rotas. Recarregue a página.", "danger");
        }
        
        // Criar o tooltip personalizado
        createCustomTooltip();
    }

    // Inicializa o autocomplete
    function initAutocomplete() {
        const input = document.getElementById('location-search');
        const options = {
            types: ['geocode'],
            componentRestrictions: { country: 'br' }
        };
        
        autocomplete = new google.maps.places.Autocomplete(input, options);
        
        // Quando um local é selecionado no autocomplete
        autocomplete.addListener('place_changed', function() {
            const place = autocomplete.getPlace();
            
            if (!place.geometry) {
                // Substituir alert por notificação inline mais suave
                const notifyWarning = document.createElement('div');
                notifyWarning.className = 'alert alert-warning mt-2';
                notifyWarning.innerHTML = `Não foi possível encontrar o endereço selecionado.`;
                const locationForm = document.querySelector('#location-form');
                if (locationForm) {
                    locationForm.appendChild(notifyWarning);
                } else {
                    console.warn('Elemento #location-form não encontrado para anexar notificação');
                }
                
                // Remover a notificação após alguns segundos
                setTimeout(() => {
                    if (notifyWarning && notifyWarning.parentNode) {
                        notifyWarning.parentNode.removeChild(notifyWarning);
                    }
                }, 5000);
                return;
            }
            
            // Adicionar o local à lista
            const newLocation = {
                id: locationId++,
                name: formatLocationName(place.name),
                address: formatLocationName(place.formatted_address),
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            locations.push(newLocation);
            
            // Adicionar marcador e atualizar a lista
            addMarkerForLocation(newLocation, locations.length - 1);
            updateLocationsList();
            
            // Limpar o campo de busca
            input.value = '';
        });
    }

    // Inicializa a navegação por abas (novas abas inferiores)
    function initTabNavigation() {
        // Inicializar abas inferiores (abaixo do mapa)
        const bottomTabButtons = document.querySelectorAll('.bottom-tab-btn');
        const bottomTabContents = document.querySelectorAll('.bottom-tab-content');
        
        // Verificar se estamos no GitHub Pages (para aplicar animações avançadas)
        const isGitHubPages = window.location.href.includes('github.io');
        
        if (bottomTabButtons.length > 0) {
            console.log("Inicializando sistema de navegação para tabs inferiores");
            
            bottomTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    console.log("Tab inferior clicada:", tabId);
                    
                    // Verificar se já é o botão ativo e se o painel está expandido
                    const isCurrentlyActive = button.classList.contains('active');
                    const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
                    const isExpanded = bottomTabsContainer && !bottomTabsContainer.classList.contains('minimized');
                    
                    // Se clicar no mesmo botão que já está ativo e o painel estiver expandido, minimiza
                    if (isCurrentlyActive && isExpanded) {
                        toggleTabsExpansion(); // Minimizar o painel
                        return; // Não muda o conteúdo, apenas minimiza
                    }
                    
                    // Se o painel estiver minimizado, expande ao clicar em qualquer botão
                    if (bottomTabsContainer && bottomTabsContainer.classList.contains('minimized')) {
                        toggleTabsExpansion(); // Expandir o painel
                    }
                    
                    // Desativar todas as abas inferiores
                    bottomTabButtons.forEach(btn => btn.classList.remove('active'));
                    bottomTabContents.forEach(content => content.classList.remove('active'));
                    
                    // Ativar a aba inferior clicada
                    button.classList.add('active');
                    
                    // Mapear o data-tab para o ID do conteúdo correto
                    const contentMap = {
                        'bottom-events': 'bottom-events-content',
                        'bottom-restrictions': 'bottom-restrictions-content',
                        'bottom-report': 'bottom-report-content'
                    };
                    
                    const contentId = contentMap[tabId];
                    if (contentId) {
                        const contentElement = document.getElementById(contentId);
                        if (contentElement) {
                            // Ocultar TODOS os conteúdos primeiro
                            bottomTabContents.forEach(content => {
                                content.style.display = 'none';
                                content.classList.remove('active');
                            });
                            
                            // Ativar apenas o conteúdo da aba clicada
                            contentElement.classList.add('active');
                            contentElement.style.display = 'flex';
                            
                            // Efeitos visuais adicionais para GitHub Pages
                            if (isGitHubPages) {
                                // Reset da animação
                                contentElement.style.animation = 'none';
                                setTimeout(() => {
                                    contentElement.style.animation = 'fadeInUp 0.5s ease forwards';
                                }, 10);
                                
                                // Não fazer scroll automático - removido para evitar expansão automática
                            }
                        } else {
                            console.warn(`Elemento de conteúdo #${contentId} não encontrado`);
                        }
                    }
                });
            });
        } else {
            console.warn("Botões de tab inferiores não encontrados. Abas não inicializadas.");
        }
    }

    // Função para gerenciar a visibilidade das abas inferiores
    function toggleBottomTabsVisibility(show = true) {
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        if (bottomTabsContainer) {
            if (show) {
                // Garante que o container está visível 
                bottomTabsContainer.style.removeProperty('display');
                bottomTabsContainer.style.display = 'flex';
                
                // Remover a classe minimizada para mostrar o conteúdo completo
                bottomTabsContainer.classList.remove('minimized');
                
                // Atualizar o texto do botão de toggle
                const toggleIcon = document.getElementById('toggle-icon');
                if (toggleIcon) {
                    toggleIcon.textContent = '▼ Minimizar';
                }
                
                console.log("Abas inferiores expandidas com sucesso");
                
                // Mostrar informações iniciais relevantes (origem)
                showInitialTabsContent();
            } else {
                // Apenas minimiza, sem ocultar completamente
                bottomTabsContainer.classList.add('minimized');
                
                // Atualizar o texto do botão de toggle
                const toggleIcon = document.getElementById('toggle-icon');
                if (toggleIcon) {
                    toggleIcon.textContent = '▲ Expandir';
                }
                
                console.log("Abas inferiores minimizadas com sucesso");
            }
        } else {
            console.warn("Container de abas inferiores não encontrado!");
        }
    }
    
    // Função para mostrar conteúdo inicial relevante nas abas
    function showInitialTabsContent() {
        // Mostrar eventos da cidade de origem (Dois Córregos)
        const routeIds = [mockData.origin.id];
        showEventsForCitiesOnRoute(routeIds);
        
        // Mostrar restrições para a cidade de origem
        showTruckRestrictionsForCitiesOnRoute(routeIds, null);
        
        // Mostrar mensagem no relatório
        const reportContent = document.getElementById('bottom-report-content');
        if (reportContent) {
            const routeSummary = document.getElementById('route-summary');
            if (routeSummary) {
                routeSummary.innerHTML = `
                    <p>Adicione destinos e otimize uma rota para ver o relatório detalhado.</p>
                    <p>Origem atual: <strong>Dois Córregos-SP</strong></p>
                `;
            }
        }
    }
    
    // Função para expandir/colapsar as abas inferiores
    function toggleTabsExpansion() {
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        const toggleIcon = document.getElementById('toggle-icon');
        const mapContainer = document.querySelector('.map-container');
        
        if (bottomTabsContainer) {
            if (bottomTabsContainer.classList.contains('minimized')) {
                // Expandir
                bottomTabsContainer.classList.remove('minimized');
                if (toggleIcon) toggleIcon.textContent = '▼ Minimizar';
                
                // Ajustar altura do mapa quando as abas estão expandidas
                if (mapContainer) {
                    // Ajustar a altura do container do mapa para considerar o tamanho expandido das abas
                    const tabsHeight = bottomTabsContainer.offsetHeight;
                    mapContainer.style.bottom = tabsHeight + 'px';
                    
                    // Forçar redesenho do mapa
                    if (typeof google !== 'undefined' && google.maps && map) {
                        setTimeout(() => {
                            google.maps.event.trigger(map, 'resize');
                            console.log("Mapa redimensionado após expandir abas, altura das abas:", tabsHeight);
                        }, 100);
                    }
                }
            } else {
                // Minimizar
                bottomTabsContainer.classList.add('minimized');
                if (toggleIcon) toggleIcon.textContent = '▲ Expandir';
                
                // Restaurar altura original do mapa quando as abas estão minimizadas
                if (mapContainer) {
                    mapContainer.style.bottom = '60px'; // Altura das abas minimizadas
                    
                    // Forçar redesenho do mapa
                    if (typeof google !== 'undefined' && google.maps && map) {
                        setTimeout(() => {
                            google.maps.event.trigger(map, 'resize');
                            console.log("Mapa redimensionado após minimizar abas");
                        }, 100);
                    }
                }
            }
        }
    }
    
    // Configura todos os event listeners
    function initEventListeners() {
        // Toggle para mostrar/esconder a sidebar removido
        
        // Botão para fechar a sidebar em telas pequenas
        document.querySelector('.sidebar-close').addEventListener('click', function() {
            document.getElementById('sidebar').classList.add('sidebar-hidden');
        });
        
        // Upload de arquivo com suporte para drag and drop
        const fileUploadInput = document.getElementById('file-upload');
        const uploadArea = document.getElementById('upload-area');
        
        // Evento para quando o arquivo é selecionado pelo input
        fileUploadInput.addEventListener('change', handleFileUpload);
        
        // Eventos de drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Adicionar classe visual quando o arquivo está sendo arrastado sobre a área
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('dragover');
            }, false);
        });
        
        // Remover classe visual quando o arquivo sai da área ou é solto
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('dragover');
            }, false);
        });
        
        // Processar o arquivo quando for solto na área
        uploadArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length) {
                fileUploadInput.files = files;
                handleFileUpload({target: fileUploadInput});
            }
        }, false);
        
        // Botão para otimizar rota
        const optimizeButton = document.getElementById('optimize-route');
        const customRouteButton = document.getElementById('custom-route');
        const locationsList = document.getElementById('locations-list');
        
        if (optimizeButton) {
            optimizeButton.addEventListener('click', optimizeRoute);
        } else {
            console.error("Botão de otimização de rota não encontrado!");
        }
        
        // Adicionar funcionalidade ao botão de rota personalizada
        if (customRouteButton && locationsList) {
            customRouteButton.addEventListener('click', toggleCustomRouteMode);
        } else {
            console.error("Elementos para rota personalizada não encontrados!");
        }
        
        // Filtrar eventos automaticamente ao mudar as datas
        document.getElementById('start-date').addEventListener('change', filterEventsByDate);
        document.getElementById('end-date').addEventListener('change', filterEventsByDate);
        
        // Botões de controle do mapa
        document.getElementById('zoom-to-fit').addEventListener('click', zoomToFitAllMarkers);
        document.getElementById('toggle-poi').addEventListener('click', togglePointsOfInterest);
        
        // Botões da aba de relatório
        document.getElementById('save-route').addEventListener('click', saveRoute);
        document.getElementById('print-route').addEventListener('click', printRoute);
        
        // Inicializar os cards de rotas alternativas
        function initRouteOptionCards() {
            // Evento para clique nos cards de rota alternativa
            const routeCards = document.querySelectorAll('.route-option-card');
            routeCards.forEach(card => {
                card.addEventListener('click', function() {
                    const routeIndex = parseInt(this.getAttribute('data-route'));
                    
                    // Atualizar seleção visual
                    document.querySelectorAll('.route-option-card').forEach(c => {
                        c.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    
                    // Atualizar o select escondido (para compatibilidade)
                    const selectElement = document.getElementById('alternative-routes-sidebar');
                    selectElement.value = routeIndex;
                    
                    // Disparar evento de mudança para acionar o manipulador existente
                    const event = new Event('change');
                    selectElement.dispatchEvent(event);
                });
            });
        }
        
        // Chamar inicialização após carregar o DOM
        initRouteOptionCards();
        
        // Esta função foi movida para a seção global para resolver o erro de referência
        
        // Seletor de rotas alternativas na sidebar (mantido para compatibilidade)
        document.getElementById('alternative-routes-sidebar').addEventListener('change', function(e) {
            const selectedIndex = parseInt(e.target.value);
            if (alternativeRoutes && alternativeRoutes.length > selectedIndex) {
                const selectedRoute = alternativeRoutes[selectedIndex];
                
                console.log("Selecionando rota alternativa:", selectedIndex);
                console.log("Caminho da rota selecionada:", selectedRoute.path);
                
                // Informar sobre a troca de rota
                console.log("Alternando para rota: " + selectedIndex + ", reconstruindo elementos...");
                showNotification("Alternando para rota " + (selectedIndex + 1) + "...", "info");
                
                // Salvar o caminho selecionado para uso após a limpeza
                const pathToUse = selectedRoute.path;
                
                // Parar qualquer animação em andamento
                if (routeAnimationTimeout) {
                    clearTimeout(routeAnimationTimeout);
                    routeAnimationTimeout = null;
                }
                
                // Limpar TUDO - todas as rotas, marcadores, eventos, e estado
                clearRoute();
                clearAllPolylines();
                clearPOIMarkers();
                clearEventMarkers();
                
                // Resetar o mapa para forçar atualização
                if (map) {
                    try {
                        const mapCenter = map.getCenter();
                        map.setCenter(mapCenter);
                    } catch (e) {
                        console.error("Erro ao recentrar mapa:", e);
                    }
                }
                
                // Delay maior para garantir limpeza completa antes de reconstruir
                setTimeout(() => {
                    console.log("Reconstruindo a rota...");
                    
                    // Resetar DirectionsRenderer para garantir um estado limpo
                    if (directionsRenderer) {
                        try {
                            directionsRenderer.setMap(null);
                            directionsRenderer = new google.maps.DirectionsRenderer({
                                suppressMarkers: true,
                                preserveViewport: true,
                                polylineOptions: {
                                    strokeColor: '#1976D2',
                                    strokeOpacity: 0.7,
                                    strokeWeight: 4
                                }
                            });
                            directionsRenderer.setMap(map);
                            directionsRenderer.setDirections({routes: []});
                        } catch (e) {
                            console.error("Erro ao resetar directionsRenderer:", e);
                        }
                    }
                    
                    // Reordenar marcadores
                    reorderMarkers(pathToUse);
                    
                    // Desenhar nova rota com delay adicional para garantir que o mapa está pronto
                    setTimeout(() => {
                        console.log("Desenhando nova rota: ", selectedIndex);
                        
                        // Atualizar índice atual de rota
                        currentRouteIndex = selectedIndex;
                        currentDisplayedRoute = pathToUse;
                        
                        // Desenhar nova rota
                        drawRouteOnMap(pathToUse, "truck1");
                        
                        // Mostrar pontos de interesse e eventos somente após desenhar a rota
                        setTimeout(() => {
                            showPointsOfInterestOnRoute(pathToUse);
                            showEventsForCitiesOnRoute(pathToUse);
                        }, 200);
                    }, 200);
                }, 400);
                
                // Atualizar restrições
                showTruckRestrictionsForCitiesOnRoute(selectedRoute.path, null); // null para mostrar todos os tipos
                
                // Atualizar rota atual
                currentRouteIndex = selectedIndex;
            }
        });
    }

    // Função para tratar o upload de arquivo
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            parseCEPFile(content);
        };
        reader.readAsText(file);
    }

    // Formatar texto para iniciar com maiúscula e resto minúscula
    function formatLocationName(name) {
        // Se o nome for vazio, retornar
        if (!name) return name;
        
        // Dividir o nome em palavras
        return name.split(' ').map(word => {
            if (!word) return '';
            // Primeira letra maiúscula, resto minúscula
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }).join(' ');
    }
    
    // Função para processar o arquivo de CEPs
    function parseCEPFile(content) {
        // Verificar se content é válido
        if (!content || typeof content !== 'string') {
            console.error('Conteúdo do arquivo inválido:', content);
            return;
        }
        
        const lines = content.split('\n');
        let newLocations = [];
        
        // CEPs com coordenadas conhecidas para as principais cidades paulistas
        const knownCEPs = {
            '14020-260': {name: 'Ribeirão Preto', lat: -21.1767, lng: -47.8208},
            '17560-000': {name: 'Vera Cruz', lat: -22.2205, lng: -49.8233},
            '17580-000': {name: 'Pompéia', lat: -22.1075, lng: -50.1764},
            '17280-000': {name: 'Pederneiras', lat: -22.3518, lng: -48.7780},
            '17220-000': {name: 'Itapuí', lat: -22.2323, lng: -48.7186},
            '17340-000': {name: 'Barra Bonita', lat: -22.4910, lng: -48.5582},
            '17380-000': {name: 'Brotas', lat: -22.2794, lng: -48.1251},
            '17200-000': {name: 'Jaú', lat: -22.2936, lng: -48.5592},
            '18600-000': {name: 'Botucatu', lat: -22.8837, lng: -48.4437},
            '17120-000': {name: 'Agudos', lat: -22.4696, lng: -48.9870},
            '17210-000': {name: 'Igaraçu do Tietê', lat: -22.5092, lng: -48.5597},
            '17040-001': {name: 'Bauru', lat: -22.3246, lng: -49.0871},
            '17400-000': {name: 'Garça', lat: -22.2132, lng: -49.6546},
            '17480-000': {name: 'Marília', lat: -22.2171, lng: -49.9501},
            '17300-000': {name: 'Dois Córregos', lat: -22.3673, lng: -48.3822},
            '18430-035': {name: 'Ribeirão Branco', lat: -24.2231, lng: -48.7635} // Coordenadas corretas para Ribeirão Branco-SP
        };
        
        // Geocodificador para CEPs desconhecidos
        const geocoder = new google.maps.Geocoder();
        let geocodeQueue = [];
        
        for (const line of lines) {
            if (!line.trim()) continue;
            
            const parts = line.split(',');
            if (parts.length < 2) continue;
            
            const cep = parts[0].trim();
            let name = parts[1].trim();
            
            // Formatar nome (primeira letra maiúscula, resto minúscula)
            name = formatLocationName(name);
            
            if (cep && name) {
                // Formatar CEP para garantir consistência no formato xxxxx-xxx
                const formattedCEP = formatCEP(cep);
                
                // Verificar se é um CEP conhecido (tentando com o formato fornecido ou com formato padronizado)
                if (knownCEPs[cep] || knownCEPs[formattedCEP]) {
                    // Usar o CEP que for encontrado no banco de dados
                    const knownLocation = knownCEPs[cep] || knownCEPs[formattedCEP];
                    const formattedCityName = formatLocationName(knownLocation.name);
                    
                    // Log para depuração
                    console.log(`CEP ${cep} encontrado na base de dados: ${knownLocation.name}, coordenadas: ${knownLocation.lat}, ${knownLocation.lng}`);
                    
                    newLocations.push({
                        id: locationId++,
                        name: name,
                        address: `${name}, ${formattedCityName}, SP, Brasil`,
                        zipCode: cep,
                        latitude: knownLocation.lat,
                        longitude: knownLocation.lng,
                        isOrigin: false
                    });
                } else {
                    // Adicionar à fila para geocodificação
                    geocodeQueue.push({
                        cep: cep,
                        name: name // Nome já formatado
                    });
                }
            }
        }
        
        // Processar os CEPs conhecidos imediatamente
        if (newLocations.length > 0) {
            // Para cada novo local, adicionar à lista e ao mapa
            newLocations.forEach((location, index) => {
                locations.push(location);
                addMarkerForLocation(location, locations.length - 1);
            });
            
            // Atualizar a lista de locais
            updateLocationsList();
            
            // Ajustar o zoom para mostrar todos os pontos com padding para melhor visualização
            zoomToFitAllMarkers();
            
            // Exibir notificação de sucesso
            showNotification(`${newLocations.length} locais adicionados com sucesso.`, "success");
        }
        
        // Processar a fila de geocodificação para CEPs desconhecidos
        if (geocodeQueue.length > 0) {
            // Adicionar uma notificação inline sobre o processo de geocodificação
            const fileUploadElement = document.querySelector('.file-upload');
            if (fileUploadElement) {
                const statusElement = document.createElement('div');
                statusElement.className = 'alert alert-info mt-3';
                statusElement.id = 'geocode-status';
                statusElement.innerHTML = `Processando ${geocodeQueue.length} endereços adicionais...`;
                fileUploadElement.appendChild(statusElement);
            }
            
            let processedCount = 0;
            
            // Função para processar a fila de geocodificação
            function processGeocodingQueue() {
                if (geocodeQueue.length === 0) {
                    // Todos os geocodes foram processados
                    const statusElement = document.getElementById('geocode-status');
                    if (statusElement && statusElement.parentNode) {
                        statusElement.parentNode.removeChild(statusElement);
                    }
                    return;
                }
                
                const item = geocodeQueue.shift();
                const address = `${item.cep}, Brasil`;
                
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const location = results[0].geometry.location;
                        
                        const newLocation = {
                            id: locationId++,
                            name: item.name, // Já vem formatado de antes
                            address: `${item.name}, ${formatLocationName(address)}`,
                            zipCode: item.cep,
                            latitude: location.lat(),
                            longitude: location.lng(),
                            isOrigin: false
                        };
                        
                        locations.push(newLocation);
                        addMarkerForLocation(newLocation, locations.length - 1);
                        
                        // Atualizar a lista de locais
                        updateLocationsList();
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Ajustar o zoom
                        zoomToFitAllMarkers();
                        
                        // Continuar com o próximo após um curto delay (para evitar limites de API)
                        setTimeout(processGeocodingQueue, 200);
                    } else {
                        // CORREÇÃO: Não adicionar CEPs que não puderam ser geocodificados
                        console.warn(`CEP não encontrado: ${item.cep} - ${item.name}. Este local não será adicionado.`);
                        
                        // Mostrar notificação para o usuário sobre o CEP não encontrado
                        const notifyError = document.createElement('div');
                        notifyError.className = 'alert alert-warning mt-2';
                        notifyError.innerHTML = `CEP não encontrado: ${item.cep} - ${item.name}`;
                        document.querySelector('.file-upload').appendChild(notifyError);
                        
                        // Remover a notificação após alguns segundos
                        setTimeout(() => {
                            if (notifyError && notifyError.parentNode) {
                                notifyError.parentNode.removeChild(notifyError);
                            }
                        }, 5000);
                        
                        // Atualizar o status sem adicionar o local
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Continuar com o próximo após um curto delay
                        setTimeout(processGeocodingQueue, 200);
                    }
                });
            }
            
            // Iniciar o processamento da fila
            processGeocodingQueue();
        }
        
        // Limpar o campo de upload
        document.getElementById('file-upload').value = '';
        
        // Contar as linhas válidas do arquivo original
        const validLines = lines.filter(line => {
            if (!line.trim()) return false;
            const parts = line.split(',');
            return parts.length >= 2 && parts[0].trim() && parts[1].trim();
        }).length;
        
        // Feedback para o usuário com notificação mais moderna e sem alterar layout
        const uploadArea = document.getElementById('upload-area');
        
        // Salvar o conteúdo original do componente de upload
        const originalContent = uploadArea.innerHTML;
        
        // Preservar dimensões originais
        const originalHeight = uploadArea.offsetHeight;
        const originalWidth = uploadArea.offsetWidth;
        
        // Guardar o estilo original para depois restaurar
        const originalStyle = {
            height: uploadArea.style.height,
            width: uploadArea.style.width,
            minHeight: uploadArea.style.minHeight
        };
        
        // Fixar as dimensões para evitar mudanças no layout
        uploadArea.style.height = originalHeight + 'px';
        uploadArea.style.width = originalWidth + 'px';
        uploadArea.style.minHeight = originalHeight + 'px';
        
        // Substituir com a mensagem de sucesso
        uploadArea.innerHTML = `
            <div class="upload-success">
                <i class="fas fa-check-circle upload-success-icon"></i>
                <h5 class="mt-2">Arquivo processado com sucesso!</h5>
                <p class="upload-success-text">${validLines} ${validLines === 1 ? 'local adicionado' : 'locais adicionados'}</p>
            </div>
        `;
        
        // Adicionar classes para animação
        uploadArea.classList.add('success');
        
        // Restaurar o componente original após alguns segundos
        setTimeout(() => {
            // Fade out
            uploadArea.classList.add('fading');
            
            setTimeout(() => {
                // Restaurar conteúdo original e dimensões flexíveis
                uploadArea.innerHTML = originalContent;
                uploadArea.style.height = originalStyle.height;
                uploadArea.style.width = originalStyle.width;
                uploadArea.style.minHeight = originalStyle.minHeight;
                uploadArea.classList.remove('success', 'fading');
            }, 300);
        }, 2500);
    }

    // Função para extrair CEP de um objeto Place
    function getZipCodeFromPlace(place) {
        if (!place.address_components) return "";
        
        for (let component of place.address_components) {
            if (component.types.includes('postal_code')) {
                return component.long_name;
            }
        }
        return "";
    }

    // Adiciona um marcador no mapa para um local
    // targetArray permite especificar onde o marcador será armazenado (para reordenação segura)
    function addMarkerForLocation(location, index, targetArray = null) {
        // Verificar se o local já tem um marcador existente antes de criar um novo
        const existingMarker = markers.find(m => String(m.location.id) === String(location.id));
        
        if (existingMarker) {
            console.log(`Reutilizando marcador existente para ${location.name} (ID: ${location.id})`);
            // Atualizar apenas o número de sequência no marcador existente
            existingMarker.marker.setLabel({
                text: index === 0 ? 'O' : (index).toString(),
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            });
            existingMarker.marker.setMap(map); // Garantir que está visível no mapa
            
            // Se for para adicionar a outro array, fazer isso
            if (targetArray) {
                targetArray.push(existingMarker);
            }
            
            return existingMarker;
        }
        
        // Caso não exista marcador, criar um novo
        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id})`);
        
        // Verificar se está na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        const isSameCityAsOrigin = origin && isSameCity(location, origin);
        
        // Ícone personalizado com número de sequência
        const markerLabel = index === 0 ? 'O' : (index).toString();
        
        // Cor específica para a origem e pontos na mesma cidade
        let markerColor = '#1976D2'; // Cor padrão (azul)
        if (index === 0) {
            markerColor = '#FF0000'; // Origem (vermelho)
        } else if (isSameCityAsOrigin) {
            markerColor = '#FF9800'; // Ponto na mesma cidade (laranja)
        }
        
        // Verificar se deve animar o marcador (apenas pontos na mesma cidade)
        const animation = isSameCityAsOrigin && !location.isOrigin ? 
                         google.maps.Animation.BOUNCE : null;
        
        console.log(`Configurando marcador para ${location.name} - Mesma cidade da origem: ${isSameCityAsOrigin}`);
        
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: location.name,
            label: {
                text: markerLabel,
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: markerColor,
                fillOpacity: 1,
                strokeWeight: 0,
                scale: 12
            },
            animation: animation,
            zIndex: index === 0 ? 1000 : (isSameCityAsOrigin ? 500 : 100) // Ordem: Origem > Mesma cidade > Outros
        });
        
        // Infowindow com detalhes do local
        const infowindow = new google.maps.InfoWindow({
            content: `
                <div>
                    <h5>${location.name}</h5>
                    <p>${location.address}</p>
                    ${location.zipCode ? `<p>CEP: ${location.zipCode}</p>` : ''}
                    ${!location.isOrigin ? `<button onclick="removeLocation('${location.id}')" class="btn btn-sm btn-danger">Remover</button>` : ''}
                </div>
            `
        });
        
        // Event listener para abrir o infowindow
        marker.addListener('click', function() {
            if (activeInfoWindow) {
                activeInfoWindow.close();
            }
            infowindow.open(map, marker);
            activeInfoWindow = infowindow;
            
            // Se o local estiver na mesma cidade da origem, destacar visualmente
            if (isSameCity(location, locations.find(loc => loc.isOrigin))) {
                marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(() => marker.setAnimation(null), 1500);
            }
        });
        
        // Criar objeto do marcador
        const markerObj = { marker, location, infowindow };
        
        // Armazenar o marcador na array principal ou na array alvo, se fornecida
        if (targetArray) {
            targetArray.push(markerObj);
        } else {
            markers.push(markerObj);
        }
        
        return markerObj;
    }

    // Atualiza a lista de locais no sidebar com base na ordem dos marcadores
    function updateLocationsList() {
        const container = document.getElementById('locations-list');
        if (!container) {
            console.error("Elemento 'locations-list' não encontrado!");
            return;
        }
        container.innerHTML = '';
        
        // Extrair os locais não-origem dos marcadores para preservar a ordem
        const orderedLocations = markers
            .map(m => m.location)
            .filter(loc => !loc.isOrigin);
        
        // Adicionar cada local à lista na ordem dos marcadores
        orderedLocations.forEach((location, index) => {
            const locationItem = document.createElement('div');
            locationItem.className = 'location-item';
            locationItem.setAttribute('data-id', location.id); // Adicionar data-id para a funcionalidade de rota personalizada
            locationItem.innerHTML = `
                <div>
                    <div><span class="badge bg-primary">${index + 1}</span> ${location.name}</div>
                    <div class="location-address">${location.address}</div>
                </div>
                <button class="btn btn-sm btn-danger" onclick="removeLocation('${location.id}')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                </button>
            `;
            container.appendChild(locationItem);
        });
    }

    // Remove um local da lista e do mapa
    function removeLocation(id) {
        console.log("Removendo localização com ID:", id, "Tipo:", typeof id);
        
        // Converter para string para garantir consistência na comparação
        const idStr = String(id);
        
        // Remover o local da lista
        locations = locations.filter(loc => String(loc.id) !== idStr);
        
        // Remover o marcador do mapa - usar String para garantir comparação consistente
        const markerIndex = markers.findIndex(m => String(m.location.id) === idStr);
        if (markerIndex !== -1) {
            console.log(`Marcador encontrado no índice ${markerIndex} e será removido`);
            markers[markerIndex].marker.setMap(null);
            markers.splice(markerIndex, 1);
        } else {
            console.log(`Nenhum marcador encontrado para o ID ${idStr}`);
        }
        
        // Atualizar a lista e reindexar os marcadores
        updateLocationsList();
        reindexMarkers();
        
        // Se houver uma rota atual, limpá-la
        clearRoute();
    }

    // Reindexar os marcadores após remoção
    function reindexMarkers() {
        markers.forEach((markerObj, index) => {
            if (!markerObj.location.isOrigin) {
                markerObj.marker.setLabel({
                    text: index.toString(),
                    color: 'white',
                    fontSize: '14px',
                    fontWeight: 'bold'
                });
            }
        });
    }

    // Limpar rota atual e marcadores relacionados
    // Função para limpar todas as polylines do mapa
    function clearAllPolylines() {
        console.log("Limpando todas as polylines do mapa...");
        
        // Limpar todas as polylines registradas
        if (allRoutePolylines.length > 0) {
            console.log(`Limpando ${allRoutePolylines.length} polylines registradas`);
            allRoutePolylines.forEach(polyline => {
                try {
                    if (polyline) polyline.setMap(null);
                } catch (e) {
                    console.error("Erro ao limpar polyline:", e);
                }
            });
            allRoutePolylines = [];
        }
        
        // Outras limpezas específicas de polylines
        if (routePath) {
            try {
                routePath.setMap(null);
                routePath = null;
                console.log("Polyline principal removida");
            } catch (e) {
                console.error("Erro ao remover polyline principal:", e);
            }
        }
        
        // Reset do mapa como medida adicional
        try {
            if (map) {
                const mapCenter = map.getCenter();
                map.setCenter(mapCenter);
                console.log("Mapa recentrado para forçar atualização");
            }
        } catch (e) {
            console.error("Erro ao recentrar mapa:", e);
        }
    }

    function clearRoute() {
        console.log("Limpando rota atual...");
        
        // Limpar o renderizador de direções
        if (directionsRendererInitialized && directionsRenderer) {
            try {
                // Limpar rotas existentes
                directionsRenderer.setDirections({ routes: [] });
                
                // Em alguns casos, pode ser necessário recriar o renderer
                directionsRenderer.setMap(null);
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: true,
                    preserveViewport: true,
                    polylineOptions: {
                        strokeColor: '#1976D2',
                        strokeOpacity: 0.7,
                        strokeWeight: 4
                    }
                });
                directionsRenderer.setMap(map);
                console.log("DirectionsRenderer recriado com sucesso");
            } catch (err) {
                console.error("Erro ao limpar direções:", err);
            }
        } else {
            console.warn("directionsRenderer não está disponível ou não inicializado");
        }
        
        // Limpar timeout de animação se existir
        if (routeAnimationTimeout) {
            clearTimeout(routeAnimationTimeout);
            routeAnimationTimeout = null;
            console.log("Animação de rota interrompida");
        }
        
        // Limpar todas as polylines
        clearAllPolylines();
        
        // Reset das variáveis de controle
        currentDisplayedRoute = null;
        
        // Limpar marcadores de POI
        clearPOIMarkers();
        
        // Limpar marcadores de eventos
        clearEventMarkers();
        
        // Resetar o resumo da rota - com verificação de segurança
        const routeSummary = document.getElementById('route-summary');
        if (routeSummary) {
            routeSummary.style.display = 'none';
        }
        document.getElementById('save-route').disabled = true;
        document.getElementById('print-route').disabled = true;
    }

    // Limpar marcadores de pontos de interesse
    function clearPOIMarkers() {
        poiMarkers.forEach(marker => marker.setMap(null));
        poiMarkers = [];
    }

    // Limpar marcadores de eventos
    function clearEventMarkers() {
        eventMarkers.forEach(marker => marker.setMap(null));
        eventMarkers = [];
    }

    // Otimizar a rota
    function optimizeRoute() {
        // Verificar se há pelo menos um destino além da origem
        if (locations.length <= 1) {
            // Usar função auxiliar para mostrar notificação
            showNotification('Adicione pelo menos um destino para calcular a rota.', 'warning', '.route-controls');
            // Esconder as abas inferiores se não houver destinos
            toggleBottomTabsVisibility(false);
            return;
        }
        
        // Mostrar as abas inferiores quando houver destinos, mas mantê-las minimizadas
        // Deixamos visível mas não expandimos automaticamente
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        if (bottomTabsContainer) {
            bottomTabsContainer.style.removeProperty('display');
            bottomTabsContainer.style.display = 'flex';
            // Mantém minimizado deliberadamente, o usuário deve clicar para expandir
            bottomTabsContainer.classList.add('minimized');
        }
        
        // Mostrar spinner de carregamento centralizado no mapa
        showLoadingSpinner();
        
        // Mostrar loading no botão também
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = '<span class="spinner-border" role="status" aria-hidden="true"></span> Calculando...';
            optimizeBtn.disabled = true;
        }
        
        // IMPORTANTE: Assegurar que os marcadores originais sejam preservados antes de limpar
        const currentMarkers = [...markers]; // Criar uma cópia dos marcadores atuais
        
        // Limpar rota anterior
        clearRoute();
        
        // Usar caminhão padrão como veículo
        const vehicleType = "truck1"; // Caminhão 1 eixo como padrão
        
        // Calcular a rota otimizada (versão simplificada do TSP)
        calculateOptimizedRoute(vehicleType, false, currentMarkers);
    }

    // Calcular rota otimizada pelo algoritmo TSP
    function calculateOptimizedRoute(vehicleType, includeOriginReturn, savedMarkers = null) {
        try {
            console.log("==========================================");
            console.log("  INICIANDO CÁLCULO DE ROTA OTIMIZADA");
            console.log("==========================================");
            
            // Limpar rotas alternativas existentes
            alternativeRoutes = [];
            currentRouteIndex = 0;
            
            // Garantir que temos localizações válidas
            if (!locations || !Array.isArray(locations) || locations.length === 0) {
                console.error("Nenhuma localização disponível");
                showNotification("Erro: Nenhuma localização disponível", "error");
                return;
            }
            
            // Encontrar origem e destinos
            const origin = locations.find(loc => loc.isOrigin);
            const destinations = locations.filter(loc => !loc.isOrigin);
            
            if (!origin) {
                console.error("Origem não encontrada", locations);
                showNotification("Erro: Não foi possível identificar uma origem", "error");
                return;
            }
            
            if (!destinations.length) {
                console.error("Nenhum destino encontrado", locations);
                showNotification("Adicione pelo menos um destino para calcular a rota", "warning");
                return;
            }
            
            // Validar coordenadas da origem
            if (!origin.latitude || !origin.longitude || isNaN(origin.latitude) || isNaN(origin.longitude)) {
                console.error("Origem com coordenadas inválidas:", origin);
                origin.latitude = -22.3673; // Dois Córregos
                origin.longitude = -48.3822;
                console.log("Corrigidas coordenadas da origem");
            }
            
            // Validar coordenadas dos destinos
            let allValid = true;
            for (let dest of destinations) {
                if (!dest.latitude || !dest.longitude || isNaN(dest.latitude) || isNaN(dest.longitude)) {
                    console.error("Destino com coordenadas inválidas:", dest);
                    dest.latitude = -22.3673 + (Math.random() - 0.5) * 0.1; // Próximo a Dois Córregos
                    dest.longitude = -48.3822 + (Math.random() - 0.5) * 0.1;
                    console.log("Corrigidas coordenadas de destino", dest.name);
                    allValid = false;
                }
            }
            
            if (!allValid) {
                console.warn("Algumas coordenadas de destino foram corrigidas automaticamente");
            }
            
            // Calcular distância em linha reta (para verificação e garantia)
            let straightLineDistance = 0;
            try {
                for (let i = 0; i < destinations.length; i++) {
                    const dist = calculateDistance(
                        origin.latitude, origin.longitude,
                        destinations[i].latitude, destinations[i].longitude
                    );
                    straightLineDistance += dist;
                    console.log(`Distância de ${origin.name} para ${destinations[i].name}: ${dist.toFixed(1)} km`);
                }
                console.log("Distância total aproximada em linha reta:", straightLineDistance.toFixed(1), "km");
            } catch (distError) {
                console.error("Erro ao calcular distância em linha reta:", distError);
                straightLineDistance = destinations.length * 50; // Valor médio seguro
                console.log("Usando distância segura:", straightLineDistance);
            }
            
            // Gerar rotas alternativas usando diferentes algoritmos
            generateAlternativeRoutes(origin, destinations, includeOriginReturn);
            
            // CRIAR UMA ROTA DE BACKUP CASO ALGO FALHE
            const backupRoute = {
                path: [origin, ...destinations],
                pathIds: [origin.id, ...destinations.map(d => d.id)],
                distance: Math.max(100, straightLineDistance * 1.3),
                time: calculateTravelTime(Math.max(100, straightLineDistance * 1.3)) // tempo usando função centralizada
            };
            
            // Verificar se temos alternativas geradas
            if (!alternativeRoutes || !Array.isArray(alternativeRoutes) || alternativeRoutes.length === 0) {
                console.warn("Nenhuma rota alternativa disponível. Usando rota de backup.");
                alternativeRoutes = [backupRoute];
            }
            
            // Processar todas as rotas alternativas para garantir consistência
            alternativeRoutes = postProcessTspResults(alternativeRoutes);
            console.log("Rotas alternativas após processamento:", alternativeRoutes);
            
            // Usar a primeira rota como padrão
            let tspResult = alternativeRoutes[0];
            
            // Verificar se o resultado é válido
            if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path) || tspResult.path.length === 0) {
                console.warn("Resultado TSP inválido. Usando rota de backup.", tspResult);
                tspResult = backupRoute;
                alternativeRoutes[0] = backupRoute;
            }
            
            // Garantir que temos pathIds para uso posterior
            if (!tspResult.pathIds || !Array.isArray(tspResult.pathIds)) {
                console.warn("Gerando pathIds para a rota");
                
                // Tentar extrair IDs dos objetos de localização
                tspResult.pathIds = tspResult.path.map(item => {
                    // Se o item for um objeto com ID
                    if (typeof item === 'object' && item !== null && item.id !== undefined) {
                        return item.id;
                    }
                    // Se o item já for um ID
                    return item;
                });
                
                console.log("IDs de caminho gerados:", tspResult.pathIds);
            }
            
            // VERIFICAR E CORRIGIR DISTÂNCIA INVÁLIDA (PROBLEMA COMUM NO GITHUB PAGES)
            if (typeof tspResult.distance !== 'number' || isNaN(tspResult.distance) || tspResult.distance <= 0) {
                console.warn("CORREÇÃO CRÍTICA: Distância TSP inválida detectada:", tspResult.distance);
                
                // Estratégia 1: Recalcular a distância baseada nas coordenadas dos pontos
                let recalculatedDistance = 0;
                try {
                    const pathPoints = tspResult.path || [];
                    
                    if (pathPoints.length > 1) {
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            const current = pathPoints[i];
                            const next = pathPoints[i + 1];
                            
                            if (current && next && 
                                current.latitude && current.longitude && 
                                next.latitude && next.longitude) {
                                const segmentDist = calculateDistance(
                                    current.latitude, current.longitude,
                                    next.latitude, next.longitude
                                );
                                recalculatedDistance += segmentDist;
                            }
                        }
                    }
                    
                    console.log("Distância recalculada:", recalculatedDistance);
                } catch (distError) {
                    console.error("Erro ao recalcular distância:", distError);
                }
                
                // Estratégia 2: Se recálculo falhar, usar a distância em linha reta com fator de correção
                if (recalculatedDistance <= 0) {
                    recalculatedDistance = destinations.length * 50; // Valor médio seguro
                    
                    if (straightLineDistance > 0) {
                        // Fator de correção para compensar curvas das estradas
                        recalculatedDistance = straightLineDistance * 1.4;
                    }
                    
                    console.log("Usando distância aproximada:", recalculatedDistance);
                }
                
                // Definir nova distância com valor mínimo garantido
                tspResult.distance = Math.max(recalculatedDistance, destinations.length * 20, 30);
                console.log("Distância final corrigida:", tspResult.distance.toFixed(1), "km");
                
                // Atualizar o tempo usando nossa função centralizada
                tspResult.time = calculateTravelTime(tspResult.distance);
                console.log("Tempo atualizado:", tspResult.time.toFixed(1), "minutos");
            }
            
            // IMPORTANTE: Método direto para processar a rota padrão 
            // em vez de usar o seletor que está causando problemas
            
            console.log("Tratando a rota padrão DIRETAMENTE (sem usar o event handler)...");
            
            // Salvar uma cópia de quais locais temos antes de iniciar
            const locationsBeforeRoute = [...locations];
            console.log("Locais antes de processar rota:", locationsBeforeRoute.map(l => `${l.name} (ID: ${l.id})`));
            
            // Limpar as rotas no mapa, mas não os marcadores
            if (directionsRenderer) {
                directionsRenderer.setMap(null);
            }
            
            // Criar um novo array para os marcadores reordenados
            const reorderedMarkers = [];
            
            // Verificar e corrigir possíveis problemas com os IDs da rota
            const fixedPath = tspResult.path.map(locationId => {
                if (typeof locationId === 'object' && locationId !== null) {
                    // Se for um objeto, extrair o ID
                    return locationId.id || locationId;
                }
                return locationId;
            });
            
            // Substituir o caminho original pelo caminho com IDs corrigidos
            tspResult.path = fixedPath;
            
            console.log("Caminho da rota após correção:", tspResult.path);
            
            // Processar a rota em ordem correta
            tspResult.path.forEach((locationId, index) => {
                // Garantir que o ID é uma string para comparação
                const locationIdStr = String(locationId);
                console.log(`Processando ID: ${locationIdStr}, tipo original: ${typeof locationId}, valor:`, locationId);
                
                const location = locations.find(loc => String(loc.id) === locationIdStr);
                
                if (!location) {
                    console.error(`Marcador não encontrado para localização ID: ${locationIdStr}`);
                    return;
                }
                
                console.log(`Processando ponto ${index} da rota: ${location.name} (ID: ${location.id})`);
                
                // Verificar se é a origem para garantir que o número de sequência seja 0
                const markerIndex = location.isOrigin ? 0 : index;
                
                // Verificar se já existe um marcador para este local
                const existingMarkerObj = markers.find(m => String(m.location.id) === locationIdStr);
                
                if (existingMarkerObj) {
                    // Atualizar rótulo do marcador com a nova sequência
                    existingMarkerObj.marker.setLabel({
                        text: markerIndex === 0 ? 'O' : markerIndex.toString(),
                        color: 'white',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    });
                    
                    // Garantir que o marcador esteja visível no mapa
                    existingMarkerObj.marker.setMap(map);
                    
                    // Adicionar à lista de marcadores reordenados
                    reorderedMarkers.push(existingMarkerObj);
                } else {
                    // Se o marcador não existir, criar um novo
                    const newMarkerObj = addMarkerForLocation(location, markerIndex, reorderedMarkers);
                    console.log(`Criado novo marcador para ${location.name} (ID: ${location.id})`);
                }
            });
            
            // Atualizar o array principal de marcadores com os reordenados
            if (reorderedMarkers.length > 0) {
                console.log(`Substituindo array de marcadores (${markers.length}) pelos reordenados (${reorderedMarkers.length})`);
                markers = [...reorderedMarkers];
            }
            
            // Verificar se temos localizações suficientes para desenhar a rota
            if (tspResult.path.length >= 2) {
                // Coletar localizações na ordem da rota para desenhar no mapa
                // Usamos os IDs já normalizados
                const pathLocations = [];
                
                // Adicionar cada localização verificando antes
                tspResult.path.forEach(id => {
                    const idStr = String(id);
                    
                    // Verificar que não é um objeto antes de pesquisar
                    if (typeof id === 'object') {
                        console.log(`ID de tipo objeto encontrado: ${JSON.stringify(id)}`);
                        return; // pular este ID
                    }
                    
                    const location = locations.find(loc => String(loc.id) === idStr);
                    if (!location) {
                        console.error(`Localização não encontrada para ID: ${idStr} durante o desenho da rota`);
                    } else {
                        // Só adicionar se encontrou a localização
                        pathLocations.push(location);
                    }
                });
                
                // Desenhar a rota no mapa usando as direções do Google
                // Usamos drawRouteOnMap que é a função correta definida no código
                const pathToUse = tspResult.pathIds || tspResult.path;
                drawRouteOnMap(pathToUse, vehicleType);
                
                // Mostrar pontos de interesse e eventos ao longo da rota
                showPointsOfInterestOnRoute(pathToUse);
                showEventsForCitiesOnRoute(pathToUse);
                showTruckRestrictionsForCitiesOnRoute(pathToUse, null); // null para mostrar todos os tipos
                
                // Atualizar a sequência de rota no relatório
                // A função não existe, então implementamos diretamente aqui
                const routeSequenceElement = document.getElementById('route-sequence');
                if (routeSequenceElement) {
                    // Limpar qualquer conteúdo anterior
                    routeSequenceElement.innerHTML = '';
                    
                    // Obter localizações na ordem da rota
                    // Garantir que todos os IDs já foram normalizados na etapa anterior
                    const routeLocations = tspResult.path.map(id => {
                        const idStr = String(id);
                        const location = locations.find(loc => String(loc.id) === idStr);
                        if (!location) {
                            console.error(`Localização não encontrada para ID: ${idStr} ao montar sequência`);
                        }
                        return location;
                    }).filter(loc => loc !== undefined);
                    
                    // Criar lista com a sequência de locais
                    const sequenceList = document.createElement('ol');
                    sequenceList.className = 'route-sequence-list';
                    
                    routeLocations.forEach((location, index) => {
                        const item = document.createElement('li');
                        // Destacar a origem
                        if (location.isOrigin) {
                            item.className = 'origin-point';
                            item.innerHTML = `${location.name} (Origem)`;
                        } else {
                            item.innerHTML = location.name;
                        }
                        sequenceList.appendChild(item);
                    });
                    
                    routeSequenceElement.appendChild(sequenceList);
                }
                
                // Adicionar também informações de distância e tempo estimado ao relatório
                const routeInfoElement = document.getElementById('route-summary');
                if (routeInfoElement) {
                    const distance = tspResult.distance ? tspResult.distance.toFixed(1) : "N/A";
                    const hours = Math.floor(tspResult.time / 60);
                    const minutes = Math.round(tspResult.time % 60);
                    const timeStr = hours > 0 ? `${hours}h ${minutes}min` : `${minutes}min`;
                    
                    routeInfoElement.innerHTML = `
                        <h3>Resumo da Rota</h3>
                        <p><strong>Distância total:</strong> ${distance} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeStr}</p>
                    `;
                }
                
                // Imprimir diagnóstico de marcadores após o processamento
                console.log(`Após processar rota: ${markers.length} marcadores principais, ${reorderedMarkers.length} marcadores reordenados`);
            } else {
                console.error("Número insuficiente de pontos para desenhar uma rota");
            }
            
            // Mostrar restrições para caminhões nas cidades da rota
            showTruckRestrictionsForCitiesOnRoute(tspResult.path, null); // null para mostrar todos os tipos
            
            // Atualizar o resumo da rota
            updateRouteSummary(tspResult, vehicleType);
        } catch (error) {
            console.error("Erro ao calcular rota otimizada:", error);
            // Usar a função centralizada de notificação
            showNotification("Ocorreu um erro ao calcular a rota. Tente novamente.", "error");
        }
        
        // Habilitar botões de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
        
        // Esconder o spinner de carregamento
        hideLoadingSpinner();
        
        // Restaurar o botão de otimizar
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
        }
        
        // Não navegar automaticamente para nenhuma aba após a otimização
        console.log("Rota otimizada com sucesso, mantendo a aba atual");
        
        // Restaurar o modo de Rota Personalizada se estava ativo
        const customRouteButton = document.getElementById('custom-route');
        if (customRouteMode && customRouteButton) {
            // Reativar o modo de rota personalizada
            const locationsListElement = document.getElementById('locations-list');
            if (locationsListElement) {
                locationsListElement.classList.add('custom-route-active');
                
                // Readicionar eventos de drag and drop a todos os itens de localização
                const locationItems = locationsListElement.querySelectorAll('li');
                locationItems.forEach(item => {
                    if (!item.classList.contains('origin-point')) {
                        item.classList.add('draggable');
                        item.setAttribute('draggable', 'true');
                        
                        item.addEventListener('dragstart', handleDragStart);
                        item.addEventListener('dragover', handleDragOver);
                        item.addEventListener('dragleave', handleDragLeave);
                        item.addEventListener('drop', handleDrop);
                        item.addEventListener('dragend', handleDragEnd);
                    }
                });
            }
        }
        
        // Garantir que os containers se ajustem ao conteúdo após o carregamento
        const restrictionsContainer = document.querySelector('.restrictions-container');
        const eventsContainer = document.querySelector('.events-container');
        
        if (restrictionsContainer) {
            restrictionsContainer.style.height = 'auto';
            restrictionsContainer.style.minHeight = '200px';
        }
        
        if (eventsContainer) {
            eventsContainer.style.height = 'auto';
            eventsContainer.style.minHeight = '200px';
        }
    }
    
    // Reordenar os marcadores para corresponder à sequência otimizada
    function reorderMarkers(optimizedPathIds) {
        console.log("Reordenando marcadores para caminho:", optimizedPathIds);
        
        // Atualizar a variável global com o caminho otimizado
        currentOptimizedPath = [...optimizedPathIds];
        
        // Atualizar eventos e restrições para o novo caminho otimizado
        // Preparar dados para atualização sem mudar para a aba de eventos
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        if (startDateInput && endDateInput) {
            // Atualizar dados dos eventos sem mudar de aba
            console.log("Atualizando dados de eventos em segundo plano sem mudar de aba");
            const routeIds = currentOptimizedPath;
            showEventsForCitiesOnRoute(routeIds, startDateInput.value, endDateInput.value);
            showTruckRestrictionsForCitiesOnRoute(routeIds, null);
        } else {
            // Fallback ao método antigo apenas se necessário
            console.log("Usando método alternativo de atualização");
        }
        console.log("Quantidade de marcadores antes:", markers.length);
        
        // Preservar os marcadores originais
        const originalMarkers = [...markers];
        
        // Remover os marcadores existentes do mapa (sem destruí-los)
        markers.forEach(markerObj => {
            markerObj.marker.setMap(null);
        });
        
        // Criar uma cópia vazia para novos marcadores
        const newMarkers = [];
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = optimizedPathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados e corrigir IDs que são objetos
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.",
                "IDs da rota:", optimizedPathIds);
            
            // Tentar corrigir IDs que são objetos em vez de valores primitivos
            optimizedPathIds = optimizedPathIds.map(id => {
                if (typeof id === 'object' && id !== null && id.id) {
                    return id.id; // Extrair o ID do objeto
                }
                return id;
            });
            
            // Tentar encontrar as localizações novamente
            console.log("Tentando novamente com IDs corrigidos:", optimizedPathIds);
            pathLocations = optimizedPathIds.map(id => {
                const idStr = String(id);
                return locations.find(loc => String(loc.id) === idStr);
            });
            
            // Se ainda houver localizações não encontradas, registrar mas continuar
            if (pathLocations.some(loc => !loc)) {
                console.error("Ainda há localizações não encontradas após correção.");
            }
        }
        
        // Verificar se é possível reutilizar marcadores existentes
        if (originalMarkers.length > 0) {
            console.log("Tentando reutilizar marcadores existentes");
            
            // Tentar reutilizar marcadores originais na nova ordem
            pathLocations
                .filter(loc => loc) // Remover localizações nulas
                .forEach((location, index) => {
                    // Encontrar o marcador original correspondente a esta localização
                    const originalMarker = originalMarkers.find(m => 
                        String(m.location.id) === String(location.id));
                    
                    if (originalMarker) {
                        // Reutilizar o marcador, atualizando apenas seu número de sequência
                        const marker = originalMarker.marker;
                        
                        // Garantir que a origem tenha sempre índice 0
                        const markerIndex = location.isOrigin ? 0 : (index);
                        const markerLabel = markerIndex === 0 ? 'O' : markerIndex.toString();
                        
                        console.log(`Atualizando marcador para ${location.name} (ID: ${location.id}) - É origem: ${location.isOrigin}, Label: ${markerLabel}`);
                        
                        marker.setLabel({
                            text: markerLabel,
                            color: "#FFFFFF",
                            fontSize: '14px',
                            fontWeight: 'bold'
                        });
                        marker.setMap(map);
                        
                        // Adicionar à nova lista de marcadores
                        newMarkers.push({
                            marker: marker,
                            location: location
                        });
                    } else {
                        // Se não encontrou o marcador original, criar um novo
                        // Garantir que a origem tenha sempre índice 0
                        const markerIndex = location.isOrigin ? 0 : index;
                        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id}) - É origem: ${location.isOrigin}, Índice: ${markerIndex}`);
                        addMarkerForLocation(location, markerIndex, newMarkers);
                    }
                });
                
            // Substituir o array de marcadores pelo novo
            markers = newMarkers;
        } else {
            // Fallback para o comportamento original
            console.log("Não há marcadores originais para reutilizar, criando novos");
            
            // Adicionar marcadores novamente na ordem otimizada
            pathLocations
                .filter(loc => loc) // Remover localizações nulas
                .forEach((location, index) => {
                    addMarkerForLocation(location, index);
                });
        }
        
        console.log("Quantidade de marcadores após reordenação:", markers.length);
        
        // Atualizar a lista de locais
        updateLocationsList();
    }

    // Função auxiliar para verificar se dois locais estão na mesma cidade
    function isSameCity(loc1, loc2) {
        if (!loc1 || !loc2) return false;
        
        console.log(`Verificando se ${loc1.name} e ${loc2.name} estão na mesma cidade`);
        
        // Se o nome da cidade está explícito no objeto
        if (loc1.cityName && loc2.cityName) {
            const result = loc1.cityName === loc2.cityName;
            console.log(`Comparação por cityName: ${loc1.cityName} vs ${loc2.cityName} = ${result}`);
            return result;
        }
        

        
        // Extrair cidade dos endereços (normalmente o primeiro componente após o nome)
        const address1Parts = loc1.address ? loc1.address.split(',') : [];
        const address2Parts = loc2.address ? loc2.address.split(',') : [];
        
        // Verificar se os endereços têm pelo menos duas partes (nome, cidade)
        if (address1Parts.length > 0 && address2Parts.length > 0) {
            const city1 = address1Parts[0].trim().toLowerCase();
            const city2 = address2Parts[0].trim().toLowerCase();
            
            if (city1 === city2) {
                console.log(`Mesma cidade encontrada nos endereços: ${city1}`);
                return true;
            }
        }
        
        // Verificar se ambos os nomes contêm a mesma cidade
        if (loc1.name && loc2.name) {
            // Removemos acentos e convertemos para minúsculas para comparação
            const name1 = loc1.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            const name2 = loc2.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            
            // Lista de cidades comuns do interior de São Paulo
            const cities = [
                "dois corregos", "dois córregos", "jau", "jaú", "botucatu", "bauru", 
                "pederneiras", "brotas", "barra bonita", "igaracu", "igaraçu", 
                "agudos", "lencois", "lençóis", "itapui", "itapuí"
            ];
            
            // Verificar se ambos os nomes contêm a mesma cidade
            for (const city of cities) {
                if (name1.includes(city) && name2.includes(city)) {
                    console.log(`Mesma cidade encontrada nos nomes: "${city}"`);
                    return true;
                }
            }
        }
        
        console.log("Não estão na mesma cidade");
        return false;
    }
    
    // Funções para controlar o spinner de carregamento
    function showLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'block';
        }
    }
    
    function hideLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    }
    
    // Traçar a rota no mapa
    function drawRouteOnMap(pathIds, vehicleType) {
        console.log("Desenhando rota para IDs:", pathIds);
        
        // Mostrar spinner durante o carregamento
        showLoadingSpinner();
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de caminho inválidos ou vazios:", pathIds);
            hideLoadingSpinner();
            return; // Interromper execução para evitar erros
        }
        
        // Verificar se há uma rota já desenhada e removê-la para evitar sobreposições
        if (routePath) {
            console.log("Removendo rota anterior antes de desenhar nova rota");
            try {
                routePath.setMap(null);
                routePath = null;
            } catch (e) {
                console.error("Erro ao remover rota anterior:", e);
            }
        }
        
        console.log("Localizações disponíveis:", locations);
        
        // Converter ids para objetos de localização
        const pathLocations = [];
        for (let i = 0; i < pathIds.length; i++) {
            const id = pathIds[i];
            // Garantir que a comparação de IDs seja feita como string
            const lookupId = String(typeof id === 'object' ? (id.id || id) : id);
            console.log("Procurando localização com ID:", lookupId, "Tipo:", typeof lookupId);
            
            const location = locations.find(loc => String(loc.id) === lookupId);
            if (!location) {
                console.error(`Localização ID ${lookupId} não encontrada!`);
            } else {
                console.log(`Localização ID ${lookupId} encontrada:`, location);
                pathLocations.push(location);
            }
        }
        
        // Verificar se todos os ids foram encontrados
        if (pathLocations.length !== pathIds.length) {
            // Usar String para garantir comparação consistente
            const missingIds = pathIds.filter(id => {
                const idStr = String(id);
                return !pathLocations.find(loc => String(loc.id) === idStr);
            });
            
            console.error("Algumas localizações não foram encontradas:", missingIds);
            // Usar função auxiliar para mostrar notificação
            showNotification('Erro ao traçar rota: algumas localizações não foram encontradas', 'danger', '.route-controls');
            return;
        }
        
        // Verificar e destacar pontos na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        
        if (origin) {
            pathLocations.forEach(location => {
                if (!location.isOrigin && isSameCity(location, origin)) {
                    console.log(`Ponto ${location.name} está na mesma cidade da origem (${origin.name})`);
                    
                    // Encontrar o marcador correspondente e destacá-lo
                    const locationId = location.id;
                    console.log("Buscando marcador para ID:", locationId, "Tipo:", typeof locationId);
                    
                    // Depuração de todos os markers para diagnóstico
                    console.log("Todos os marcadores disponíveis:", markers.map(m => ({
                        name: m.location.name,
                        id: m.location.id,
                        idType: typeof m.location.id
                    })));
                    
                    // Busca do marcador com conversão de string consistente
                    const markerIdString = String(locationId);
                    console.log(`Procurando marcador com ID string "${markerIdString}"`);
                    
                    const marker = markers.find(m => {
                        if (!m || !m.location) {
                            console.log("Marcador inválido encontrado na lista");
                            return false;
                        }
                        
                        try {
                            const mLocationIdString = String(m.location.id);
                            const isMatch = mLocationIdString === markerIdString;
                            console.log(`Comparando IDs: "${mLocationIdString}" === "${markerIdString}" = ${isMatch}`);
                            return isMatch;
                        } catch (err) {
                            console.error("Erro ao comparar IDs:", err);
                            return false;
                        }
                    });
                    
                    if (marker) {
                        marker.marker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#FF4500', // Cor mais destacada
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#000',
                            scale: 12
                        });
                    } else {
                        console.log(`Marcador não encontrado para localização ${location.name} (ID: ${locationId})`);
                    }
                }
            });
        }
        
        // Criar waypoints para o serviço de direções
        console.log("Criando waypoints para o serviço de direções com " + pathLocations.length + " pontos");
        
        // Debug para verificar que temos todos os pontos necessários
        pathLocations.forEach((location, idx) => {
            console.log(`Ponto ${idx}: ${location.name} (${location.latitude}, ${location.longitude}) - isOrigin: ${location.isOrigin}`);
        });
        
        const waypoints = pathLocations.slice(1, -1).map(location => ({
            location: new google.maps.LatLng(location.latitude, location.longitude),
            stopover: true
        }));
        
        const originPoint = new google.maps.LatLng(
            pathLocations[0].latitude,
            pathLocations[0].longitude
        );
        
        const destinationPoint = new google.maps.LatLng(
            pathLocations[pathLocations.length - 1].latitude,
            pathLocations[pathLocations.length - 1].longitude
        );
        
        const request = {
            origin: originPoint,
            destination: destinationPoint,
            waypoints: waypoints,
            optimizeWaypoints: false, // Não otimizar, já temos a ordem do TSP
            travelMode: google.maps.TravelMode.DRIVING,
            avoidTolls: false
        };
        
        directionsService.route(request, (result, status) => {
            // Esconder indicador de progresso
            hideLoadingSpinner();
            
            if (status === google.maps.DirectionsStatus.OK) {
                // Verificar se o DirectionsRenderer foi inicializado corretamente
                if (!directionsRendererInitialized || !directionsRenderer) {
                    console.error("DirectionsRenderer não está disponível ou inicializado");
                    showNotification("Erro no serviço de rotas. Tente recarregar a página.", "danger");
                    return;
                }
                
                // Limpar todas as polylines antigas para evitar sobreposições
                clearAllPolylines();
                
                try {
                    // Limpar renderizador antes de aplicar novas direções
                    directionsRenderer.setMap(null);
                    
                    // Recriar o renderizador para garantir que não haja sobreposições
                    directionsRenderer = new google.maps.DirectionsRenderer({
                        suppressMarkers: true, // Usamos nossos próprios marcadores
                        preserveViewport: true, // Não muda o zoom/centro do mapa
                        polylineOptions: {
                            strokeColor: '#1976D2',
                            strokeOpacity: 0.7,
                            strokeWeight: 4
                        }
                    });
                    directionsRenderer.setMap(map);
                    
                    // Aplicar as direções ao renderizador
                    directionsRenderer.setDirections(result);
                    console.log("Direções aplicadas com sucesso");
                    
                    // Registrar esta rota como a atual
                    currentDisplayedRoute = pathIds;
                    
                    // Capturar referências às polylines para limpeza futura
                    setTimeout(() => {
                        try {
                            const mapDiv = document.getElementById('map');
                            if (mapDiv) {
                                const polylines = mapDiv.querySelectorAll('path');
                                console.log(`Encontradas ${polylines.length} polylines no mapa`);
                            }
                        } catch (e) {
                            console.error("Erro ao contar polylines:", e);
                        }
                    }, 500);
                    
                } catch (err) {
                    console.error("Erro ao aplicar direções:", err);
                    showNotification("Erro ao exibir rota no mapa: " + err.message, "warning");
                    return;
                }
                
                // Animar a rota (opcional)
                console.log("Resultado da rota:", result);
                
                // Verificar se os dados da rota estão disponíveis
                if (result && result.routes && result.routes.length > 0 && result.routes[0].overview_path) {
                    console.log("Iniciando animação da rota com", result.routes[0].overview_path.length, "pontos");
                    
                    // Pequeno atraso para garantir que o DirectionsRenderer esteja pronto
                    setTimeout(() => {
                        try {
                            // Verifica se os pontos são objetos de LatLng ou precisam ser convertidos
                            const routePoints = result.routes[0].overview_path.map(point => {
                                // Se já for um objeto LatLng, retorne-o diretamente
                                if (point instanceof google.maps.LatLng) {
                                    return point;
                                } 
                                // Se for um objeto com lat/lng como métodos
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    return new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    return new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Formato desconhecido
                                else {
                                    console.error("Formato de ponto desconhecido:", point);
                                    return null;
                                }
                            }).filter(p => p !== null);
                            
                            console.log("Pontos da rota preparados para animação:", routePoints.length);
                            animateRoute(routePoints);
                        } catch (err) {
                            console.error("Erro ao preparar pontos para animação da rota:", err);
                            showNotification("Não foi possível animar a rota: " + err.message, "warning");
                        }
                    }, 1000);
                    
                } else {
                    console.error("Dados da rota incompletos, não é possível animar:", result);
                    showNotification("Não foi possível visualizar a rota animada. Tente novamente.", "warning");
                }
                
                // Ajustar o mapa para mostrar toda a rota
                const bounds = new google.maps.LatLngBounds();
                pathLocations.forEach(location => {
                    bounds.extend(new google.maps.LatLng(location.latitude, location.longitude));
                });
                map.fitBounds(bounds);
                
                // Adicionar um pequeno padding ao mapa para melhor visualização
                const padding = {
                    top: 50,
                    right: 50,
                    bottom: 50,
                    left: 50
                };
                map.fitBounds(bounds, padding);
            } else {
                // Substituir alert por notificação inline mais suave
                console.error(`Erro ao calcular rota: ${status}`);
                
                // Preparar mensagem de erro mais amigável baseada no tipo de erro
                let errorMsg = '';
                
                if (status === 'ZERO_RESULTS') {
                    errorMsg = 'Não foi possível encontrar uma rota entre os pontos selecionados. ' +
                              'Isto pode ocorrer se um dos pontos estiver em uma área inacessível ' +
                              'ou se houver uma grande barreira natural (como um rio ou oceano) entre eles.';
                } else if (status === 'MAX_WAYPOINTS_EXCEEDED') {
                    errorMsg = 'Número máximo de destinos excedido. Tente dividir sua rota em partes menores.';
                } else if (status === 'MAX_ROUTE_LENGTH_EXCEEDED') {
                    errorMsg = 'A rota é muito longa. Tente dividir sua rota em partes menores.';
                } else if (status === 'OVER_QUERY_LIMIT') {
                    errorMsg = 'Limite de consultas excedido. Aguarde alguns minutos e tente novamente.';
                } else {
                    errorMsg = `Não foi possível calcular a rota: ${status}`;
                }
                
                // Usar função auxiliar para exibir notificação
                showNotification(errorMsg, 'danger');
                console.error("Directions request failed due to " + status);
            }
        });
    }

    // Animar a rota desenhando progressivamente
    function animateRoute(path) {
        console.log("Iniciando animação da rota...");
        
        // Logging para diagnóstico
        try {
            if (path && path.length > 0) {
                const firstPoint = path[0];
                console.log("Primeiro ponto da rota:", firstPoint);
                console.log("Tipo do primeiro ponto:", 
                    firstPoint instanceof google.maps.LatLng ? "LatLng" :
                    typeof firstPoint.lat === 'function' ? "Com métodos lat/lng" :
                    firstPoint.lat !== undefined ? "Com propriedades lat/lng" :
                    firstPoint.latitude !== undefined ? "Com propriedades latitude/longitude" :
                    "Desconhecido"
                );
            }
        } catch (e) {
            console.error("Erro ao analisar formato dos pontos:", e);
        }
        
        try {
            // Limpar qualquer animação existente
            if (routeAnimationTimeout) {
                clearTimeout(routeAnimationTimeout);
                routeAnimationTimeout = null;
            }
            
            // Se já existir uma rota, removê-la
            if (routePath) {
                try {
                    routePath.setMap(null);
                } catch (err) {
                    console.error("Erro ao limpar rota anterior:", err);
                }
                routePath = null;
            }
            
            // Forçar limpeza de qualquer polyline restante no mapa
            try {
                if (directionsRendererInitialized && directionsRenderer) {
                    directionsRenderer.setDirections({ routes: [] });
                }
                
                // Este é um "truque" para forçar a limpeza de todas as polylines
                if (map) {
                    const mapCenter = map.getCenter();
                    map.setCenter(mapCenter);
                }
            } catch (err) {
                console.error("Erro ao fazer limpeza extra do mapa:", err);
            }
            
            // Verificar se o caminho é válido
            if (!path) {
                console.error("Caminho nulo para animação");
                showNotification("Não foi possível animar a rota: dados ausentes", "warning");
                return;
            }
            
            if (!Array.isArray(path)) {
                console.error("Tipo de caminho inválido para animação:", typeof path);
                showNotification("Não foi possível animar a rota: formato de dados incorreto", "warning");
                return;
            }
            
            if (path.length === 0) {
                console.error("Caminho vazio para animação");
                showNotification("Não foi possível animar a rota: caminho vazio", "warning");
                return;
            }
        } catch (err) {
            console.error("Erro na inicialização da animação:", err);
            return;
        }
        
        // Limpar todas as polylines anteriores antes de criar nova
        clearAllPolylines();
        
        // Criar uma nova polyline para a rota
        routePath = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: '#1976D2',
            strokeOpacity: 1.0,
            strokeWeight: 5,
            map: map
        });
        
        // Registrar esta polyline para limpeza futura
        allRoutePolylines.push(routePath);
        
        console.log(`Animando rota com ${path.length} pontos...`);
        
        // Animação step-by-step
        let index = 0;
        const interval = 20; // ms entre cada ponto
        const batchSize = 3; // número de pontos a adicionar por vez (para animação mais suave)
        
        function animate() {
            // Verificar se o caminho da rota ainda está disponível
            if (!routePath) {
                console.error("routePath foi removido antes do início da animação");
                return;
            }
            
            if (index < path.length) {
                try {
                    // Adicionar um lote de pontos por vez para animação mais suave
                    for (let i = 0; i < batchSize && index < path.length; i++) {
                        if (routePath && routePath.getPath) {
                            try {
                                const point = path[index];
                                
                                // Criar um objeto LatLng válido, independente do formato do ponto
                                let latLng;
                                
                                // Se já for um objeto LatLng válido
                                if (point instanceof google.maps.LatLng) {
                                    latLng = point;
                                }
                                // Se for um objeto com métodos lat/lng
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    latLng = new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    latLng = new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Se for um objeto com propriedades latitude/longitude
                                else if (point.latitude !== undefined && point.longitude !== undefined) {
                                    latLng = new google.maps.LatLng(point.latitude, point.longitude);
                                }
                                // Formato desconhecido - usar um ponto padrão para evitar erros
                                else {
                                    console.error("Formato de ponto desconhecido na animação:", point);
                                    // Pular este ponto e continuar
                                    index++;
                                    continue;
                                }
                                
                                // Adicionar o ponto ao caminho
                                routePath.getPath().push(latLng);
                            } catch (pointErr) {
                                console.error("Erro ao processar ponto específico:", pointErr, "Índice:", index);
                                // Continuar para o próximo ponto mesmo em caso de erro
                            }
                        } else {
                            console.error("routePath foi removido durante a animação");
                            return; // Sair para evitar erros
                        }
                        index++;
                    }
                    
                    // Mostrar progresso da animação para depuração
                    if (index % 20 === 0 || index === path.length) {
                        console.log(`Animação da rota: ${Math.round((index / path.length) * 100)}% concluída (${index}/${path.length} pontos)`);
                    }
                    
                    // Agendar próximo batch da animação
                    routeAnimationTimeout = setTimeout(animate, interval);
                } catch (err) {
                    console.error("Erro durante a animação da rota:", err);
                    showNotification("Erro na animação da rota: " + err.message, "warning");
                }
            } else {
                console.log("Animação da rota concluída com sucesso.");
                showNotification("Rota calculada e animada com sucesso!", "success");
            }
        }
        
        // Iniciar animação com breve atraso
        console.log("Agendando início da animação da rota...");
        setTimeout(animate, 100);
    }

    // Mostrar pontos de interesse ao longo da rota
    function showPointsOfInterestOnRoute(pathIds) {
        console.log("Mostrando pontos de interesse para rota com IDs:", pathIds);
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inválidos ou vazios para pontos de interesse:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar pontos de interesse:", pathIds);
            } else {
                console.error("Impossível encontrar até mesmo a origem. Abortando exibição de pontos de interesse.");
                return;
            }
        }
        
        // Limpar marcadores anteriores
        clearPOIMarkers();
        
        // Se a opção de mostrar POIs estiver desativada, retornar
        if (!showPOIs) return;
        
        console.log("showPointsOfInterestOnRoute recebeu IDs:", pathIds);
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.", 
                "IDs da rota:", pathIds.map(id => String(id)),
                "Localizações:", locations);
            // Continuar mesmo com algumas localizações faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (versão melhorada)
        const citiesOnRoute = []; // Array para armazenar as cidades detectadas
        
        // Lista de cidades importantes para melhor detecção
        const knownCities = [
            "Campinas", "Ribeirão Preto", "São Carlos", "Piracicaba", "São Paulo", 
            "Sorocaba", "Americana", "Limeira", "Rio Claro", "Araraquara", "Bauru", 
            "Botucatu", "Jaú", "Dois Córregos", "Santos", "Guarulhos", "Osasco",
            "Jundiaí", "Franca", "Marília", "Presidente Prudente", "Araçatuba"
        ];
        
        // Para cada localização na rota
        pathLocations.filter(loc => loc).forEach(loc => {
            if (!loc.address) {
                // Se não tiver endereço, usar o nome da localização
                if (loc.name && !citiesOnRoute.includes(loc.name)) {
                    citiesOnRoute.push(loc.name);
                }
                return;
            }
            
            // 1. Verificar se o endereço contém alguma cidade conhecida
            const addressLower = loc.address.toLowerCase();
            let cityFound = false;
            
            knownCities.forEach(city => {
                if (addressLower.includes(city.toLowerCase())) {
                    if (!citiesOnRoute.includes(city)) {
                        console.log(`Cidade conhecida encontrada: ${city} em "${loc.address}"`);
                        citiesOnRoute.push(city);
                        cityFound = true;
                    }
                }
            });
            
            // 2. Se não encontrou nenhuma cidade conhecida, extrair a primeira parte do endereço
            if (!cityFound) {
                const parts = loc.address.split(',');
                const extractedCity = parts[0].trim();
                
                if (extractedCity && !citiesOnRoute.includes(extractedCity)) {
                    console.log(`Cidade extraída do endereço: ${extractedCity}`);
                    citiesOnRoute.push(extractedCity);
                }
            }
        });
        
        console.log("Cidades detectadas no percurso:", citiesOnRoute);
        
        // Filtrar POIs que estão nas cidades da rota
        const poisOnRoute = mockData.pointsOfInterest.filter(poi => 
            citiesOnRoute.some(city => poi.cityName.includes(city))
        );
        
        // Adicionar marcadores para os POIs
        poisOnRoute.forEach(poi => {
            let icon;
            
            // Ícone baseado no tipo de POI
            switch (poi.type) {
                case 'toll':
                    icon = {
                        path: 'M-2,-2 L2,-2 L2,2 L-2,2 Z', // Quadrado
                        fillColor: '#4caf50',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#007700',
                        scale: 6,
                        labelOrigin: new google.maps.Point(0, 0)
                    };
                    break;
                case 'weighStation':
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#ff9800',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#b26a00',
                        scale: 6
                    };
                    break;
                case 'gasStation':
                    icon = {
                        path: 'M-2,-2 L2,-2 L0,2 Z', // Triângulo
                        fillColor: '#2196f3',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#0069c0',
                        scale: 6
                    };
                    break;
                default:
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#9c27b0',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#6a0080',
                        scale: 6
                    };
            }
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: { lat: poi.latitude, lng: poi.longitude },
                map: map,
                title: poi.name,
                icon: icon,
                zIndex: 50
            });
            
            // Adicionar listener para mostrar tooltip ao passar o mouse
            marker.addListener('mouseover', function() {
                showTooltip(marker, poi);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Armazenar o marcador
            poiMarkers.push(marker);
        });
    }

    // Mostrar eventos para as cidades na rota
    function showEventsForCitiesOnRoute(pathIds, startDateStr, endDateStr) {
        console.log("=================== NOVA EXECUÇÃO ===================");
        console.log("Mostrando eventos para rota com IDs:", pathIds);
        console.log("Datas de filtro (string):", startDateStr, endDateStr);
        
        // Valores para filtragem por data - garantir que são strings válidas
        let startDateValue = startDateStr || "";
        let endDateValue = endDateStr || "";
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inválidos ou vazios:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar eventos:", pathIds);
            } else {
                console.error("Impossível encontrar até mesmo a origem. Abortando exibição de eventos.");
                return;
            }
        }
        
        // Limpar a lista de eventos
        const eventsListContainer = document.getElementById('events-list');
        eventsListContainer.innerHTML = '';
        
        // Log para diagnóstico
        console.log("Eventos disponíveis:", mockData.cityEvents);
        
        if (!pathIds || pathIds.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos.</p>';
            return;
        }
        
        // CORREÇÃO: Converter IDs para objetos de localização de forma mais robusta
        const pathLocations = [];
        for (const id of pathIds) {
            const idStr = String(id);
            const location = locations.find(loc => String(loc.id) === idStr);
            if (location) {
                pathLocations.push(location);
                console.log(`Localização encontrada para ID ${idStr}:`, location);
            }
        }
        
        if (pathLocations.length === 0) {
            console.error("Nenhuma localização válida encontrada na rota");
            eventsListContainer.innerHTML = '<p class="text-muted">Erro ao encontrar localizações na rota.</p>';
            return;
        }
        
        // EXTRAÇÃO MELHORADA DE CIDADES DO PERCURSO
        // Array para armazenar os nomes das cidades que estão REALMENTE na rota
        const citiesOnRoute = [];
        
        // Cidade de origem (sempre incluir Dois Córregos)
        citiesOnRoute.push("Dois Córregos");
        console.log(`[ROTA] Adicionada cidade de origem: Dois Córregos`);
        
        // Processar CADA destino na rota para extrair nomes de cidades
        for (const location of pathLocations) {
            // Apenas adicionar se tivermos um nome válido
            if (location && location.name) {
                // Verificar se o nome é uma cidade conhecida (estratégia 1)
                const knownCities = [
                    "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                    "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                    "Americana", "Sorocaba", "Limeira", "Rio Claro", "Mineiros do Tietê",
                    "Barra Bonita", "Igaraçu do Tietê", "Macatuba", "Pederneiras", "Bocaina",
                    "Brotas", "Torrinha", "Itirapina", "São Manuel", "Lençóis Paulista",
                    "Agudos", "Marília", "Ourinhos", "Assis", "Presidente Prudente"
                ];
                
                // Se o nome exato da localização é uma cidade conhecida
                if (knownCities.includes(location.name) && !citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionada cidade conhecida: ${location.name}`);
                    continue; // Ir para o próximo local
                }
                
                // Estratégia 2: Usar o nome da localização diretamente
                if (!citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionado local como possível cidade: ${location.name}`);
                }
            }
        }
        
        console.log(`[ROTA] Cidades encontradas no percurso (${citiesOnRoute.length}): ${citiesOnRoute.join(', ')}`);
        
        console.log("APENAS ESTAS CIDADES ESTÃO NA ROTA REAL:", citiesOnRoute);
        
        // NOVA IMPLEMENTAÇÃO DE FILTRAGEM DE EVENTOS
        console.log("NOVA IMPLEMENTAÇÃO: Filtragem estrita de eventos por cidade e data");
        console.log(`Filtrando eventos para cidades: ${citiesOnRoute.join(', ')}`);
        console.log(`Filtro de data: ${startDateValue || 'sem data inicial'} a ${endDateValue || 'sem data final'}`);
        
        // ESTE É O PONTO CRÍTICO PARA A CORREÇÃO DO FILTRO DE DATAS
        // Usar EXATAMENTE as datas informadas pelo usuário nos campos do formulário
        console.log("[CORREÇÃO DE FILTRO] Usando datas exatamente como informadas pelo usuário:", startDateStr, endDateStr);
        
        // Apenas ajustar se as datas estiverem totalmente vazias
        if (!startDateValue && !endDateValue) {
            // Obter os valores REAIS dos campos no formulário
            const startDateField = document.getElementById('start-date');
            const endDateField = document.getElementById('end-date');
            
            if (startDateField && startDateField.value) {
                startDateValue = startDateField.value;
                console.log("[FILTRO] Obtida data de início do campo do formulário:", startDateValue);
            }
            
            if (endDateField && endDateField.value) {
                endDateValue = endDateField.value;
                console.log("[FILTRO] Obtida data de fim do campo do formulário:", endDateValue);
            }
            
            // Se ainda estiver vazio, apenas então usar valores padrão
            const currentYear = new Date().getFullYear();
            if (!startDateValue) {
                startDateValue = `${currentYear}-01-01`;
                console.log("[FILTRO] Usando data de início padrão:", startDateValue);
            }
            
            if (!endDateValue) {
                endDateValue = `${currentYear}-12-31`;
                console.log("[FILTRO] Usando data de fim padrão:", endDateValue);
            }
        }
        
        console.log(`[DATA] Filtro FINAL: ${startDateValue} até ${endDateValue}`);
        
        // Array para armazenar eventos filtrados
        let eventsOnRoute = [];
        
        // Para cada evento nos dados...
        mockData.cityEvents.forEach(event => {
            let includeEvent = false;
            
            try {
                // PARTE 1: VERIFICAÇÃO DE CIDADE - Evento deve estar em uma cidade do percurso
                const cityMatch = citiesOnRoute.includes(event.cityName);
                if (!cityMatch) {
                    console.log(`[CIDADE] Evento '${event.name}' em '${event.cityName}' REJEITADO - cidade não está no percurso`);
                    return; // Pular para o próximo evento
                }
                
                // PARTE 2: AJUSTAR DATAS DO EVENTO PARA O ANO ATUAL
                // Evento especial: Festival de Verão
                const isFestivalVerao = event.id === 99 && event.name === "Festival de Verão";
                
                // Obter o ano atual
                const currentYear = new Date().getFullYear();
                
                // Criar novas datas para o evento ajustadas para o ano atual
                const eventStart = new Date(event.startDate);
                const eventEnd = new Date(event.endDate);
                
                // Garantir que estamos usando o ano atual para eventos anuais (aniversários)
                if (event.name.includes("Aniversário") || event.isHoliday) {
                    eventStart.setFullYear(currentYear);
                    eventEnd.setFullYear(currentYear);
                }
                
                // Ajustar horas para garantir dias completos
                eventStart.setHours(0,0,0,0);
                eventEnd.setHours(23,59,59,999);
                
                // Log detalhado
                console.log(`[EVENTO] ${event.name} (${event.cityName}): ${eventStart.toLocaleDateString('pt-BR')}-${eventEnd.toLocaleDateString('pt-BR')}`);
                
                // PARTE 3: APLICAR FILTRO DE DATA
                if (startDateValue && endDateValue) {
                    // Tratamento especial para o Festival de Verão
                    if (isFestivalVerao) {
                        console.log(`[FESTIVAL] Festival de Verão excluído quando há filtro de data`);
                        includeEvent = false;
                        return;
                    }
                    
                    try {
                        // Criar objetos Date para as datas do filtro
                        let filterStart = new Date(startDateValue);
                        let filterEnd = new Date(endDateValue);
                        
                        // Verificar se as datas são objetos Date válidos
                        if (isNaN(filterStart.getTime()) || isNaN(filterEnd.getTime())) {
                            console.error(`[ERRO] Datas de filtro inválidas: ${startDateValue}, ${endDateValue}`);
                            
                            // Tentar corrigir formatos de data (pode ser ISO ou MM/DD/YYYY)
                            if (startDateValue.includes('/')) {
                                const parts = startDateValue.split('/');
                                filterStart = new Date(parts[2], parts[0]-1, parts[1]);
                            }
                            
                            if (endDateValue.includes('/')) {
                                const parts = endDateValue.split('/');
                                filterEnd = new Date(parts[2], parts[0]-1, parts[1]);
                            }
                            
                            // Verificar novamente
                            if (isNaN(filterStart.getTime()) || isNaN(filterEnd.getTime())) {
                                console.error(`[ERRO] Impossível corrigir datas inválidas`);
                                includeEvent = true; // Em caso de erro, mostrar evento
                                return;
                            }
                        }
                        
                        // Garantir dia completo
                        filterStart.setHours(0,0,0,0);
                        filterEnd.setHours(23,59,59,999);
                        
                        // LÓGICA CORRETA DE FILTRAGEM CONFORME ESPECIFICAÇÃO:
                        // Para exibir um evento, as seguintes condições devem ser atendidas:
                        // 1. A data de início do filtro (start-date) deve ser <= data de início do evento
                        // 2. A data de fim do filtro (end-date) deve ser >= data de início do evento
                        
                        // Por exemplo:
                        // Evento de aniversário em 04/02/2025:
                        // - Será exibido se start-date <= 04/02/2025 E end-date >= 04/02/2025
                        
                        // Evento que ocorre de 04/08/2025 a 14/08/2025:
                        // - Será exibido se start-date <= 04/08/2025 E end-date >= 04/08/2025
                        
                        const isEventInFilterRange = filterStart <= eventStart && filterEnd >= eventStart;
                        
                        console.log(`[VERIFICAÇÃO DE DATA]`, {
                            evento: event.name,
                            eventStart: eventStart.toLocaleDateString('pt-BR'),
                            eventEnd: eventEnd.toLocaleDateString('pt-BR'),
                            filterStart: filterStart.toLocaleDateString('pt-BR'),
                            filterEnd: filterEnd.toLocaleDateString('pt-BR'),
                            // Verificar se a data início do filtro é <= data início do evento
                            condicao1: filterStart <= eventStart ? "SIM" : "NÃO",
                            // Verificar se a data fim do filtro é >= data início do evento
                            condicao2: filterEnd >= eventStart ? "SIM" : "NÃO",
                            resultado: isEventInFilterRange ? "ACEITO" : "REJEITADO"
                        });
                        
                        if (isEventInFilterRange) {
                            console.log(`[ACEITO] Evento '${event.name}' (${eventStart.toLocaleDateString('pt-BR')}) está dentro do período de filtro: ${filterStart.toLocaleDateString('pt-BR')} a ${filterEnd.toLocaleDateString('pt-BR')}`);
                            includeEvent = true;
                        } else {
                            console.log(`[REJEITADO] Evento '${event.name}' (${eventStart.toLocaleDateString('pt-BR')}) está fora do período de filtro: ${filterStart.toLocaleDateString('pt-BR')} a ${filterEnd.toLocaleDateString('pt-BR')}`);
                            includeEvent = false;
                        }
                    } catch (dateError) {
                        console.error(`[ERRO] Falha ao processar datas do filtro:`, dateError);
                        includeEvent = true; // Em caso de erro mostrar o evento
                    }
                } else {
                    // Sem filtro de data, mostrar todos os eventos
                    console.log(`[ACEITO] Evento '${event.name}' aceito (sem filtro de data)`);
                    includeEvent = true;
                }
                
            } catch (error) {
                console.error(`[ERRO GERAL] Falha ao processar evento ${event.name}:`, error);
                includeEvent = true; // Em caso de erro geral, mostrar o evento
            }
            
            // Se passou por todos os filtros, incluir o evento
            if (includeEvent) {
                console.log(`[FINAL] Evento '${event.name}' em '${event.cityName}' - INCLUÍDO NA LISTA FINAL`);
                eventsOnRoute.push(event);
            }
        });
        
        // Se não houver eventos, mostrar mensagem
        if (eventsOnRoute.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted" style="color: #666666;">Nenhum evento encontrado para o período e cidades selecionados.</p>';
            return;
        }
        
        // Limpar marcadores anteriores
        clearEventMarkers();
        
        // Ordenar eventos por data
        eventsOnRoute.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        
        // Adicionar cada evento à lista
        eventsOnRoute.forEach(event => {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Formatar datas
            const startDate = new Date(event.startDate);
            const endDate = new Date(event.endDate);
            const formattedStartDate = startDate.toLocaleDateString('pt-BR');
            const formattedEndDate = endDate.toLocaleDateString('pt-BR');
            const dateText = formattedStartDate === formattedEndDate ? 
                            formattedStartDate : 
                            `${formattedStartDate} - ${formattedEndDate}`;
            
            // Definir classe baseada no tipo de evento
            const eventTypeClass = event.isHoliday ? 'holiday' : 'event';
            
            eventItem.innerHTML = `
                <div class="event-name" style="color: #000000;">${event.name} 
                    <span class="event-type ${eventTypeClass}">${event.isHoliday ? 'Feriado' : 'Evento'}</span>
                    <span class="restriction-level ${event.restrictionLevel}">${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</span>
                </div>
                <div class="event-date" style="color: #000000;">${event.cityName} | ${event.name.includes("Aniversário") ? extrairDataFundacao(event.description) : dateText}</div>
                <div class="event-description" style="color: #000000;">${event.description}</div>
            `;
            
            eventsListContainer.appendChild(eventItem);
            
            // Adicionar marcador no mapa para o evento
            // Para simplificar, vamos usar a posição da cidade (primeiro local que corresponde ao nome da cidade)
            const cityLocation = pathLocations.find(loc => loc.address.includes(event.cityName));
            if (cityLocation) {
                addEventMarker(event, cityLocation);
            }
        });
    }

    // Adicionar marcador para um evento
    function addEventMarker(event, location) {
        // Seletor de ícone com base no tipo de evento
        const markerColor = event.isHoliday ? '#f44336' : '#ff9800';
        const markerIcon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: markerColor,
            fillOpacity: 1,
            strokeWeight: 1,
            strokeColor: '#000',
            scale: 8
        };
        
        // Criar o marcador
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: event.name,
            icon: markerIcon,
            zIndex: 30
        });
        
        // Conteúdo do tooltip
        const tooltipContent = `
            <div class="tooltip-title">${event.name}</div>
            <div>${event.cityName}</div>
            <div>${new Date(event.startDate).toLocaleDateString('pt-BR')} - ${new Date(event.endDate).toLocaleDateString('pt-BR')}</div>
            <div>${event.description}</div>
            <div>Nível de restrição: ${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</div>
        `;
        
        // Adicionar listener para mostrar tooltip ao passar o mouse
        marker.addListener('mouseover', function() {
            showTooltip(marker, { tooltipContent });
        });
        
        marker.addListener('mouseout', function() {
            hideTooltip();
        });
        
        // Armazenar o marcador
        eventMarkers.push(marker);
    }

    // Mostrar restrições para caminhões nas cidades da rota
    function showTruckRestrictionsForCitiesOnRoute(pathIds, vehicleType) {
        console.log("DEBUG: Acionando função para mostrar restrições de caminhões das cidades do percurso");
        console.log("Mostrando restrições de caminhões para rota com IDs:", pathIds);
        
        // Adicionar timestamp ao log para debug
        console.log("Timestamp:", new Date().toISOString());
        
        // Verificar se estamos no GitHub Pages
        const isGitHubPages = window.location.href.includes('github.io');
        
        if (isGitHubPages) {
            console.warn("GITHUB PAGES DETECTADO - Usando método adaptado para mostrar cidades na rota");
            
            // No GitHub Pages, vamos obter todas as cidades da rota
            // Esta é a parte crucial: capturar as cidades da rota atual
            const citiesInRoute = [];
            
            // Se tivermos um caminho otimizado válido, usá-lo
            if (window.currentOptimizedPath && window.currentOptimizedPath.length > 0) {
                console.log("Usando rota otimizada para identificar cidades", window.currentOptimizedPath);
                
                // Adicionar origem primeiro
                const origin = locations.find(loc => loc.isOrigin);
                if (origin) {
                    citiesInRoute.push({
                        cityName: extractCityName(origin.address || origin.name),
                        position: 1,
                        originalLocation: origin,
                        displayName: origin.name // Nome para mostrar na interface
                    });
                }
                
                // Adicionar as demais cidades da rota otimizada
                for (let i = 0; i < window.currentOptimizedPath.length; i++) {
                    const locationId = window.currentOptimizedPath[i];
                    const location = locations.find(loc => String(loc.id) === String(locationId));
                    
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: i + 2, // +2 porque origem é 1 e arrays começam em 0
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                }
            } else {
                // Fallback para pathIds passados para a função
                console.log("Usando pathIds como fallback para identificar cidades");
                
                // Usar os IDs de caminho fornecidos para obter as cidades
                pathIds.forEach((id, index) => {
                    const location = locations.find(loc => String(loc.id) === String(id));
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: index + 1,
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                });
            }
            
            // Garantir que temos cidades para mostrar
            if (citiesInRoute.length === 0) {
                console.warn("Nenhuma cidade encontrada na rota atual, usando cidades padrão");
                // Usar lista de cidades padrão como último recurso
                citiesInRoute.push(
                    { cityName: "Dois Córregos", position: 1, displayName: "Dois Córregos (origem)" },
                    { cityName: "Jaú", position: 2, displayName: "Jaú" },
                    { cityName: "Bauru", position: 3, displayName: "Bauru" }
                );
            }
            
            console.log("Cidades detectadas na rota:", citiesInRoute);
            
            // Limpar a lista
            const restrictionsListContainer = document.getElementById('restrictions-list');
            restrictionsListContainer.innerHTML = '';
            
            // Adicionar título explicativo
            const titleElement = document.createElement('div');
            titleElement.style.padding = '10px';
            titleElement.style.margin = '0 0 15px 0';
            titleElement.style.backgroundColor = '#ffc107';
            titleElement.style.color = 'black';
            titleElement.style.borderRadius = '4px';
            titleElement.style.fontWeight = 'bold';
            titleElement.style.textAlign = 'center';
            titleElement.style.width = '100%'; // Ocupar toda a largura disponível
            
            // Construir nome das cidades para o título usando displayName em vez de cityName
            const citiesSequence = citiesInRoute.map(c => c.displayName || c.cityName).join(' → ');
            titleElement.innerHTML = 'Restrições para caminhões na rota<br>' + 
                                    '<span style="font-size: 0.9em; font-weight: normal; word-wrap: break-word; display: inline-block; width: 100%;">' +
                                    citiesSequence +
                                    '</span>';
            
            restrictionsListContainer.appendChild(titleElement);
            
            // Para cada cidade na rota, gerar uma restrição representativa
            citiesInRoute.forEach(city => {
                // Gerar uma restrição para esta cidade
                // Vamos variar o tipo de restrição com base na posição para diversidade visual
                const restrictionType = city.position % 3 === 0 ? "rodizio" : (city.position % 2 === 0 ? "total" : "partial");
                const dayType = city.position % 2 === 0 ? "weekday" : "all";
                
                // Criar tipos diferentes de descrições conforme o tipo de restrição
                let description = "";
                if (restrictionType === "partial") {
                    description = "Restrição parcial para caminhões de grande porte no centro";
                } else if (restrictionType === "total") {
                    description = "Restrição total para caminhões acima de 2 eixos no centro";
                } else {
                    description = "Sistema de rodízio para todos os tipos de caminhões";
                }
                
                // Definir horários diferentes com base na posição para variedade
                const startHour = (city.position % 12) + 7; // Entre 7h e 18h
                const endHour = Math.min(startHour + 3, 22); // No máximo até 22h
                const startTime = `${startHour.toString().padStart(2, '0')}:00`;
                const endTime = `${endHour.toString().padStart(2, '0')}:00`;
                
                // Criar o elemento de restrição
                const restrictionItem = document.createElement('div');
                restrictionItem.className = 'restriction-item';
                
                // Determinar texto de dias
                let dayTypeText = 'Todos os dias';
                if (dayType === 'weekday') dayTypeText = 'Dias úteis';
                else if (dayType === 'weekend') dayTypeText = 'Finais de semana';
                
                // Estilo para a cidade com barra lateral colorida
                const cidadeStyle = 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px; display: flex; align-items: center; flex-wrap: wrap;';
                
                // Texto com a posição na rota e nome do local
                let posicaoNaRotaTexto = '';
                if (city.position === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">Origem</span>';
                    
                    // Adicionar nome do local se disponível
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                } else {
                    // Estilo para a posição com nome do local
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">#${city.position}</span>`;
                    
                    // Adicionar nome do local se disponível
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                }
                
                // Criar HTML da restrição
                restrictionItem.innerHTML = `
                    <div class="restriction-city" style="${cidadeStyle}">
                        ${posicaoNaRotaTexto}
                        ${city.cityName}
                        <span class="restriction-type ${restrictionType}">${restrictionType === 'partial' ? 'Parcial' : (restrictionType === 'total' ? 'Total' : 'Rodízio')}</span>
                    </div>
                    <div class="restriction-time">${dayTypeText} | ${startTime} - ${endTime}</div>
                    <div class="restriction-description">${description}</div>
                    <div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">✓ Esta cidade está no seu percurso</div>
                `;
                
                // Adicionar à lista
                restrictionsListContainer.appendChild(restrictionItem);
            });
            
            console.log(`GitHub Pages: Exibindo ${citiesInRoute.length} restrições para cidades na rota atual`);
            
            // Retornar para não continuar a execução da função original
            return;
        }
        
        // Verificações de segurança
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.warn("IDs de rota inválidos ou vazios. Usando modo demonstração para exibir restrições relevantes");
            
            // No modo demonstração, mostrar restrições para cidades importantes
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando a origem e cidades importantes para mostrar restrições:", pathIds);
            } else {
                console.warn("Impossível encontrar a origem, usando um ID padrão");
                pathIds = [1]; // ID padrão para quando não há localização de origem
            }
        }
        console.log("Parâmetro vehicleType:", vehicleType, "- Isso será ignorado completamente");
        // Limpar a lista de restrições
        const restrictionsListContainer = document.getElementById('restrictions-list');
        restrictionsListContainer.innerHTML = '';
        
        // Log detalhado para diagnóstico
        console.log("Restrições disponíveis:", mockData.truckRestrictions);
        
        // DEBUG: Forçar a exibição de restrições para todas as cidades importantes
        console.warn("DIAGNÓSTICO DE RESTRIÇÕES: Forçando exibição para todas as cidades");
        
        // Verificar se estamos na versão GitHub Pages (já feito na função)
        // A variável isGitHubPages já foi declarada no início da função
        // Apenas registrar para diagnóstico
        console.log("Executando em GitHub Pages (verificação secundária):", isGitHubPages);
        
        // Converter IDs para objetos de localização com comparação segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a comparação de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localizações não foram encontradas.",
                "IDs da rota:", pathIds.map(id => String(id)));
            // Continuar mesmo com algumas localizações faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (ignorar localizações não encontradas)
        console.log("Detectando cidades na rota para restrições de caminhões...");
        
        // IMPORTANTE: Para debug e diagnóstico - Visualizar as restrições disponíveis
        console.table(mockData.truckRestrictions.map(r => ({
            cidade: r.cityName,
            tipo: r.restrictionType,
            afeta: r.affectedVehicles ? r.affectedVehicles.join(', ') : 'todos',
            desc: r.description
        })));
        
        // Obter todos os waypoints da rota, se disponíveis
        let citiesFromWaypoints = [];
        
        // Verificar se temos uma rota ativa com direções
        if (directionsRenderer && directionsRenderer.getDirections()) {
            const route = directionsRenderer.getDirections().routes[0];
            if (route && route.legs) {
                // Extrair cidades de todos os waypoints na rota
                route.legs.forEach(leg => {
                    if (leg.start_address) {
                        const startCity = extractCityFromAddress(leg.start_address);
                        if (startCity) citiesFromWaypoints.push(startCity);
                    }
                    if (leg.end_address) {
                        const endCity = extractCityFromAddress(leg.end_address);
                        if (endCity) citiesFromWaypoints.push(endCity);
                    }
                });
                console.log("Cidades extraídas de waypoints da rota:", citiesFromWaypoints);
            }
        }
        
        /**
         * Extrai o nome da cidade de um endereço completo
         * @param {string} address - Endereço completo
         * @returns {string|null} - Nome da cidade extraído ou null se não encontrado
         */
        function extractCityFromAddress(address) {
            if (!address) return null;
            
            // Lista de cidades conhecidas para detecção direta
            const knownCities = [
                "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                "Americana", "Sorocaba", "Limeira", "Rio Claro", "Lençóis Paulista"
            ];
            
            // Procurar cidades conhecidas no endereço
            for (const city of knownCities) {
                if (address.includes(city)) {
                    return city;
                }
            }
            
            // Tentar extrair a cidade do formato padrão de endereço
            // Padrão comum: "Rua X, Cidade - Estado, CEP"
            const parts = address.split(',');
            if (parts.length >= 2) {
                // A cidade geralmente está na segunda parte
                let cityPart = parts[1].trim();
                
                // Remover o estado e CEP se presente
                if (cityPart.includes('-')) {
                    cityPart = cityPart.split('-')[0].trim();
                }
                
                return cityPart;
            }
            
            return null;
        }
        
        /**
         * Função principal para extrair nome de cidade de um texto ou endereço
         * Utiliza várias estratégias para identificar a cidade
         * @param {string} addressOrName - Endereço completo ou nome de localização
         * @returns {string} - Nome da cidade extraído ou texto original como fallback
         */
        function extractCityName(addressOrName) {
            if (!addressOrName) return 'Desconhecido';
            
            // Tentar extrair cidade de endereço completo primeiro
            const cityFromAddress = extractCityFromAddress(addressOrName);
            if (cityFromAddress) return cityFromAddress;
            
            // Lista de cidades conhecidas para reconhecimento direto
            const knownCities = [
                "Dois Córregos", "Jaú", "Botucatu", "Bauru", "Ribeirão Preto", 
                "São Paulo", "Campinas", "São Carlos", "Piracicaba", "Araraquara",
                "Americana", "Sorocaba", "Limeira", "Rio Claro", "Lençóis Paulista"
            ];
            
            // Verificar se o nome já contém uma cidade conhecida
            for (const city of knownCities) {
                if (addressOrName.includes(city)) {
                    return city;
                }
            }
            
            // Se chegamos até aqui, retornar o nome como está
            return addressOrName;
        }
        
        const citiesOnRoute = pathLocations
            .filter(loc => loc) // Remover localizações nulas
            .map(loc => {
                if (!loc.address) {
                    console.log("Localização sem endereço:", loc);
                    return loc.name || "Desconhecido";
                }
                
                // Extrair cidade do endereço ou usar nome da localização
                const cityName = extractCityFromAddress(loc.address) || loc.name.trim();
                
                console.log(`DEBUG - Localização: ${loc.name}, Endereço: ${loc.address}, Cidade extraída: ${cityName}`);
                return cityName;
            });
        
        // Adicionar cidades detectadas dos waypoints
        citiesFromWaypoints.forEach(city => {
            if (city && !citiesOnRoute.includes(city)) {
                citiesOnRoute.push(city);
            }
        });
        
        // Garantir que a origem (Dois Córregos) esteja incluída
        if (!citiesOnRoute.includes("Dois Córregos")) citiesOnRoute.push("Dois Córregos");
        
        // Extrair o destino final corretamente
        const destinoFinal = pathLocations[pathLocations.length - 1];
        if (destinoFinal && destinoFinal.address) {
            const destinoCity = extractCityFromAddress(destinoFinal.address);
            if (destinoCity && !citiesOnRoute.includes(destinoCity)) {
                citiesOnRoute.push(destinoCity);
                console.log(`Destino adicionado à lista de restrições: ${destinoCity}`);
            }
        }
        
        // IMPORTANTE: Adicionar cidades específicas para garantir que restrições apareçam
        // Adicionamos as cidades mais importantes do percurso para demonstração
        const cidadesImportantes = [
            "Dois Córregos", "Jaú", "Bauru", "Botucatu", "São Paulo", 
            "Campinas", "Piracicaba", "São Carlos", "Araraquara", 
            "Ribeirão Preto", "Americana", "Limeira", "Rio Claro"
        ];
        
        // Adicionar cidades importantes que podem estar no percurso
        // Isso garante que o usuário veja restrições relevantes mesmo se a detecção automática falhar
        cidadesImportantes.forEach(cidade => {
            if (!citiesOnRoute.includes(cidade)) {
                console.log(`Adicionando cidade importante para restrições: ${cidade}`);
                citiesOnRoute.push(cidade);
            }
        });
        
        console.log("CIDADES NA ROTA PARA RESTRIÇÕES (inclui importantes):", citiesOnRoute);
        
        // SOLUÇÃO MELHORADA: Filtrar restrições para TODAS as cidades
        console.log(`Filtrando restrições para TODAS as cidades na rota`);
        
        // DEBUG: Mostrar todas as cidades disponíveis nas restrições para diagnóstico
        const todasCidadesComRestricoes = [...new Set(mockData.truckRestrictions.map(r => r.cityName))];
        console.log("TODAS AS CIDADES COM RESTRIÇÕES DISPONÍVEIS:", todasCidadesComRestricoes);
        
        // Verificar tipos de caminhões específicos a serem filtrados
        const tiposCaminhoesFiltrar = ['truck1', 'truck2', 'truck3', 'truck4', 'truck5']; // Caminhão 1 eixo, 2 eixos, truck, comercial, toco
        
        // DEBUG: Registrar todas as restrições disponíveis para diagnóstico
        console.log("Total de restrições disponíveis:", mockData.truckRestrictions.length);
        
        // SOLUÇÃO DIRETA: no GitHub Pages substituímos os dados de restrições diretamente
        // para garantir que apenas cidades da rota sejam mostradas
        let restrictionsOnRoute;
        
        // Verificar se estamos no GitHub Pages
        if (isGitHubPages) {
            console.warn("MODO GITHUB PAGES - Substituindo dados por versão controlada");
            
            // No GitHub Pages, vamos criar uma versão controlada dos dados
            // com APENAS as restrições das cidades que queremos mostrar
            
            // Sobrescrever completamente as restrições no modo GitHub Pages
            // para termos controle total sobre o que é exibido
            const restricoesControladasGitHubPages = [
                // Dois Córregos (origem)
                { 
                    id: 1, 
                    cityName: "Dois Córregos", 
                    dayType: "weekday", 
                    startTime: "07:00", 
                    endTime: "09:00", 
                    restrictionType: "partial", 
                    description: "Restrição parcial para caminhões de grande porte no centro", 
                    affectedVehicles: ["truck1", "truck5"] 
                },
                
                // Jaú (segunda cidade na rota)
                { 
                    id: 2, 
                    cityName: "Jaú", 
                    dayType: "weekday", 
                    startTime: "17:00", 
                    endTime: "20:00", 
                    restrictionType: "partial", 
                    description: "Restrição parcial para todos os caminhões no centro", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                },
                
                // Bauru (terceira cidade na rota)
                { 
                    id: 3, 
                    cityName: "Bauru", 
                    dayType: "all", 
                    startTime: "07:00", 
                    endTime: "22:00", 
                    restrictionType: "rodizio", 
                    description: "Sistema de rodízio para todos os caminhões", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                }
            ];
            
            // Usar nossa lista controlada
            restrictionsOnRoute = restricoesControladasGitHubPages;
            
            console.log(`Usando lista controlada de restrições: ${restrictionsOnRoute.length}`);
        } else {
            // Modo normal - filtrar apenas restrições das cidades na rota
            restrictionsOnRoute = mockData.truckRestrictions.filter(restriction => {
                // 1. Verificar se a cidade está no percurso (caso exato primeiro)
                const cidadeExata = citiesOnRoute.includes(restriction.cityName);
                
                // 2. Comparação flexível para nomes de cidades (ambos os lados em minúsculas)
                const restrictionCity = restriction.cityName.toLowerCase().trim();
                
                // Verificar se a cidade da restrição está em alguma cidade na rota
                let cityMatch = cidadeExata;
                
                // Se não encontrou correspondência exata, tentar correspondência parcial
                if (!cityMatch) {
                    for (const city of citiesOnRoute) {
                        if (!city) continue;
                        
                        const routeCity = city.toLowerCase().trim();
                        
                        // Verificar correspondência exata primeiro
                        if (restrictionCity === routeCity) {
                            console.log(`CORRESPONDÊNCIA EXATA: ${restriction.cityName} = ${city}`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da rota está contida na cidade da restrição
                        if (routeCity.length > 3 && restrictionCity.includes(routeCity)) {
                            console.log(`CORRESPONDÊNCIA PARCIAL: '${restriction.cityName}' contém '${city}'`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da restrição está contida na cidade da rota
                        if (restrictionCity.length > 3 && routeCity.includes(restrictionCity)) {
                            console.log(`CORRESPONDÊNCIA PARCIAL INVERSA: '${city}' contém '${restriction.cityName}'`);
                            cityMatch = true;
                            break;
                        }
                    }
                }
                
                // 3. Verificar se a restrição afeta algum dos tipos de caminhões que estamos filtrando
                const tiposCaminhoesAfetados = restriction.affectedVehicles || [];
                const afetaTiposFiltrados = tiposCaminhoesAfetados.some(tipo => tiposCaminhoesFiltrar.includes(tipo));
                
                // Para restrições que afetam TODOS os caminhões, também incluímos
                const afetaTodos = tiposCaminhoesAfetados.includes('all') || tiposCaminhoesAfetados.length === 0;
                
                // Log detalhado para debug
                if (cityMatch) {
                    console.log(`CIDADE CORRESPONDE: ${restriction.cityName} - ${restriction.description}`);
                    console.log(`Afeta caminhões: ${restriction.affectedVehicles ? restriction.affectedVehicles.join(', ') : 'todos'}`);
                    
                    if (afetaTiposFiltrados || afetaTodos) {
                        console.log(`✓ INCLUI RESTRIÇÃO: Afeta os tipos de caminhões filtrados`);
                    } else {
                        console.log(`✗ EXCLUI RESTRIÇÃO: Não afeta os tipos de caminhões filtrados`);
                    }
                }
                
                // Retorna true apenas se a cidade está na rota E a restrição afeta os tipos de caminhões filtrados
                return cityMatch && (afetaTiposFiltrados || afetaTodos);
            });
            
            console.log(`RESTRIÇÕES FILTRADAS: ${restrictionsOnRoute.length} restrições encontradas para as cidades na rota`);
        }
        
        // Adicionar título explicativo para a seção de restrições no GitHub Pages
        if (isGitHubPages) {
            try {
                // Limpar a lista primeiro e adicionar título depois
                const restrictionsListContainer = document.getElementById('restrictions-list');
                
                // Limpar o container para garantir que não há restrições remanescentes
                restrictionsListContainer.innerHTML = '';
                
                // Criar título destacado
                const titleElement = document.createElement('div');
                titleElement.className = 'restrictions-title';
                titleElement.style.padding = '10px';
                titleElement.style.margin = '0 0 15px 0';
                titleElement.style.backgroundColor = '#1976D2';
                titleElement.style.color = 'white';
                titleElement.style.borderRadius = '4px';
                titleElement.style.fontWeight = 'bold';
                titleElement.style.textAlign = 'center';
                titleElement.style.width = '100%'; // Ocupar toda a largura disponível
                titleElement.innerHTML = 'Restrições para caminhões na rota<br>' + 
                                        '<span style="font-size: 0.9em; font-weight: normal; word-wrap: break-word; display: inline-block; width: 100%;">' +
                                        'Dois Córregos → Jaú → Bauru' +
                                        '</span>';
                
                // Adicionar título
                restrictionsListContainer.appendChild(titleElement);
                
                // Verificar o número de restrições
                console.log(`Exibindo ${restrictionsOnRoute.length} restrições na versão GitHub Pages`);
            } catch (e) {
                console.error("Erro ao adicionar título no GitHub Pages:", e);
            }
        }
        
        // Se não houver restrições, mostrar mensagem adaptada aos tipos de caminhões filtrados
        if (restrictionsOnRoute.length === 0) {
            // Formatar os tipos de caminhões para a mensagem
            const tiposCaminhoesTexto = [
                'caminhão de 1 eixo', 
                'caminhão de 2 eixos', 
                'caminhão truck',
                'caminhão comercial',
                'caminhão toco'
            ].join(', ');
            
            const mensagem = `<p class="text-muted">Nenhuma restrição encontrada para ${tiposCaminhoesTexto} nas cidades detectadas no percurso.</p>`;
            restrictionsListContainer.innerHTML = mensagem;
            return;
        }
        
        // Adicionar cada restrição à lista
        restrictionsOnRoute.forEach(restriction => {
            const restrictionItem = document.createElement('div');
            restrictionItem.className = 'restriction-item';
            
            // Texto para tipo de dia
            let dayTypeText = '';
            switch (restriction.dayType) {
                case 'weekday': dayTypeText = 'Dias úteis'; break;
                case 'weekend': dayTypeText = 'Fins de semana'; break;
                case 'all': dayTypeText = 'Todos os dias'; break;
            }
            
            // Criar exibição dos tipos de veículos afetados
            const vehiclesAffected = restriction.affectedVehicles || [];
            const vehiclesDisplay = vehiclesAffected.length > 0 
                ? `<div class="affected-vehicles">Afeta: ${vehiclesAffected.map(v => {
                    switch(v) {
                        case 'truck1': return 'Caminhão 1 eixo';
                        case 'truck2': return 'Caminhão 2 eixos';
                        case 'truck3': return 'Caminhão 3+ eixos';
                        case 'all': return 'Todos os caminhões';
                        default: return v;
                    }
                  }).join(', ')}</div>` 
                : '';
                
            // Verificar se a cidade está no percurso atual
            let estaNoPercurso = false;
            
            // No GitHub Pages, definimos diretamente a posição na rota com base no ID
            if (isGitHubPages) {
                // No GitHub Pages, todas as restrições estão no percurso
                estaNoPercurso = true;
                
                // Definir posição diretamente pelo ID da restrição
                // Isso é mais confiável porque nossas restrições controladas seguem essa ordem
                posicaoNaRota = restriction.id;
            } else {
                // Modo normal: verificar se a cidade está no percurso atual
                estaNoPercurso = citiesOnRoute.some(city => {
                    if (!city) return false;
                    return city.toLowerCase() === restriction.cityName.toLowerCase() ||
                           city.toLowerCase().includes(restriction.cityName.toLowerCase()) ||
                           restriction.cityName.toLowerCase().includes(city.toLowerCase());
                });
            }
            
            // Estilo especial para cidades que estão realmente no percurso
            const cidadeStyle = estaNoPercurso 
                ? 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px;' 
                : '';
            
            // No GitHub Pages, adicionamos informação da posição na rota
            let posicaoNaRotaTexto = '';
            let posicaoStyle = '';
            
            if (isGitHubPages && typeof posicaoNaRota !== 'undefined' && posicaoNaRota > 0) {
                // Gerar texto da posição na rota
                if (posicaoNaRota === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">Origem</span>';
                } else {
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">${posicaoNaRota}ª</span>`;
                }
                
                // Adicionar margem para o texto de posição
                posicaoStyle = 'display: flex; align-items: center;';
            }
            
            // Ícone para indicar se a cidade está no percurso
            const percursoIcon = estaNoPercurso && !isGitHubPages
                ? '<span style="color: #1976D2; margin-left: 5px;">✓</span>' 
                : '';
            
            restrictionItem.innerHTML = `
                <div class="restriction-city" style="${cidadeStyle} ${posicaoStyle}">
                    ${isGitHubPages ? posicaoNaRotaTexto : ''}
                    ${restriction.cityName} ${percursoIcon}
                    <span class="restriction-type ${restriction.restrictionType}">${restriction.restrictionType === 'partial' ? 'Parcial' : (restriction.restrictionType === 'total' ? 'Total' : 'Rodízio')}</span>
                </div>
                <div class="restriction-time">${dayTypeText} | ${restriction.startTime} - ${restriction.endTime}</div>
                <div class="restriction-description">${restriction.description}</div>
                ${vehiclesDisplay}
                ${estaNoPercurso && !isGitHubPages ? '<div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">✓ Esta cidade está no seu percurso</div>' : ''}
            `;
            
            restrictionsListContainer.appendChild(restrictionItem);
        });
    }

    // Alternar entre as rotas alternativas
    function switchAlternativeRoute(routeIndex) {
        if (routeIndex < 0 || routeIndex >= alternativeRoutes.length) {
            console.error("Índice de rota inválido:", routeIndex);
            return;
        }
        
        console.log(`Alternando para rota alternativa ${routeIndex}`);
        console.log("Rotas alternativas disponíveis:", alternativeRoutes);
        
        // Salvar o índice atual
        currentRouteIndex = routeIndex;
        
        // Limpar rota atual
        clearRoute();
        
        // Usar a rota selecionada
        const tspResult = alternativeRoutes[routeIndex];
        
        if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path)) {
            console.error("Rota alternativa inválida:", tspResult);
            // Substituir alert por notificação inline mais suave
            const notifyError = document.createElement('div');
            notifyError.className = 'alert alert-warning mt-2';
            notifyError.innerHTML = `Erro: a rota selecionada é inválida`;
            document.querySelector('.route-controls').appendChild(notifyError);
            
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyError && notifyError.parentNode) {
                    notifyError.parentNode.removeChild(notifyError);
                }
            }, 5000);
            return;
        }
        
        console.log("Usando rota com caminhos:", tspResult.path);
        
        // Reordenar os marcadores visualmente para corresponder à nova sequência
        // Usar pathIds se disponível, ou path como fallback
        reorderMarkers(tspResult.pathIds || tspResult.path);
            
        // Traçar a rota usando o Google Directions Service
        drawRouteOnMap(tspResult.pathIds || tspResult.path, "truck1");
            
        // Mostrar pontos de interesse ao longo da rota
        showPointsOfInterestOnRoute(tspResult.pathIds || tspResult.path);
            
        // Mostrar eventos nas cidades da rota - pegando as datas do filtro
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        console.log("Chamando showEventsForCitiesOnRoute com datas:", startDate, endDate);
        showEventsForCitiesOnRoute(tspResult.pathIds || tspResult.path, startDate, endDate);
            
        // Mostrar restrições para caminhões nas cidades da rota
        showTruckRestrictionsForCitiesOnRoute(tspResult.pathIds || tspResult.path, null); // null para mostrar todos os tipos
            
        // Atualizar o resumo da rota
        updateRouteSummary(tspResult, "truck1", routeIndex);
        
        // Habilitar botões de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
    }
    
    // Atualizar detalhes das rotas nos cards
    function updateRouteCardDetails(routes) {
        console.log("Atualizando detalhes das rotas alternativas:", routes);
        if (!routes || routes.length === 0) {
            console.log("Nenhuma rota para atualizar");
            return;
        }
        
        // Usar a função centralizada de pós-processamento para garantir consistência
        const standardizedRoutes = postProcessTspResults(routes);
        
        standardizedRoutes.forEach((route, index) => {
            const detailsElement = document.getElementById(`route-${index}-details`);
            const cardElement = document.getElementById(`route-card-${index}`);
            
            if (detailsElement && route) {
                // Verificar se temos distância e tempo definidos
                let distanceStr = "N/A";
                let timeStr = "N/A";
                
                // Formatar distância sempre com verificação de tipo
                try {
                    const distance = parseFloat(route.totalDistance);
                    if (!isNaN(distance)) {
                        distanceStr = (distance < 1) ? 
                            `${Math.round(distance * 1000)} m` : 
                            `${distance.toFixed(1)} km`;
                    }
                } catch (e) {
                    console.error("Erro ao formatar distância:", e);
                }
                
                // Formatar tempo sempre com verificação de tipo
                try {
                    if (route.estimatedTime !== undefined && route.estimatedTime !== null) {
                        timeStr = formatTravelTime(route.estimatedTime);
                    }
                } catch (e) {
                    console.error("Erro ao formatar tempo:", e);
                }
                
                // Atualizar detalhes no card
                detailsElement.innerHTML = `
                    <span class="me-2"><i class="bi bi-truck"></i> ${distanceStr}</span>
                    <span><i class="bi bi-clock"></i> ${timeStr}</span>
                `;
                
                // Mostrar o card
                if (cardElement) {
                    cardElement.style.display = 'block';
                }
            } else {
                console.log(`Elemento de detalhes não encontrado para rota ${index}`);
            }
        });
        
        // Esconder cards não utilizados
        for (let i = standardizedRoutes.length; i < 3; i++) {
            const unusedCard = document.getElementById(`route-card-${i}`);
            if (unusedCard) {
                unusedCard.style.display = 'none';
            }
        }
    }
    
    // Função centralizada para calcular tempo com velocidade padrão
    function calculateTravelTime(distanceInKm) {
        if (!distanceInKm || distanceInKm <= 0 || isNaN(distanceInKm)) {
            console.warn("Distância inválida para cálculo de tempo:", distanceInKm);
            return 0;
        }
        // Velocidade padrão de 80km/h (solicitação do usuário)
        const speedKmh = 80;
        // Tempo em minutos: (distância / velocidade) * 60
        return (distanceInKm / speedKmh) * 60;
    }
    
    // Função auxiliar para formatação de tempo
    function formatTravelTime(minutes) {
        // Verificar se o tempo é válido
        if (minutes === undefined || minutes === null || isNaN(minutes)) {
            return "N/A";
        }
        
        if (minutes < 60) {
            return `${Math.round(minutes)} min`;
        } else {
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            return `${hours}h ${mins}min`;
        }
    }
    
    // Função removida - substituída pela função centralizada postProcessTspResults
    
    // Função para processar todos os resultados TSP finais e garantir cálculos consistentes
    function postProcessTspResults(tspResults) {
        console.log("Pós-processando resultados TSP:", tspResults);
        
        if (!tspResults || !Array.isArray(tspResults) || tspResults.length === 0) {
            console.warn("Sem resultados TSP para processar");
            return [];
        }
        
        return tspResults.map(result => {
            if (!result) return null;
            
            // Certificar que temos valores válidos de distância
            if (!result.distance || isNaN(result.distance) || result.distance <= 0) {
                console.warn("Resultado TSP com distância inválida ou zero:", result);
                result.distance = Math.max(result.totalDistance || 0, 50); // valor mínimo seguro
            }
            
            // Padronizar como lidamos com a distância total
            if (!result.totalDistance && result.distance) {
                result.totalDistance = result.distance;
            }
            
            // Recalcular o tempo usando a função centralizada (80 km/h)
            result.time = calculateTravelTime(result.distance);
            result.estimatedTime = result.time;
            
            // Garantir que pathIds esteja disponível se path estiver presente
            if (result.path && (!result.pathIds || !Array.isArray(result.pathIds))) {
                result.pathIds = result.path.map(item => {
                    return typeof item === 'object' && item !== null ? 
                        (item.id !== undefined ? item.id : item) : item;
                });
            }
            
            console.log(`Rota processada: ${result.distance.toFixed(1)}km / ${result.time.toFixed(1)} minutos`);
            return result;
        }).filter(result => result !== null);
    }
    
    // Função para gerar rotas alternativas
    function generateAlternativeRoutes(origin, destinations, includeOriginReturn) {
        // Limpar o array de rotas alternativas
        alternativeRoutes = [];
        
        // Limpar o seletor de rotas alternativas na sidebar (para compatibilidade)
        const alternativeSelectSidebar = document.getElementById('alternative-routes-sidebar');
        if (alternativeSelectSidebar) {
            alternativeSelectSidebar.innerHTML = '';
            const defaultOptionSidebar = document.createElement('option');
            defaultOptionSidebar.value = "0";
            defaultOptionSidebar.text = "Rota Otimizada (Padrão)";
            defaultOptionSidebar.selected = true;
            alternativeSelectSidebar.appendChild(defaultOptionSidebar);
        }
        
        // Resetar seleção visual nos cards
        document.querySelectorAll('.route-option-card').forEach(card => {
            card.classList.remove('selected');
        });
        const defaultCard = document.getElementById('route-card-0');
        if (defaultCard) {
            defaultCard.classList.add('selected');
        }
        
        // 1. Rota principal (otimizada pelo algoritmo principal)
        console.log("Gerando rota principal otimizada...");
        const mainRoute = solveAdvancedTSP(origin, destinations, includeOriginReturn);
        alternativeRoutes.push(mainRoute);
        
        // Só criar rotas alternativas se houver mais de 2 destinos
        if (destinations.length >= 2) {
            try {
                // 2. Rota alternativa - Proximidade à origem
                console.log("Gerando rota alternativa 1: Proximidade à origem...");
                const originProximityRoute = solveOriginProximityTSP(origin, destinations, includeOriginReturn);
                alternativeRoutes.push(originProximityRoute);
                
                // Adicionar opção ao select da sidebar
                const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                if (alternativeSidebar) {
                    const option1 = document.createElement('option');
                    option1.value = "1";
                    option1.text = "Rota Alternativa 1 (Proximidade à Origem)";
                    alternativeSidebar.appendChild(option1);
                    
                    // Atualizar card da rota alternativa 1
                    const cardRoute1 = document.getElementById('route-card-1');
                    if (cardRoute1) {
                        // Mostrar o card
                        cardRoute1.style.display = 'block';
                        
                        // Atualizar título
                        const titleElement = cardRoute1.querySelector('strong');
                        if (titleElement) {
                            titleElement.textContent = "Proximidade à origem";
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota por proximidade:", error);
            }
            
            try {
                // 3. Rota alternativa - Caminho em espiral (se tiver 3+ destinos)
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 2: Padrão espiral...");
                    const spiralRoute = solveSpiralTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(spiralRoute);
                    
                    // Adicionar opção ao select da sidebar
                    const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                    if (alternativeSidebar) {
                        const option2 = document.createElement('option');
                        option2.value = "2";
                        option2.text = "Rota Alternativa 2 (Padrão Espiral)";
                        alternativeSidebar.appendChild(option2);
                        
                        // Atualizar card da rota alternativa 2
                        const cardRoute2 = document.getElementById('route-card-2');
                        if (cardRoute2) {
                            // Mostrar o card
                            cardRoute2.style.display = 'block';
                            
                            // Atualizar título
                            const titleElement = cardRoute2.querySelector('strong');
                            if (titleElement) {
                                titleElement.textContent = "Padrão espiral";
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota em espiral:", error);
            }
            
            try {
                // 4. Rota alternativa - Prioridade por cidade (se tiver 4+ destinos)
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 3: Agrupamento por cidade...");
                    const cityPriorityRoute = solveCityPriorityTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(cityPriorityRoute);
                    const routeIndex = alternativeRoutes.length - 1;
                    
                    // Adicionar opção ao select da sidebar
                    const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                    if (alternativeSidebar) {
                        const cityOption = document.createElement('option');
                        cityOption.value = routeIndex.toString();
                        cityOption.text = `Rota Alternativa ${routeIndex} (Agrupamento por Cidade)`;
                        alternativeSidebar.appendChild(cityOption);
                        
                        // Para cada rota alternativa extra, criar ou atualizar card correspondente
                        if (routeIndex >= 3) {
                            // Verificar se já existe card para essa rota
                            let cardRouteCity = document.getElementById(`route-card-${routeIndex}`);
                            
                            // Se não existir, criar novo card
                            if (!cardRouteCity) {
                                // Clonar o template do card 2
                                const templateCard = document.getElementById('route-card-2');
                                if (templateCard && templateCard.parentNode) {
                                    cardRouteCity = templateCard.cloneNode(true);
                                    cardRouteCity.id = `route-card-${routeIndex}`;
                                    cardRouteCity.setAttribute('data-route', routeIndex.toString());
                                    
                                    // Atualizar o ID do elemento de detalhes
                                    const detailsElement = cardRouteCity.querySelector('[id^="route-"]');
                                    if (detailsElement) {
                                        detailsElement.id = `route-${routeIndex}-details`;
                                    }
                                    
                                    // Adicionar ao container
                                    templateCard.parentNode.appendChild(cardRouteCity);
                                    
                                    // Adicionar evento de clique
                                    cardRouteCity.addEventListener('click', function() {
                                        const routeIdx = parseInt(this.getAttribute('data-route'));
                                        
                                        // Atualizar seleção visual
                                        document.querySelectorAll('.route-option-card').forEach(c => {
                                            c.classList.remove('selected');
                                        });
                                        this.classList.add('selected');
                                        
                                        // Atualizar o select escondido
                                        const selectElement = document.getElementById('alternative-routes-sidebar');
                                        if (selectElement) {
                                            selectElement.value = routeIdx.toString();
                                            
                                            // Disparar evento de mudança
                                            const event = new Event('change');
                                            selectElement.dispatchEvent(event);
                                        }
                                    });
                                }
                            }
                            
                            // Atualizar título e exibir card
                            if (cardRouteCity) {
                                cardRouteCity.style.display = 'block';
                                const titleElement = cardRouteCity.querySelector('strong');
                                if (titleElement) {
                                    titleElement.textContent = "Agrupamento por cidade";
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota por cidade:", error);
            }
        }
        
        // Mostrar o seletor de rotas alternativas na sidebar se houver mais de uma rota
        const routeAlternativesSidebarEl = document.getElementById('route-alternatives-sidebar');
        if (routeAlternativesSidebarEl) {
            routeAlternativesSidebarEl.style.display = alternativeRoutes.length > 1 ? 'block' : 'none';
            console.log('Exibindo seletor de rotas alternativas na sidebar:', alternativeRoutes.length > 1);
            
            // Usar nossa função centralizada de pós-processamento para garantir consistência
            alternativeRoutes = postProcessTspResults(alternativeRoutes);
            
            // Atualizar detalhes nos cards de rotas alternativas
            updateRouteCardDetails(alternativeRoutes);
        }
        
        // Evento para o select de rotas alternativas já configurado na inicialização
        
        // Retornar a rota principal (a primeira no array)
        return alternativeRoutes[0];
    }
    
    // Algoritmo TSP baseado em proximidade à origem
    function solveOriginProximityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Ordenar destinos por distância à origem (do mais próximo ao mais distante)
            const sortedDestinations = [...destinations].sort((a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            });
            
            // Construir o caminho
            const path = [origin.id];
            // Criar um array separado para IDs primitivos
            const pathIds = [String(origin.id)];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem de proximidade à origem
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                pathIds.push(String(dest.id));
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                pathIds.push(String(origin.id));
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                pathIds: pathIds,
                totalDistance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP por proximidade à origem:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP em padrão espiral (norte, leste, sul, oeste)
    function solveSpiralTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por quadrante em relação à origem
            const northEast = [];
            const southEast = [];
            const southWest = [];
            const northWest = [];
            
            for (const dest of destinations) {
                if (dest.latitude >= origin.latitude) {
                    // Norte
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        northEast.push(dest);
                    } else {
                        // Oeste
                        northWest.push(dest);
                    }
                } else {
                    // Sul
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        southEast.push(dest);
                    } else {
                        // Oeste
                        southWest.push(dest);
                    }
                }
            }
            
            // Ordenar cada quadrante pela distância à origem
            const sortByDistanceToOrigin = (a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            };
            
            northEast.sort(sortByDistanceToOrigin);
            southEast.sort(sortByDistanceToOrigin);
            southWest.sort(sortByDistanceToOrigin);
            northWest.sort(sortByDistanceToOrigin);
            
            // Construir caminho em espiral: NE -> SE -> SW -> NW
            const sortedDestinations = [...northEast, ...southEast, ...southWest, ...northWest];
            
            // Construir o caminho
            const path = [origin.id];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem espiral
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP em padrão espiral:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP com prioridade por cidade (agrupar pontos da mesma cidade)
    function solveCityPriorityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por cidade
            const citiesMap = new Map();
            
            for (const dest of destinations) {
                const cityName = dest.address.split(',')[0].trim();
                if (!citiesMap.has(cityName)) {
                    citiesMap.set(cityName, []);
                }
                citiesMap.get(cityName).push(dest);
            }
            
            // Converter para array e ordenar cidades pela proximidade à origem
            const cities = Array.from(citiesMap.entries()).map(([cityName, cityDests]) => {
                // Calcular distância média da cidade à origem
                const avgDistance = cityDests.reduce((sum, dest) => {
                    return sum + calculateDistance(origin.latitude, origin.longitude, dest.latitude, dest.longitude);
                }, 0) / cityDests.length;
                
                return {
                    name: cityName,
                    destinations: cityDests,
                    avgDistanceToOrigin: avgDistance
                };
            });
            
            // Ordenar cidades pela distância média à origem
            cities.sort((a, b) => a.avgDistanceToOrigin - b.avgDistanceToOrigin);
            
            // Construir caminho visitando todas as cidades em ordem de proximidade
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("ID de origem usado no caminho:", originId, "Tipo:", typeof originId);
            
            const path = [originId];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Para cada cidade, visitar todos os seus pontos
            for (const city of cities) {
                // Ordenar pontos da cidade pelo mais próximo ao ponto atual
                city.destinations.sort((a, b) => {
                    const distA = calculateDistance(currentLocation.latitude, currentLocation.longitude, a.latitude, a.longitude);
                    const distB = calculateDistance(currentLocation.latitude, currentLocation.longitude, b.latitude, b.longitude);
                    return distA - distB;
                });
                
                // Adicionar pontos da cidade ao caminho
                for (const dest of city.destinations) {
                    // Converter o ID para string para consistência
                    const destId = String(dest.id);
                    console.log(`Adicionando destino ${dest.name} com ID:`, destId, "Tipo:", typeof destId);
                    
                    path.push(destId);
                    const dist = calculateDistance(
                        currentLocation.latitude, currentLocation.longitude,
                        dest.latitude, dest.longitude
                    );
                    totalDistance += dist;
                    currentLocation = dest;
                }
            }
            
            // Adicionar retorno à origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em média)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP com prioridade por cidade:", error);
            return {
                path: [origin.id],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Atualizar o resumo da rota
    function updateRouteSummary(tspResult, vehicleType, routeIndex = 0) {
        try {
            console.log("Atualizando resumo da rota com:", tspResult);
            
            // Verificar se temos resultados válidos
            if (!tspResult || typeof tspResult.distance !== 'number' || isNaN(tspResult.distance)) {
                console.error("Dados incompletos ou inválidos do TSP:", tspResult);
                
                // Adicionar um valor padrão para distância se não for válido
                if (!tspResult.distance || isNaN(tspResult.distance)) {
                    console.log("Corrigindo valor de distância");
                    
                    // Calcular uma distância aproximada com base nos pontos
                    let approxDistance = 0;
                    if (tspResult && tspResult.path && tspResult.path.length > 1) {
                        for (let i = 0; i < tspResult.path.length - 1; i++) {
                            const p1 = tspResult.path[i];
                            const p2 = tspResult.path[i+1];
                            approxDistance += calculateDistance(
                                p1.latitude, p1.longitude,
                                p2.latitude, p2.longitude
                            );
                        }
                        tspResult.distance = approxDistance;
                        console.log("Distância recalculada:", approxDistance, "km");
                    } else {
                        tspResult.distance = 0;
                    }
                }
            }
            
            // Veículo fixo (caminhão 1 eixo)
            const selectedVehicle = {
                name: "Caminhão",
                averageSpeed: 80 // km/h - velocidade média ajustada para 80km/h conforme solicitado
            };
            
            // Tempo estimado usando nossa função centralizada (em minutos)
            const estimatedTime = calculateTravelTime(tspResult.distance) / 60; // convertendo de minutos para horas
            
            // Atualizar o conteúdo do resumo
            const summaryContainer = document.getElementById('route-summary');
            if (!summaryContainer) {
                console.error("Elemento 'route-summary' não encontrado");
                return;
            }
            
            summaryContainer.style.display = 'block';
            
            // Formatar o tempo em horas e minutos
            const hours = Math.floor(estimatedTime);
            const minutes = Math.round((estimatedTime - hours) * 60);
            const timeFormatted = hours > 0 ? 
                                `${hours}h ${minutes}min` : 
                                `${minutes}min`;
            
            console.log("Distância calculada:", tspResult.distance.toFixed(1), "km");
            console.log("Tempo estimado:", timeFormatted);
            
            // Construir a lista de cidades na rota
            let locationsList = '';
            
            // Verificar se temos path válido
            if (tspResult.path && tspResult.path.length > 0) {
                // Criar a lista de locais na ordem da rota
                // Primeiro, obter objetos completos de location para cada ID no path
                const orderedLocations = [];
                tspResult.path.forEach(locationId => {
                    const id = String(locationId);
                    const location = locations.find(loc => String(loc.id) === id);
                    if (location) {
                        orderedLocations.push(location);
                    } else {
                        console.error(`Localização não encontrada para ID: ${id}`);
                    }
                });
                
                // Agora criar a lista formatada com as localizações ordenadas
                locationsList = orderedLocations.map(location => {
                    // Garantir que os nomes estão formatados corretamente
                    const locationName = formatLocationName(location.name || '');
                    const locationAddress = formatLocationName(location.address || '');
                    
                    // Verificar se é origem para destacar
                    if (location.isOrigin) {
                        return `<li class="origin-point" data-id="${location.id}">${locationName} ${locationAddress ? `(${locationAddress})` : ''} (Origem)</li>`;
                    } else {
                        return `<li data-id="${location.id}"><strong>${locationName}</strong> ${locationAddress ? `(${locationAddress})` : ''}</li>`;
                    }
                }).join('');
            } else {
                locationsList = '<li>Nenhum local encontrado na rota</li>';
            }
        
            // Determinar rótulo da rota alternativa
            let routeLabel = "";
            if (routeIndex > 0) {
                routeLabel = ` (Alternativa ${routeIndex})`;
            }
            
            summaryContainer.innerHTML = `
                <div class="summary-header">Resumo da Rota${routeLabel}</div>
                <div class="row">
                    <div class="col-12">
                        <p><strong>Distância total:</strong> ${tspResult.distance.toFixed(1)} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeFormatted}</p>
                    </div>
                </div>
                
                <div class="mt-3">
                    <div class="summary-header">Sequência da Rota</div>
                    <ol id="route-steps">
                        ${locationsList}
                    </ol>
                </div>
                
                <!-- Campo "Nome da rota" removido daqui para evitar duplicação, já existe na aba relatório -->
                
            `;
            
            // Habilitar botões de salvar e imprimir
            document.getElementById('save-route').disabled = false;
            document.getElementById('print-route').disabled = false;
            
        } catch (error) {
            console.error("Erro ao atualizar resumo da rota:", error, error.stack);
            
            // Em caso de erro, mostrar mensagem simplificada
            const summaryContainer = document.getElementById('route-summary');
            if (summaryContainer) {
                summaryContainer.innerHTML = `
                    <div class="alert alert-danger">
                        Ocorreu um erro ao processar o resumo da rota. Por favor, tente novamente.
                    </div>
                `;
                summaryContainer.style.display = 'block';
            }
        }
    }
    
    // Função para extrair a data de fundação e retornar com o ano atual
    function extrairDataFundacao(descricao) {
        try {
            // Obter ano atual
            const anoAtual = new Date().getFullYear();
            
            // Extrair a data de fundação da descrição
            // Por exemplo: "Aniversário de fundação de Dois Córregos em 04/02/1883"
            const regex = /(\d{2})\/(\d{2})\/\d{4}/;
            const match = descricao.match(regex);
            
            if (match) {
                // Formato é dia/mês/ano
                const dia = match[1];
                const mes = match[2];
                
                // Retorna a data no formato brasileiro com o ano atual
                return `${dia}/${mes}/${anoAtual}`;
            }
            
            return "Data não encontrada";
        } catch (error) {
            console.error("Erro ao extrair data de fundação:", error);
            return "Erro na data";
        }
    }

    // Função especializada para verificar e corrigir problemas com datas
    function ensureValidDateFormat(dateStr) {
        if (!dateStr) return null;
        
        try {
            // Tentar criar um objeto Date diretamente
            let dateObj = new Date(dateStr);
            
            // Verificar se é uma data válida
            if (!isNaN(dateObj.getTime())) {
                return dateObj;
            }
            
            // Tentar formatos comuns
            if (dateStr.includes('/')) {
                // Formato MM/DD/YYYY ou DD/MM/YYYY
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    // Assumir MM/DD/YYYY (formato comum nos EUA)
                    dateObj = new Date(parts[2], parts[0]-1, parts[1]);
                    
                    // Se ainda for inválido, tentar DD/MM/YYYY (formato brasileiro)
                    if (isNaN(dateObj.getTime())) {
                        dateObj = new Date(parts[2], parts[1]-1, parts[0]);
                    }
                    
                    if (!isNaN(dateObj.getTime())) {
                        return dateObj;
                    }
                }
            }
            
            // Tentar formato ISO sem hora
            if (dateStr.includes('-') && dateStr.length === 10) {
                // Formato YYYY-MM-DD
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    dateObj = new Date(parts[0], parts[1]-1, parts[2]);
                    if (!isNaN(dateObj.getTime())) {
                        return dateObj;
                    }
                }
            }
            
            console.error("Nenhum formato de data conhecido funcionou para:", dateStr);
            return null;
        } catch (e) {
            console.error("Erro ao processar data:", e);
            return null;
        }
    }

    // Filtrar eventos por data - atualiza automaticamente ao mudar datas
    function filterEventsByDate() {
        console.log("==========================================");
        console.log("FILTRO DE EVENTOS POR DATA SOLICITADO");
        console.log("==========================================");
        
        // Obter valores atuais das datas para filtro
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        
        // Verificação de segurança para GitHub Pages
        if (!startDateInput || !endDateInput) {
            console.error("Campos de data não encontrados no DOM");
            
            // Tentar criar os campos se estiverem ausentes (para GitHub Pages)
            try {
                // Verificar se temos o container de datas
                const dateContainer = document.querySelector('.date-filters');
                if (dateContainer) {
                    if (!startDateInput) {
                        const newStartInput = document.createElement('input');
                        newStartInput.type = 'date';
                        newStartInput.id = 'start-date';
                        newStartInput.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newStartInput);
                        console.log("Criado campo de data inicial ausente");
                    }
                    
                    if (!endDateInput) {
                        const newEndInput = document.createElement('input');
                        newEndInput.type = 'date';
                        newEndInput.id = 'end-date';
                        newEndInput.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newEndInput);
                        console.log("Criado campo de data final ausente");
                    }
                }
            } catch (e) {
                console.error("Falha ao criar campos de data:", e);
            }
            
            // Tentar novamente após recriação
            const retriedStartInput = document.getElementById('start-date');
            const retriedEndInput = document.getElementById('end-date');
            
            if (!retriedStartInput || !retriedEndInput) {
                console.error("Impossível recuperar campos de data, mesmo após tentativa de criação");
                return;
            } else {
                console.log("Campos de data recuperados após recriação");
                startDateInput = retriedStartInput;
                endDateInput = retriedEndInput;
            }
        }
        
        // Obter datas do filtro
        let startDateStr = startDateInput.value;
        let endDateStr = endDateInput.value;
        
        // Validar datas de filtro
        if (!startDateStr || !endDateStr) {
            console.warn("Pelo menos uma das datas de filtro está vazia:", {start: startDateStr, end: endDateStr});
            
            // Atribuir valores padrão se as datas estiverem vazias
            const today = new Date();
            const oneWeekLater = new Date();
            oneWeekLater.setDate(today.getDate() + 7);
            
            // Converter para formato YYYY-MM-DD
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            // Atualizar elementos do formulário apenas se estiverem vazios
            if (!startDateStr) {
                startDateStr = formatDate(today);
                startDateInput.value = startDateStr;
                console.log("Data inicial ajustada para hoje:", startDateStr);
            }
            
            if (!endDateStr) {
                endDateStr = formatDate(oneWeekLater);
                endDateInput.value = endDateStr;
                console.log("Data final ajustada para uma semana depois:", endDateStr);
            }
        }
        
        console.log(`Datas finais para filtragem: ${startDateStr} até ${endDateStr}`);
        
        let routeIds = [];
        
        // Se tivermos uma rota otimizada atual, usar os pontos dessa rota
        if (currentOptimizedPath && currentOptimizedPath.length > 0) {
            console.log("Usando rota otimizada atual:", currentOptimizedPath);
            routeIds = [...currentOptimizedPath]; // Clonar para não modificar o original
        } else if (directionsRenderer && directionsRenderer.getDirections()) {
            // Se tivermos uma rota no renderer mas não otimizada, usar locais atuais
            console.log("Usando locais atuais como rota");
            routeIds = locations.map(loc => loc.id);
        } else {
            // Se não tivermos rota, mostrar apenas para origem
            console.log("Sem rota, mostrando apenas para origem");
            // Mostrar notificação para indicar que é necessário calcular uma rota
            const notifyInfo = document.createElement('div');
            notifyInfo.className = 'alert alert-info mt-2';
            notifyInfo.innerHTML = `Calcule uma rota primeiro para ver os eventos e restrições no percurso.`;
            // Usar a primeira aba inferior ativa como container para notificação
            const tabContent = document.querySelector('.bottom-tab-content.active');
            if (tabContent) {
                tabContent.appendChild(notifyInfo);
            } else {
                // Fallback para a seção de otimização caso as abas não existam
                const optimizeSection = document.querySelector('.optimize-btn-container');
                if (optimizeSection) {
                    optimizeSection.appendChild(notifyInfo);
                }
            }
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyInfo && notifyInfo.parentNode) {
                    notifyInfo.parentNode.removeChild(notifyInfo);
                }
            }, 5000);
        }
        
        // Se ainda não temos IDs de rota, usar pelo menos a origem
        if (!routeIds || routeIds.length === 0) {
            routeIds = [mockData.origin.id];
            console.log("Usando apenas a origem para eventos:", routeIds);
        }
        
        // Mostrar eventos para as cidades da rota com filtro por data
        console.log("Chamando showEventsForCitiesOnRoute de filterEventsByDate com datas:", startDateStr, endDateStr);
        showEventsForCitiesOnRoute(routeIds, startDateStr, endDateStr);
        
        // Mostrar restrições para TODOS os tipos de caminhões nas cidades da rota
        // Passando null para indicar que queremos mostrar para todos os tipos
        showTruckRestrictionsForCitiesOnRoute(routeIds, null);
    }

    // Salvar a rota
    function saveRoute() {
        // Verificar primeiro o campo no relatório principal
        let routeName = document.getElementById('report-route-name').value;
        
        // Se estiver vazio, verificar o campo no modal
        if (!routeName) {
            routeName = document.getElementById('route-name-modal').value;
        }
        
        if (!routeName) {
            // Substituir alert por notificação inline mais suave
            const notifyWarning = document.createElement('div');
            notifyWarning.className = 'alert alert-warning mt-2';
            notifyWarning.innerHTML = `Por favor, dê um nome para a rota antes de salvar.`;
            document.querySelector('.route-controls').appendChild(notifyWarning);
            
            // Remover a notificação após alguns segundos
            setTimeout(() => {
                if (notifyWarning && notifyWarning.parentNode) {
                    notifyWarning.parentNode.removeChild(notifyWarning);
                }
            }, 5000);
            return;
        }
        
        // Substituir alert por notificação inline mais suave
        const notifySuccess = document.createElement('div');
        notifySuccess.className = 'alert alert-success mt-2';
        notifySuccess.innerHTML = `Rota "${routeName}" salva com sucesso!`;
        document.querySelector('.route-controls').appendChild(notifySuccess);
        
        // Remover a notificação após alguns segundos
        setTimeout(() => {
            if (notifySuccess && notifySuccess.parentNode) {
                notifySuccess.parentNode.removeChild(notifySuccess);
            }
        }, 5000);
    }

    // Imprimir a rota
    function printRoute() {
        window.print();
    }

    // Zoom para mostrar todos os marcadores
    function zoomToFitAllMarkers() {
        if (markers.length === 0) return;
        
        const bounds = new google.maps.LatLngBounds();
        markers.forEach(markerObj => {
            bounds.extend(markerObj.marker.getPosition());
        });
        
        map.fitBounds(bounds);
    }

    // Alternador para mostrar/esconder pontos de interesse
    function togglePointsOfInterest() {
        showPOIs = !showPOIs;
        
        // Ajustar visibilidade dos marcadores
        poiMarkers.forEach(marker => {
            marker.setVisible(showPOIs);
        });
        
        // Se tivermos uma rota ativa e quisermos mostrar POIs, recarregar os POIs
        if (showPOIs && directionsRenderer.getDirections()) {
            showPointsOfInterestOnRoute(locations);
        }
    }

    // Criar tooltip personalizado
    function createCustomTooltip() {
        try {
            // Criar elemento de tooltip
            customTooltip = document.createElement('div');
            customTooltip.className = 'custom-tooltip';
            customTooltip.style.display = 'none';
            
            // Verificar se o body existe antes de adicionar
            if (document.body) {
                document.body.appendChild(customTooltip);
                console.log("Tooltip personalizado criado com sucesso");
            } else {
                console.error("document.body não está disponível para adicionar o tooltip");
            }
        } catch (err) {
            console.error("Erro ao criar tooltip personalizado:", err);
        }
    }

    // Mostrar tooltip
    function showTooltip(marker, data) {
        // Se o dado tiver conteúdo de tooltip predefinido, usar esse
        if (data.tooltipContent) {
            customTooltip.innerHTML = data.tooltipContent;
        } else {
            // Caso contrário, construir baseado no tipo de ponto de interesse
            let content = `<div class="tooltip-title">${data.name}</div>`;
            
            if (data.type === 'toll') {
                content += `
                    <div>Pedágio na rodovia ${data.highway}</div>
                    <div>Valor: R$ ${data.cost.toFixed(2)}</div>
                `;
            } else if (data.type === 'weighStation') {
                content += `
                    <div>Balança na rodovia ${data.highway}</div>
                    <div>Status: ${data.isActive ? 'Ativa' : 'Inativa'}</div>
                `;
            } else if (data.type === 'gasStation') {
                content += `
                    <div>Posto de combustível</div>
                    <div>Serviços: ${formatServices(data.services)}</div>
                `;
            } else {
                content += `
                    <div>Ponto de interesse em ${data.cityName}</div>
                `;
            }
            
            customTooltip.innerHTML = content;
        }
        
        // Posicionar o tooltip acima do marcador
        const projection = map.getProjection();
        const position = marker.getPosition();
        const pixelOffset = overlay.getProjection().fromLatLngToDivPixel(position);
        
        customTooltip.style.left = pixelOffset.x + 'px';
        customTooltip.style.top = (pixelOffset.y - 120) + 'px'; // Posicionar acima do marcador
        customTooltip.style.display = 'block';
    }

    // Esconder tooltip
    function hideTooltip() {
        if (customTooltip) {
            customTooltip.style.display = 'none';
        }
    }

    // Formatar lista de serviços
    function formatServices(services) {
        if (!services || !Array.isArray(services)) return '';
        
        const serviceNames = {
            'food': 'Alimentação',
            'rest': 'Área de descanso',
            'shower': 'Chuveiro',
            'mechanic': 'Mecânico',
            'tire': 'Borracharia'
        };
        
        return services.map(s => serviceNames[s] || s).join(', ');
    }

    // Implementação avançada do algoritmo do Caixeiro Viajante (TSP)
    // Idêntico ao comportamento da versão Replit
    function solveAdvancedTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP avançado com", destinations.length, "destinos");
        
        // Se não houver destinos, retornar apenas a origem
        if (!destinations.length) {
            console.log("Sem destinos, retornando apenas origem");
            return {
                path: [origin],
                distance: 0
            };
        }
        
        // Verificar se os objetos têm as propriedades necessárias
        if (!origin.latitude || !origin.longitude) {
            console.error("Origem sem coordenadas:", origin);
            // Criar coordenadas padrão para Dois Córregos se não existirem
            origin.latitude = origin.latitude || -22.3673;
            origin.longitude = origin.longitude || -48.3822;
        }
        
        // Verificar e corrigir destinos sem coordenadas
        for (let i = 0; i < destinations.length; i++) {
            if (!destinations[i].latitude || !destinations[i].longitude) {
                console.error("Destino sem coordenadas:", destinations[i]);
                // Atribuir coordenadas aproximadas baseadas em Dois Córregos com deslocamento
                destinations[i].latitude = -22.3673 + (Math.random() - 0.5) * 0.1;
                destinations[i].longitude = -48.3822 + (Math.random() - 0.5) * 0.1;
            }
        }
        
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Verificar se há pontos na mesma cidade da origem
        // Se houver, devem ser visitados primeiro
        const sameCity = [];
        const otherCities = [];
        
        destinations.forEach(dest => {
            if (isSameCity(dest, origin)) {
                sameCity.push(dest);
            } else {
                otherCities.push(dest);
            }
        });
        
        // Se há pontos na mesma cidade, priorizá-los
        if (sameCity.length > 0) {
            // Colocar os pontos da mesma cidade primeiro, depois resolver o restante
            console.log(`Encontrado ${sameCity.length} pontos na mesma cidade da origem. Priorizando.`);
            
            // Calcular a distância para priorizar essa ordem
            let sameCityDist = 0;
            const sameCityPath = [origin, ...sameCity];
            
            for (let i = 0; i < sameCityPath.length - 1; i++) {
                const dist = calculateDistance(
                    sameCityPath[i].latitude, sameCityPath[i].longitude,
                    sameCityPath[i+1].latitude, sameCityPath[i+1].longitude
                );
                sameCityDist += dist;
                console.log(`Distância de ${sameCityPath[i].name} para ${sameCityPath[i+1].name}: ${dist.toFixed(1)} km`);
            }
            
            // Se não temos outros pontos, retornar apenas os da mesma cidade
            if (otherCities.length === 0) {
                console.log("Apenas pontos na mesma cidade, distância total:", sameCityDist.toFixed(1), "km");
                return {
                    path: sameCityPath,
                    distance: sameCityDist
                };
            }
            
            // Resolver o TSP para os outros pontos
            const otherResult = solveBasicTSP(sameCityPath[sameCityPath.length-1], otherCities, includeReturn);
            
            // Combinar os caminhos
            const fullPath = [...sameCityPath.slice(0, -1), ...otherResult.path];
            const fullDistance = sameCityDist + otherResult.distance;
            
            console.log("Combinando caminhos, distância na mesma cidade:", sameCityDist.toFixed(1), 
                       "km, distância para outras cidades:", otherResult.distance.toFixed(1), 
                       "km, total:", fullDistance.toFixed(1), "km");
            
            return {
                path: fullPath,
                distance: fullDistance
            };
        }
        
        const result = solveBasicTSP(origin, destinations, includeReturn);
        console.log("TSP básico, distância total:", result.distance.toFixed(1), "km");
        
        // Garantir que o caminho contém apenas IDs e não objetos completos
        if (result.path && Array.isArray(result.path)) {
            result.pathIds = result.path.map(loc => {
                if (typeof loc === 'object' && loc !== null && loc.id !== undefined) {
                    return loc.id;
                }
                return loc;
            });
            console.log("Caminho convertido para IDs:", result.pathIds);
        }
        
        return result;
    }
    
    // Versão básica do TSP para cidades diferentes
    function solveBasicTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP básico com", destinations.length, "destinos");
        
        // Verificar se existem pontos na mesma cidade que o último ponto antes de iniciar
        const sameCityPoints = destinations.filter(dest => isSameCity(dest, origin));
        if (sameCityPoints.length > 0) {
            console.log(`Encontrados ${sameCityPoints.length} pontos na mesma cidade que o ponto de partida (${origin.name}). Eles serão priorizados.`);
        }
        
        // Ordenar os destinos por proximidade da origem para priorizar a ordem
        let sortedDestinations = [...destinations].sort((a, b) => {
            // Se um está na mesma cidade da origem e o outro não, o da mesma cidade vem primeiro
            const aInSameCity = isSameCity(a, origin);
            const bInSameCity = isSameCity(b, origin);
            
            if (aInSameCity && !bInSameCity) return -1;
            if (!aInSameCity && bInSameCity) return 1;
            
            // Se ambos estão ou não na mesma cidade, ordenar por distância
            const distA = calculateDistance(
                origin.latitude, origin.longitude, 
                a.latitude, a.longitude
            );
            
            const distB = calculateDistance(
                origin.latitude, origin.longitude, 
                b.latitude, b.longitude
            );
            
            return distA - distB;
        });
        
        // Log da ordem pré-calculada
        console.log("Destinos ordenados por proximidade:", 
                   sortedDestinations.map((d, i) => 
                                         `${i+1}. ${d.name} (${isSameCity(d, origin) ? "mesma cidade, " : ""}${calculateDistance(
                                             origin.latitude, origin.longitude,
                                             d.latitude, d.longitude
                                         ).toFixed(1)} km)`).join(", "));
        
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Matriz de distâncias entre todos os pontos
        const points = [origin, ...sortedDestinations];
        const numPoints = points.length;
        const distMatrix = Array(numPoints).fill().map(() => Array(numPoints).fill(0));
        
        // Preencher a matriz de distâncias
        for (let i = 0; i < numPoints; i++) {
            for (let j = i + 1; j < numPoints; j++) {
                const dist = calculateDistance(
                    points[i].latitude, points[i].longitude,
                    points[j].latitude, points[j].longitude
                );
                distMatrix[i][j] = dist;
                distMatrix[j][i] = dist; // A matriz é simétrica
            }
        }
        
        // Método Nearest Insertion: começamos com a rota origem -> ponto mais próximo -> origem
        // e iterativamente adicionamos o melhor ponto para inserir na rota atual
        
        // Inicializar com o ponto mais próximo da origem
        let bestDist = Infinity;
        let bestIdx = -1;
        
        for (let i = 1; i < numPoints; i++) {
            if (distMatrix[0][i] < bestDist) {
                bestDist = distMatrix[0][i];
                bestIdx = i;
            }
        }
        
        // Rota inicial: origem -> ponto mais próximo
        let tour = [0, bestIdx];
        let remaining = Array.from({length: numPoints - 1}, (_, i) => i + 1);
        remaining.splice(remaining.indexOf(bestIdx), 1);
        
        // Calcular a distância inicial
        totalDistance = bestDist;
        
        // Usar a função auxiliar para completar o algoritmo
        const result = finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn);
        tour = result.tour;
        totalDistance = result.totalDistance;
        
        // Se não for para incluir retorno, remover o último link (do último ponto de volta à origem)
        if (!includeReturn && tour.length > 1) {
            const last = tour[tour.length - 1];
            totalDistance -= distMatrix[last][0];
            // Não removemos a origem do início porque a rota deve começar na origem
        }
        
        // Converter os índices de tour de volta para os pontos reais
        const path = tour.map(idx => points[idx]);
        
        // Ajustar a rota se não for para incluir retorno à origem
        if (!includeReturn) {
            // Garante que a rota não termine voltando para a origem
            if (path[path.length - 1] === origin) {
                path.pop();
            }
        } else {
            // Garante que a rota termine na origem
            if (path[path.length - 1] !== origin) {
                path.push(origin);
                
                // Adicionar a distância de retorno
                const lastPoint = path[path.length - 2];
                const returnDistance = calculateDistance(
                    lastPoint.latitude, lastPoint.longitude,
                    origin.latitude, origin.longitude
                );
                totalDistance += returnDistance;
            }
        }
        
        return {
            path: path,
            distance: totalDistance
        };
    }
    
    // Manteremos a versão simples para compatibilidade
    function solveTSP(origin, destinations, includeReturn) {
        return solveAdvancedTSP(origin, destinations, includeReturn);
    }
    
    // Função para finalizar o algoritmo TSP básico
    function finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn) {
        // Enquanto houver pontos não visitados
        while (remaining.length > 0) {
            let bestInsertion = {
                point: -1,
                position: -1,
                cost: Infinity
            };
            
            // Para cada ponto restante
            for (let i = 0; i < remaining.length; i++) {
                const point = remaining[i];
                
                // Para cada possível posição de inserção no tour atual
                for (let j = 1; j <= tour.length; j++) {
                    const prev = tour[j-1];
                    const next = j < tour.length ? tour[j] : tour[0]; // Se estamos no final, o próximo é o início
                    
                    // Calcular o custo de inserção = dist(prev, point) + dist(point, next) - dist(prev, next)
                    const insertionCost = distMatrix[prev][point] + 
                                         distMatrix[point][next] -
                                         distMatrix[prev][next];
                    
                    if (insertionCost < bestInsertion.cost) {
                        bestInsertion = {
                            point: point,
                            position: j,
                            cost: insertionCost
                        };
                    }
                }
            }
            
            // Inserir o melhor ponto na melhor posição
            tour.splice(bestInsertion.position, 0, bestInsertion.point);
            remaining.splice(remaining.indexOf(bestInsertion.point), 1);
            
            // Atualizar a distância total
            totalDistance += bestInsertion.cost;
        }
        
        return { tour, totalDistance };
    }

    // Calcular distância entre dois pontos usando a fórmula de Haversine
    function calculateDistance(lat1, lon1, lat2, lon2) {
        // Verificar se os parâmetros são válidos
        if (lat1 === undefined || lon1 === undefined || lat2 === undefined || lon2 === undefined) {
            console.error("Coordenadas inválidas no cálculo de distância:", lat1, lon1, lat2, lon2);
            return 10; // Valor padrão seguro para evitar distância zero
        }
        
        // Verificar se os valores são numéricos
        if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
            console.error("Coordenadas NaN no cálculo de distância:", lat1, lon1, lat2, lon2);
            return 15; // Valor padrão seguro para evitar distância zero
        }
        
        // Verificar se as coordenadas são idênticas (mesmo ponto)
        if (lat1 === lat2 && lon1 === lon2) {
            console.log("Coordenadas idênticas detectadas, retornando valor mínimo para mesma localização");
            return 0.1; // Distância mínima para evitar zero mas ainda indicar que é o mesmo ponto
        }
        
        try {
            const R = 6371; // Raio da Terra em km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const distance = R * c; // Distância em km
            
            // Verificar se a distância é válida
            if (isNaN(distance)) {
                console.error("Distância calculada NaN:", distance, "para coordenadas:", lat1, lon1, lat2, lon2);
                return 20; // Valor padrão seguro para evitar distância zero
            }
            
            // Verificar se a distância é zero ou muito próxima de zero
            if (distance <= 0 || distance < 0.001) {
                console.log("Distância calculada muito pequena:", distance, "usando valor mínimo seguro");
                return 0.1; // Valor mínimo seguro para evitar problemas no algoritmo
            }
            
            return distance;
        } catch (error) {
            console.error("Erro ao calcular distância:", error);
            return 25; // Valor padrão seguro em caso de erro
        }
    }

    // Converter graus para radianos
    function deg2rad(deg) {
        return deg * (Math.PI/180);
    }

    // Classe para projeção de overlay personalizado
    class OverlayProjection {
        fromLatLngToDivPixel(latLng) {
            const scale = Math.pow(2, map.getZoom());
            const proj = map.getProjection();
            const bounds = map.getBounds();
            
            if (!proj || !bounds) {
                return { x: 0, y: 0 };
            }
            
            const nw = proj.fromLatLngToPoint(
                new google.maps.LatLng(
                    bounds.getNorthEast().lat(),
                    bounds.getSouthWest().lng()
                )
            );
            
            const point = proj.fromLatLngToPoint(latLng);
            
            return {
                x: Math.floor((point.x - nw.x) * scale),
                y: Math.floor((point.y - nw.y) * scale)
            };
        }
        
        fromDivPixelToLatLng(pixel) {
            return null; // Não precisamos desta funcionalidade
        }
    }

    // Criar um overlay personalizado para a projeção
    const overlay = new google.maps.OverlayView();
    overlay.draw = function() {};
    overlay.setMap(map);
    overlay.getProjection = function() {
        return new OverlayProjection();
    };

    // Expor funções necessárias globalmente
    window.removeLocation = removeLocation;
    
    // Variáveis para controlar o modo de rota personalizada
    let customRouteMode = false;
    let dragItem = null;
    let dragOverItem = null;

    // Função para alternar o modo de rota personalizada
    function toggleCustomRouteMode() {
        customRouteMode = !customRouteMode;
        const locationsListElement = document.getElementById('locations-list');
        const customRouteButton = document.getElementById('custom-route');
        
        if (customRouteMode) {
            // Ativar modo de rota personalizada
            locationsListElement.classList.add('custom-route-active');
            customRouteButton.style.backgroundColor = '#ffc107';
            customRouteButton.style.borderColor = '#ffab00';
            
            // Identificar todos os itens não-origem
            const locationItems = locationsListElement.querySelectorAll('li:not(.origin-point)');
            
            // Adicionar HTML diretamente com botões para solução mais compatível
            locationItems.forEach(item => {
                // Criar o HTML para os botões de subir/descer
                const buttonsHTML = `
                    <span class="position-controls" style="margin-right: 10px;">
                        <button type="button" class="btn btn-sm move-up" style="padding: 2px 5px; margin-right: 2px; color: #ffc107; background-color: transparent; border: 1px solid #ffc107;" title="Mover para cima">⬆</button>
                        <button type="button" class="btn btn-sm move-down" style="padding: 2px 5px; color: #ffc107; background-color: transparent; border: 1px solid #ffc107;" title="Mover para baixo">⬇</button>
                    </span>
                `;
                
                // Inserir no início do item
                item.innerHTML = buttonsHTML + item.innerHTML;
                
                // Adicionar os event listeners após inserir o HTML
                const upButton = item.querySelector('.move-up');
                const downButton = item.querySelector('.move-down');
                
                if (upButton) {
                    upButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const li = this.closest('li');
                        const previousSibling = li.previousElementSibling;
                        if (previousSibling && !previousSibling.classList.contains('origin-point')) {
                            locationsListElement.insertBefore(li, previousSibling);
                            updateCustomRoute();
                        }
                    });
                }
                
                if (downButton) {
                    downButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const li = this.closest('li');
                        const nextSibling = li.nextElementSibling;
                        if (nextSibling) {
                            locationsListElement.insertBefore(nextSibling, li);
                            updateCustomRoute();
                        }
                    });
                }
            });
            
            showNotification('Modo de rota personalizada ativado. Use as setas ⬆⬇ para reordenar os locais.', 'info');
        } else {
            // Desativar modo de rota personalizada
            locationsListElement.classList.remove('custom-route-active');
            customRouteButton.style.backgroundColor = '#f8f9fa';
            customRouteButton.style.borderColor = '#ced4da';
            
            // Recriar a lista sem os controles
            const items = locationsListElement.querySelectorAll('li');
            items.forEach(item => {
                // Remover controles de posição se existirem
                const controls = item.querySelector('.position-controls');
                if (controls) {
                    controls.remove();
                }
            });
            
            // Atualizar a rota com a nova ordem
            updateCustomRoute();
        }
    }
    
    // Funções para manipular eventos de drag and drop
    function handleDragStart(e) {
        dragItem = e.target;
        // Verificar se o elemento tem classList
        if (e.target && e.target.classList) {
            e.target.classList.add('dragging');
            // Fornecer feedback visual e melhorar a experiência de arrastar
            e.dataTransfer.effectAllowed = 'move';
            // Definir uma imagem fantasma personalizada para melhorar a visualização
            try {
                const ghostElement = e.target.cloneNode(true);
                ghostElement.style.opacity = '0.7';
                ghostElement.style.position = 'absolute';
                ghostElement.style.top = '-1000px';
                document.body.appendChild(ghostElement);
                e.dataTransfer.setDragImage(ghostElement, 20, 20);
                setTimeout(() => {
                    document.body.removeChild(ghostElement);
                }, 0);
            } catch (error) {
                console.log("Erro ao criar imagem fantasma para drag:", error);
            }
        }
    }
    
    function handleDragOver(e) {
        e.preventDefault();
        // Melhorar o feedback visual durante o drag over
        e.dataTransfer.dropEffect = 'move';
        
        // Garantir que temos um elemento de lista (li)
        let targetElement = e.target;
        while (targetElement && targetElement.nodeName !== 'LI') {
            targetElement = targetElement.parentNode;
        }
        
        if (targetElement && !targetElement.classList.contains('origin-point')) {
            dragOverItem = targetElement;
        }
    }
    
    function handleDragEnter(e) {
        e.preventDefault();
        
        // Garantir que temos um elemento de lista (li)
        let targetElement = e.target;
        while (targetElement && targetElement.nodeName !== 'LI') {
            targetElement = targetElement.parentNode;
        }
        
        // Adicionar destaque visual quando entrar em uma área válida de drop
        if (targetElement && !targetElement.classList.contains('origin-point')) {
            targetElement.style.backgroundColor = '#fffbeb';
            dragOverItem = targetElement;
        }
    }
    
    function handleDragLeave(e) {
        e.preventDefault();
        
        // Garantir que temos um elemento de lista (li)
        let targetElement = e.target;
        while (targetElement && targetElement.nodeName !== 'LI') {
            targetElement = targetElement.parentNode;
        }
        
        // Remover destaque visual quando sair da área de drop
        if (targetElement) {
            targetElement.style.backgroundColor = '';
        }
    }
    
    function handleDrop(e) {
        e.preventDefault();
        
        // Verificar se temos dragItem e dragOverItem válidos
        if (!dragItem || !dragOverItem) {
            console.error("Erro no drag and drop: dragItem ou dragOverItem é nulo");
            return;
        }
        
        // Não permitir soltar sobre a origem
        if (dragOverItem.classList && dragOverItem.classList.contains('origin-point')) {
            return;
        }
        
        try {
            // Reordenar os itens na lista
            const parent = dragItem.parentNode;
            if (!parent) {
                console.error("Erro no drag and drop: parent é nulo");
                return;
            }
            
            const referenceNode = (dragOverItem !== dragItem.nextSibling) ? 
                                dragOverItem : 
                                dragOverItem.nextSibling;
            
            parent.insertBefore(dragItem, referenceNode);
            
            // Atualizar a rota imediatamente após o drop
            updateCustomRoute();
        } catch (error) {
            console.error("Erro ao reordenar itens:", error);
        }
    }
    
    function handleDragEnd() {
        if (dragItem && dragItem.classList) {
            dragItem.classList.remove('dragging');
        }
        dragItem = null;
        dragOverItem = null;
    }
    
    // Função para atualizar a rota com a nova ordem personalizada
    function updateCustomRoute() {
        const locationsListElement = document.getElementById('locations-list');
        const locationItems = locationsListElement.querySelectorAll('li');
        
        // Verificar se há locais suficientes para uma rota
        if (locationItems.length < 2) {
            showNotification('Adicione pelo menos um destino além da origem para criar uma rota.', 'warning');
            return;
        }
        
        // Coletar os IDs dos locais na nova ordem
        const newLocationOrder = [];
        let originId = null;
        
        // Primeiro, encontrar o ID da origem
        locationItems.forEach(item => {
            if (item.classList.contains('origin-point')) {
                // Extrair o ID do atributo data-id ou similar
                // Supondo que temos um atributo data-id nos elementos da lista
                originId = parseInt(item.getAttribute('data-id'));
                if (isNaN(originId)) {
                    // Fallback - usar o ID da origem dos dados
                    originId = mockData.origin.id;
                }
                newLocationOrder.push(originId);
            }
        });
        
        // Em seguida, adicionar os demais locais na ordem em que aparecem
        locationItems.forEach(item => {
            if (!item.classList.contains('origin-point')) {
                const locationId = parseInt(item.getAttribute('data-id'));
                if (!isNaN(locationId)) {
                    newLocationOrder.push(locationId);
                }
            }
        });
        
        // Se não temos pelo menos a origem e um destino, não continuar
        if (newLocationOrder.length < 2) {
            showNotification('Não foi possível identificar os locais da rota. Por favor, tente novamente.', 'error');
            return;
        }
        
        // Atualizar a rota com a nova ordem
        calculateCustomRoute(newLocationOrder);
    }
    
    // Função para calcular uma rota com uma ordem personalizada de locais
    function calculateCustomRoute(locationIds) {
        // Mostrar notificação de que estamos calculando
        showNotification('Calculando rota personalizada...', 'info');
        
        // Desabilitar botão enquanto calcula
        const customRouteButton = document.getElementById('custom-route');
        if (customRouteButton) {
            customRouteButton.disabled = true;
        }
        
        // Buscar os locais correspondentes pelos IDs
        const routeLocations = locationIds.map(id => {
            return locations.find(loc => loc.id === id);
        }).filter(loc => loc !== undefined);
        
        // Verificar se temos locais suficientes
        if (routeLocations.length < 2) {
            showNotification('Não há locais suficientes para calcular uma rota.', 'error');
            if (customRouteButton) {
                customRouteButton.disabled = false;
            }
            return;
        }
        
        // Montar a rota em etapas (waypoints)
        const origin = routeLocations[0];
        const destination = routeLocations[routeLocations.length - 1];
        const waypoints = routeLocations.slice(1, routeLocations.length - 1).map(location => {
            return {
                location: new google.maps.LatLng(location.latitude, location.longitude),
                stopover: true
            };
        });
        
        // Configurar a requisição de direções
        const request = {
            origin: new google.maps.LatLng(origin.latitude, origin.longitude),
            destination: new google.maps.LatLng(destination.latitude, destination.longitude),
            waypoints: waypoints,
            optimizeWaypoints: false, // Não otimizar, usar a ordem personalizada
            travelMode: google.maps.TravelMode.DRIVING
        };
        
        // Calcular a rota
        directionsService.route(request, (result, status) => {
            if (status === 'OK') {
                directionsRenderer.setDirections(result);
                
                // Capturar o caminho otimizado para uso em outras funções
                currentOptimizedPath = locationIds;
                
                // Mostrar o resumo da rota
                showRouteSummary(result, routeLocations);
                
                // Mostrar os eventos e restrições para as cidades na rota
                showEventsAndRestrictionsForRoute(locationIds);
                
                // Notificar que a rota foi calculada com sucesso
                showNotification('Rota personalizada calculada com sucesso!', 'success');
            } else {
                console.error("Erro ao calcular rota:", status);
                showNotification(`Erro ao calcular rota: ${status}`, 'error');
            }
            
            // Reabilitar botão
            if (customRouteButton) {
                customRouteButton.disabled = false;
            }
        });
    }
    
    // Função para mostrar eventos e restrições para a rota personalizada
    function showEventsAndRestrictionsForRoute(locationIds) {
        // Obter as datas do filtro
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        
        if (!startDateInput || !endDateInput) {
            console.error("Campos de data não encontrados para filtrar eventos");
            return;
        }
        
        const startDateStr = startDateInput.value;
        const endDateStr = endDateInput.value;
        
        // Mostrar eventos para as cidades na rota
        showEventsForCitiesOnRoute(locationIds, startDateStr, endDateStr);
        
        // Mostrar restrições para as cidades na rota
        showTruckRestrictionsForCitiesOnRoute(locationIds);
    }
    </script>
</body>
</html>