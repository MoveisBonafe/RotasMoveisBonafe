<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Otimizador de Rotas para logística e transporte, com suporte a cálculo de rotas entre múltiplos pontos, otimização de sequência, e visualização de eventos e restrições em cidades brasileiras." />
    <meta name="keywords" content="otimizador de rotas, problema do caixeiro viajante, logística, transporte, planejamento de rotas, otimização de entregas, Brasil, Google Maps, pedágios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 380px;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .map-container {
            flex: 1;
            height: 100%;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .location-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-address {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn-container {
            position: sticky;
            bottom: 0;
            background-color: #f8f9fa;
            padding: 15px 0;
            margin-top: 20px;
        }
        #optimize-route {
            width: 100%;
        }
        .marker-label {
            color: white;
            background-color: #1976D2;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 14px;
        }
        .pac-container {
            z-index: 9999; /* Garantir que as sugestões apareçam acima de outros elementos */
        }
        .truck-icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
        }
        .truck-type {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .truck-type label {
            margin-left: 10px;
            cursor: pointer;
        }
        #route-summary {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 5px;
        }
        #route-steps {
            margin-top: 15px;
            padding-left: 15px;
        }
        .summary-header {
            font-weight: bold;
            margin-bottom: 10px;
        }
        /* Estilos para a área de upload de arquivo */
        .file-upload {
            margin-top: 15px;
            border: 2px dashed #ccc;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .file-upload p {
            margin-bottom: 10px;
            color: #666;
        }
        .file-format-example {
            background-color: #eee;
            padding: 5px;
            border-radius: 3px;
            font-family: monospace;
            display: inline-block;
            margin-bottom: 10px;
        }
        /* Botão para fechar o sidebar em telas pequenas */
        .sidebar-close {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        /* Estilo quando o sidebar está fechado */
        .sidebar-hidden {
            transform: translateX(-100%);
        }
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 100%;
                max-width: 320px;
            }
            .sidebar-close {
                display: block;
            }
            .toggle-sidebar {
                display: block;
            }
        }
        /* Estilo para os marcadores de pontos de interesse */
        .poi-marker {
            background-color: #4caf50;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            font-size: 12px;
        }
        /* Estilos para tooltip personalizado */
        .custom-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
        }
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        /* Estilos para abas */
        .tab-container {
            margin-bottom: 20px;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }
        .tab-button {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }
        .tab-button.active {
            border-bottom: 2px solid #1976D2;
            background-color: #e9ecef;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Estilo para datas */
        .date-range-container {
            display: flex;
            gap: 10px;
        }
        .date-range-container input {
            flex: 1;
        }
        
        /* Estilos para ícones de evento */
        .event-marker {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            font-size: 14px;
        }
        .event-marker.holiday {
            background-color: #f44336; /* Vermelho para feriados */
        }
        .event-marker.event {
            background-color: #ff9800; /* Laranja para eventos */
        }
        
        /* Estilo para lista de eventos */
        .events-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .event-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .event-name {
            font-weight: bold;
        }
        .event-date {
            font-size: 0.8em;
            color: #666;
        }
        .event-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .event-type.holiday {
            background-color: #f44336;
        }
        .event-type.event {
            background-color: #ff9800;
        }
        .restriction-level {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-level.low {
            background-color: #4caf50;
        }
        .restriction-level.medium {
            background-color: #ff9800;
        }
        .restriction-level.high {
            background-color: #f44336;
        }
        
        /* Estilos para restrições de caminhões */
        .restrictions-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .restriction-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .restriction-city {
            font-weight: bold;
        }
        .restriction-time {
            font-size: 0.8em;
            color: #666;
        }
        .restriction-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-type.partial {
            background-color: #ff9800;
        }
        .restriction-type.total {
            background-color: #f44336;
        }
        .restriction-type.rodizio {
            background-color: #9c27b0;
        }

        /* Estilos para animação da rota */
        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
            }
        }
        .animated-path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawPath 3s ease-in-out forwards;
        }

        /* Botões de controle da visualização */
        .map-controls {
            position: absolute;
            bottom: 24px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .map-control-btn {
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Estilo para o spinner de carregamento */
        .spinner-border {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar para controles e informações -->
        <div class="sidebar" id="sidebar">
            <h2 class="mb-4">Otimizador de Rotas</h2>
            <button type="button" class="btn-close sidebar-close" aria-label="Close"></button>
            
            <!-- Container de abas -->
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="locations">Locais</button>
                    <button class="tab-button" data-tab="events">Eventos</button>
                    <button class="tab-button" data-tab="report">Relatório</button>
                </div>
                
                <!-- Aba de Locais -->
                <div class="tab-content active" id="locations-tab">
                    <!-- Filtro de datas - movido da aba Eventos para cá -->
                    <div class="form-group">
                        <label>Filtrar eventos por data:</label>
                        <div class="date-range-container">
                            <input type="date" id="start-date" class="form-control">
                            <input type="date" id="end-date" class="form-control">
                        </div>
                        <button id="filter-events" class="btn btn-outline-primary btn-sm mt-2 mb-3">Filtrar</button>
                    </div>
                    
                    <!-- Origem fixa -->
                    <div class="form-group">
                        <label for="origin">Origem:</label>
                        <input type="text" id="origin" class="form-control" value="Dois Córregos, SP" readonly>
                    </div>
                    
                    <!-- Campo de busca para adicionar novo local -->
                    <div class="form-group">
                        <label for="location-search">Adicionar local:</label>
                        <input type="text" id="location-search" class="form-control" placeholder="Digite um endereço">
                    </div>
                    
                    <!-- Opções de veículo -->
                    <div class="form-group">
                        <label>Tipo de veículo:</label>
                        <div id="vehicle-options">
                            <div class="truck-type">
                                <input type="radio" name="vehicle-type" id="truck1" value="truck1" checked>
                                <label for="truck1">Caminhão 1 eixo</label>
                            </div>
                            <div class="truck-type">
                                <input type="radio" name="vehicle-type" id="truck2" value="truck2">
                                <label for="truck2">Caminhão 2 eixos</label>
                            </div>
                            <div class="truck-type">
                                <input type="radio" name="vehicle-type" id="truck3" value="truck3">
                                <label for="truck3">Caminhão 3 eixos</label>
                            </div>
                            <div class="truck-type">
                                <input type="radio" name="vehicle-type" id="truck5" value="truck5">
                                <label for="truck5">Caminhão 5 eixos</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Upload de arquivo -->
                    <div class="file-upload">
                        <p>Importe múltiplos endereços via arquivo:</p>
                        <div class="file-format-example">CEP,Nome do Local</div>
                        <input type="file" id="file-upload" class="form-control" accept=".txt,.csv">
                    </div>
                    
                    <!-- Lista de locais adicionados -->
                    <h5 class="mt-4">Locais adicionados:</h5>
                    <div class="location-list" id="locations-list">
                        <!-- Locais serão adicionados aqui dinamicamente -->
                    </div>
                    
                    <!-- Botão para otimizar rota -->
                    <div class="optimize-btn-container">
                        <button id="optimize-route" class="btn btn-primary">
                            Otimizar Rota
                        </button>
                    </div>
                </div>
                
                <!-- Aba de Eventos -->
                <div class="tab-content" id="events-tab">
                    
                    <h5 class="mt-3">Eventos na rota:</h5>
                    <div class="events-list" id="events-list">
                        <p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                    </div>
                    
                    <h5 class="mt-3">Restrições para caminhões:</h5>
                    <div class="restrictions-list" id="restrictions-list">
                        <p class="text-muted">Nenhuma restrição encontrada. Adicione locais e otimize a rota para ver restrições nas cidades do percurso.</p>
                    </div>
                </div>
                
                <!-- Aba de Relatório -->
                <div class="tab-content" id="report-tab">
                    <div id="route-summary" class="mb-3">
                        <p class="text-muted">Otimize uma rota para ver o relatório detalhado.</p>
                    </div>
                    
                    <div class="form-group">
                        <label for="route-name">Nome da rota:</label>
                        <input type="text" id="route-name" class="form-control" placeholder="Ex: Entrega Região Sul">
                    </div>
                    
                    <button id="save-route" class="btn btn-outline-success mt-2" disabled>Salvar Rota</button>
                    <button id="print-route" class="btn btn-outline-primary mt-2 ms-2" disabled>Imprimir</button>
                </div>
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar">☰</button>
            <div id="map"></div>
            
            <!-- Controles do mapa -->
            <div class="map-controls">
                <button class="map-control-btn" id="zoom-to-fit" title="Ajustar zoom para ver todos os pontos">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z"/>
                    </svg>
                </button>
                <button class="map-control-btn" id="toggle-poi" title="Mostrar/ocultar pontos de interesse">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Scripts externos -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="cep-database.js"></script>
    <script src="geocode-fix.js"></script>
    
    <script>
    // Dados de amostra para a aplicação standalone
    const mockData = {
        // Origem (Dois Córregos)
        origin: {
            id: 1,
            name: "Dois Córregos",
            address: "Dois Córregos, SP, Brasil",
            zipCode: "17300-000",
            latitude: -22.3673,
            longitude: -48.3822,
            isOrigin: true
        },
        
        // Tipos de veículos
        vehicleTypes: [
            { id: 1, name: "Caminhão 1 eixo", type: "truck1", costPerKm: 3.5, fuelConsumption: 4.5, averageSpeed: 75 },
            { id: 2, name: "Caminhão 2 eixos", type: "truck2", costPerKm: 4.2, fuelConsumption: 5.2, averageSpeed: 70 },
            { id: 3, name: "Caminhão 3 eixos", type: "truck3", costPerKm: 5.0, fuelConsumption: 6.0, averageSpeed: 65 },
            { id: 4, name: "Caminhão 5 eixos", type: "truck5", costPerKm: 6.5, fuelConsumption: 8.0, averageSpeed: 55 }
        ],
        
        // Pontos de interesse
        pointsOfInterest: [
            { id: 1, name: "Pedágio SP-225 (Brotas)", type: "toll", latitude: -22.2544, longitude: -48.1247, highway: "SP-225", cityName: "Brotas", cost: 11.30 },
            { id: 2, name: "Pedágio SP-225 (Jaú)", type: "toll", latitude: -22.2877, longitude: -48.5325, highway: "SP-225", cityName: "Jaú", cost: 7.90 },
            { id: 3, name: "Pedágio SP-300 (Botucatu)", type: "toll", latitude: -22.8932, longitude: -48.4521, highway: "SP-300", cityName: "Botucatu", cost: 9.50 },
            { id: 4, name: "Balança SP-225 (Dois Córregos)", type: "weighStation", latitude: -22.3532, longitude: -48.3301, highway: "SP-225", cityName: "Dois Córregos", isActive: true },
            { id: 5, name: "Balança SP-300 (Botucatu)", type: "weighStation", latitude: -22.9011, longitude: -48.4402, highway: "SP-300", cityName: "Botucatu", isActive: true },
            { id: 6, name: "Posto de combustível Shell (Dois Córregos)", type: "gasStation", latitude: -22.3673, longitude: -48.3900, highway: "SP-225", cityName: "Dois Córregos", services: ["food", "rest", "shower"] },
            { id: 7, name: "Posto de combustível BR (Jaú)", type: "gasStation", latitude: -22.2870, longitude: -48.5400, highway: "SP-225", cityName: "Jaú", services: ["food", "mechanic"] },
            { id: 8, name: "Borracharia 24h (Botucatu)", type: "mechanic", latitude: -22.8900, longitude: -48.4500, highway: "SP-300", cityName: "Botucatu", services: ["tire"] }
        ],
        
        // Eventos de cidades - atualizados para 2025
        cityEvents: [
            { id: 1, cityName: "Dois Córregos", name: "Aniversário da Cidade", startDate: "2025-05-24", endDate: "2025-05-24", isHoliday: true, description: "Feriado municipal do aniversário de Dois Córregos", restrictionLevel: "low" },
            { id: 2, cityName: "Jaú", name: "Festa do Rodeio", startDate: "2025-06-10", endDate: "2025-06-20", isHoliday: false, description: "Evento com grande circulação de veículos", restrictionLevel: "medium" },
            { id: 3, cityName: "Botucatu", name: "Festival de Inverno", startDate: "2025-07-15", endDate: "2025-07-30", isHoliday: false, description: "Evento cultural e gastronômico", restrictionLevel: "low" },
            { id: 4, cityName: "Bauru", name: "Exposição Agropecuária", startDate: "2025-08-05", endDate: "2025-08-15", isHoliday: false, description: "Feira agropecuária com shows", restrictionLevel: "high" },
            { id: 5, cityName: "Vera Cruz", name: "Exposição Agrícola", startDate: "2025-05-01", endDate: "2025-05-10", isHoliday: false, description: "Evento agrícola regional", restrictionLevel: "medium" },
            { id: 6, cityName: "Pompéia", name: "Aniversário da Cidade", startDate: "2025-05-15", endDate: "2025-05-15", isHoliday: true, description: "Feriado municipal de Pompéia", restrictionLevel: "low" },
            { id: 7, cityName: "Ribeirão Preto", name: "Agrishow", startDate: "2025-04-27", endDate: "2025-05-01", isHoliday: false, description: "Maior feira de tecnologia agrícola da América Latina", restrictionLevel: "high" }
        ],
        
        // Restrições para caminhões
        truckRestrictions: [
            { id: 1, cityName: "Dois Córregos", dayType: "weekday", startTime: "07:00", endTime: "09:00", restrictionType: "partial", description: "Restrição parcial para caminhões de grande porte no centro", affectedVehicles: ["truck5"] },
            { id: 2, cityName: "Jaú", dayType: "weekday", startTime: "17:00", endTime: "20:00", restrictionType: "partial", description: "Restrição parcial para todos os caminhões no centro", affectedVehicles: ["truck1", "truck2", "truck3", "truck5"] },
            { id: 3, cityName: "Botucatu", dayType: "weekend", startTime: "08:00", endTime: "18:00", restrictionType: "total", description: "Proibição total para caminhões na área central", affectedVehicles: ["truck1", "truck2", "truck3", "truck5"] },
            { id: 4, cityName: "Bauru", dayType: "all", startTime: "07:00", endTime: "22:00", restrictionType: "rodizio", description: "Sistema de rodízio para todos os caminhões", affectedVehicles: ["truck1", "truck2", "truck3", "truck5"] },
            { id: 5, cityName: "Vera Cruz", dayType: "weekday", startTime: "06:00", endTime: "20:00", restrictionType: "partial", description: "Restrição para caminhões de médio e grande porte", affectedVehicles: ["truck3", "truck5"] },
            { id: 6, cityName: "Pompéia", dayType: "weekday", startTime: "08:00", endTime: "17:00", restrictionType: "partial", description: "Restrição nas áreas centrais para caminhões", affectedVehicles: ["truck2", "truck3", "truck5"] },
            { id: 7, cityName: "Ribeirão Preto", dayType: "all", startTime: "07:00", endTime: "20:00", restrictionType: "rodizio", description: "Sistema de rodízio em toda área urbana", affectedVehicles: ["truck1", "truck2", "truck3", "truck5"] }
        ]
    };

    // Variáveis globais
    let map;
    let directionsService;
    let directionsRenderer;
    let autocomplete;
    let markers = [];
    let poiMarkers = [];
    let eventMarkers = [];
    let locationId = 2; // Começa em 2 porque 1 é reservado para a origem
    let locations = [mockData.origin];
    let activeInfoWindow = null;
    let routePath = null;
    let routeAnimationTimeout = null;
    let showPOIs = true;
    let customTooltip = null;
    
    // Função para formatar data do evento com segurança
    function formatarDataEvento(dataString) {
        try {
            // Se for uma string, tenta converter para Date
            let dataObj;
            if (typeof dataString === 'string') {
                // Garantir que temos uma data ISO válida
                if (dataString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    dataObj = new Date(dataString + "T00:00:00");
                } else {
                    dataObj = new Date(dataString);
                }
            } else {
                dataObj = new Date(dataString);
            }
            
            // Verificar se a data é válida
            if (isNaN(dataObj.getTime())) {
                console.warn("Data inválida:", dataString);
                return "Data inválida";
            }
            
            // Formatar como DD/MM/AAAA
            return dataObj.toLocaleDateString('pt-BR');
        } catch (e) {
            console.error("Erro ao formatar data:", dataString, e);
            return "Data indisponível";
        }
    }

    // Inicialização
    document.addEventListener("DOMContentLoaded", function() {
        initMap();
        initAutocomplete();
        initTabNavigation();
        initEventListeners();
        
        // Exibir a origem no mapa
        addMarkerForLocation(mockData.origin, 0);
        
        // Inicializar datas para o filtro de eventos - utilizando o ano atual (2025)
        const currentYear = 2025;
        const currentMonth = 4; // maio = 4 (0-based)
        
        const today = new Date(currentYear, currentMonth, 1);
        const nextMonth = new Date(currentYear, currentMonth + 1, 0);
        
        document.getElementById('start-date').valueAsDate = today;
        document.getElementById('end-date').valueAsDate = nextMonth;
        
        // Atualizar os eventos para garantir que estejam com datas do ano corrente
        updateEventDates(currentYear);
        
        // Debug
        console.log("Versão do GitHub Pages - Inicialização concluída");
        console.log("Eventos disponíveis:", mockData.cityEvents.length);
        console.log("Restrições disponíveis:", mockData.truckRestrictions.length);
    });
    
    // Função para atualizar datas de eventos para o ano atual
    function updateEventDates(year) {
        if (!mockData.cityEvents) return;
        
        mockData.cityEvents.forEach(event => {
            // Verificar se as datas já estão no ano correto
            const eventYear = new Date(event.startDate).getFullYear();
            
            if (eventYear !== year) {
                // Extrair mês e dia das datas originais
                const startDate = new Date(event.startDate);
                const endDate = new Date(event.endDate);
                
                // Criar novas datas com o ano atual
                const newStartDate = new Date(
                    year,
                    startDate.getMonth(),
                    startDate.getDate()
                );
                
                const newEndDate = new Date(
                    year,
                    endDate.getMonth(),
                    endDate.getDate()
                );
                
                // Atualizar as datas no formato ISO string (YYYY-MM-DD)
                event.startDate = newStartDate.toISOString().split('T')[0];
                event.endDate = newEndDate.toISOString().split('T')[0];
            }
        });
        
        console.log("Datas de eventos atualizadas para", year);
    }

    // Inicializa o mapa
    function initMap() {
        // Opções do mapa
        const mapOptions = {
            center: { lat: -22.3673, lng: -48.3822 }, // Dois Córregos
            zoom: 8,
            mapTypeControl: true,
            fullscreenControl: true,
            streetViewControl: true,
            zoomControl: true,
            gestureHandling: 'greedy' // Permite zoom com scroll sem precionar Ctrl
        };
        
        // Criar o mapa
        map = new google.maps.Map(document.getElementById("map"), mapOptions);
        
        // Inicializar o serviço de direções
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            suppressMarkers: true, // Não mostrar marcadores padrão do Google
            preserveViewport: true
        });
        directionsRenderer.setMap(map);
        
        // Criar o tooltip personalizado
        createCustomTooltip();
    }

    // Inicializa o autocomplete
    function initAutocomplete() {
        const input = document.getElementById('location-search');
        const options = {
            types: ['geocode'],
            componentRestrictions: { country: 'br' }
        };
        
        autocomplete = new google.maps.places.Autocomplete(input, options);
        
        // Quando um local é selecionado no autocomplete
        autocomplete.addListener('place_changed', function() {
            const place = autocomplete.getPlace();
            
            if (!place.geometry) {
                alert("Não foi possível encontrar o endereço selecionado.");
                return;
            }
            
            // Adicionar o local à lista
            const newLocation = {
                id: locationId++,
                name: place.name,
                address: place.formatted_address,
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            locations.push(newLocation);
            
            // Adicionar marcador e atualizar a lista
            addMarkerForLocation(newLocation, locations.length - 1);
            updateLocationsList();
            
            // Limpar o campo de busca
            input.value = '';
        });
    }

    // Inicializa a navegação por abas
    function initTabNavigation() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Desativar todas as abas
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Ativar a aba clicada
                button.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });
    }

    // Configura todos os event listeners
    function initEventListeners() {
        // Toggle para mostrar/esconder a sidebar
        document.getElementById('toggle-sidebar').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('sidebar-hidden');
        });
        
        // Botão para fechar a sidebar em telas pequenas
        document.querySelector('.sidebar-close').addEventListener('click', function() {
            document.getElementById('sidebar').classList.add('sidebar-hidden');
        });
        
        // Upload de arquivo
        document.getElementById('file-upload').addEventListener('change', handleFileUpload);
        
        // Botão para otimizar rota
        document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
        
        // Filtrar eventos por data
        document.getElementById('filter-events').addEventListener('click', filterEventsByDate);
        
        // Botões de controle do mapa
        document.getElementById('zoom-to-fit').addEventListener('click', zoomToFitAllMarkers);
        document.getElementById('toggle-poi').addEventListener('click', togglePointsOfInterest);
        
        // Botões da aba de relatório
        document.getElementById('save-route').addEventListener('click', saveRoute);
        document.getElementById('print-route').addEventListener('click', printRoute);
    }

    // Função para tratar o upload de arquivo
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            parseCEPFile(content);
        };
        reader.readAsText(file);
    }

    // Função para processar o arquivo de CEPs
    function parseCEPFile(content) {
        const lines = content.split('\n');
        let newLocations = [];
        
        // CEPs com coordenadas conhecidas para as principais cidades paulistas
        const knownCEPs = {
            '14020-260': {name: 'Ribeirão Preto', lat: -21.1767, lng: -47.8208},
            '17560-000': {name: 'Vera Cruz', lat: -22.2205, lng: -49.8233},
            '17580-000': {name: 'Pompéia', lat: -22.1075, lng: -50.1764},
            '17280-000': {name: 'Pederneiras', lat: -22.3518, lng: -48.7780},
            '17220-000': {name: 'Itapuí', lat: -22.2323, lng: -48.7186},
            '17340-000': {name: 'Barra Bonita', lat: -22.4910, lng: -48.5582},
            '17380-000': {name: 'Brotas', lat: -22.2794, lng: -48.1251},
            '17200-000': {name: 'Jaú', lat: -22.2936, lng: -48.5592},
            '18600-000': {name: 'Botucatu', lat: -22.8837, lng: -48.4437},
            '17120-000': {name: 'Agudos', lat: -22.4696, lng: -48.9870},
            '17210-000': {name: 'Igaraçu do Tietê', lat: -22.5092, lng: -48.5597},
            '17040-001': {name: 'Bauru', lat: -22.3246, lng: -49.0871},
            '17400-000': {name: 'Garça', lat: -22.2132, lng: -49.6546},
            '17480-000': {name: 'Marília', lat: -22.2171, lng: -49.9501},
            '17300-000': {name: 'Dois Córregos', lat: -22.3673, lng: -48.3822}
        };
        
        // Geocodificador para CEPs desconhecidos
        const geocoder = new google.maps.Geocoder();
        let geocodeQueue = [];
        
        for (const line of lines) {
            if (!line.trim()) continue;
            
            const parts = line.split(',');
            if (parts.length < 2) continue;
            
            const cep = parts[0].trim();
            const name = parts[1].trim();
            
            if (cep && name) {
                // Verificar se é um CEP conhecido
                if (knownCEPs[cep]) {
                    const knownLocation = knownCEPs[cep];
                    
                    newLocations.push({
                        id: locationId++,
                        name: name,
                        address: `${name}, ${knownLocation.name}, SP, Brasil`,
                        zipCode: cep,
                        latitude: knownLocation.lat,
                        longitude: knownLocation.lng,
                        isOrigin: false
                    });
                } else {
                    // Adicionar à fila para geocodificação
                    geocodeQueue.push({
                        cep: cep,
                        name: name
                    });
                }
            }
        }
        
        // Processar os CEPs conhecidos imediatamente
        if (newLocations.length > 0) {
            // Para cada novo local, adicionar à lista e ao mapa
            newLocations.forEach((location, index) => {
                locations.push(location);
                addMarkerForLocation(location, locations.length - 1);
            });
            
            // Atualizar a lista de locais
            updateLocationsList();
            
            // Ajustar o zoom para mostrar todos os pontos
            zoomToFitAllMarkers();
        }
        
        // Processar a fila de geocodificação para CEPs desconhecidos
        if (geocodeQueue.length > 0) {
            const statusElement = document.createElement('div');
            statusElement.className = 'alert alert-info mt-3';
            statusElement.id = 'geocode-status';
            statusElement.innerHTML = `Geocodificando ${geocodeQueue.length} endereços adicionais...`;
            document.querySelector('.file-upload').appendChild(statusElement);
            
            let processedCount = 0;
            
            // Função para processar a fila de geocodificação
            function processGeocodingQueue() {
                if (geocodeQueue.length === 0) {
                    // Todos os geocodes foram processados
                    document.getElementById('geocode-status').remove();
                    return;
                }
                
                const item = geocodeQueue.shift();
                const address = `${item.cep}, Brasil`;
                
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const location = results[0].geometry.location;
                        
                        const newLocation = {
                            id: locationId++,
                            name: item.name,
                            address: `${item.name}, ${address}`,
                            zipCode: item.cep,
                            latitude: location.lat(),
                            longitude: location.lng(),
                            isOrigin: false
                        };
                        
                        locations.push(newLocation);
                        addMarkerForLocation(newLocation, locations.length - 1);
                        
                        // Atualizar a lista de locais
                        updateLocationsList();
                        
                        // Atualizar o status
                        processedCount++;
                        document.getElementById('geocode-status').innerHTML = 
                            `Geocodificando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        
                        // Ajustar o zoom
                        zoomToFitAllMarkers();
                        
                        // Continuar com o próximo após um curto delay (para evitar limites de API)
                        setTimeout(processGeocodingQueue, 200);
                    } else {
                        // Falha no geocoding, usar coordenadas aproximadas baseadas na região SP
                        console.warn(`Falha ao geocodificar ${address}: ${status}`);
                        
                        // Coordenadas aleatórias na região central de SP (como fallback)
                        const fallbackLat = -22.3 - Math.random() * 1.5;
                        const fallbackLng = -48.3 - Math.random() * 1.5;
                        
                        const newLocation = {
                            id: locationId++,
                            name: item.name,
                            address: `${item.name}, Região Central, SP, Brasil`,
                            zipCode: item.cep,
                            latitude: fallbackLat,
                            longitude: fallbackLng,
                            isOrigin: false
                        };
                        
                        locations.push(newLocation);
                        addMarkerForLocation(newLocation, locations.length - 1);
                        
                        // Atualizar a lista de locais
                        updateLocationsList();
                        
                        // Atualizar o status
                        processedCount++;
                        document.getElementById('geocode-status').innerHTML = 
                            `Geocodificando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        
                        // Continuar com o próximo após um curto delay
                        setTimeout(processGeocodingQueue, 200);
                    }
                });
            }
            
            // Iniciar o processamento da fila
            processGeocodingQueue();
        }
        
        // Limpar o campo de upload
        document.getElementById('file-upload').value = '';
        
        // Contar as linhas válidas do arquivo original
        const validLines = lines.filter(line => {
            if (!line.trim()) return false;
            const parts = line.split(',');
            return parts.length >= 2 && parts[0].trim() && parts[1].trim();
        }).length;
        
        // Feedback para o usuário com a contagem correta
        alert(`${validLines} locais sendo importados! Os locais conhecidos aparecerão imediatamente, enquanto os demais serão geocodificados automaticamente.`);
    }

    // Função para extrair CEP de um objeto Place
    function getZipCodeFromPlace(place) {
        if (!place.address_components) return "";
        
        for (let component of place.address_components) {
            if (component.types.includes('postal_code')) {
                return component.long_name;
            }
        }
        return "";
    }

    // Adiciona um marcador no mapa para um local
    function addMarkerForLocation(location, index) {
        // Ícone personalizado com número de sequência
        const markerLabel = index === 0 ? 'O' : (index).toString();
        
        // Cor específica para a origem
        const markerColor = index === 0 ? '#FF0000' : '#1976D2';
        
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: location.name,
            label: {
                text: markerLabel,
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: markerColor,
                fillOpacity: 1,
                strokeWeight: 0,
                scale: 12
            },
            zIndex: index === 0 ? 1000 : 100 // Origem sempre em cima
        });
        
        // Infowindow com detalhes do local
        const infowindow = new google.maps.InfoWindow({
            content: `
                <div>
                    <h5>${location.name}</h5>
                    <p>${location.address}</p>
                    ${location.zipCode ? `<p>CEP: ${location.zipCode}</p>` : ''}
                    ${!location.isOrigin ? `<button onclick="removeLocation(${location.id})" class="btn btn-sm btn-danger">Remover</button>` : ''}
                </div>
            `
        });
        
        // Event listener para abrir o infowindow
        marker.addListener('click', function() {
            if (activeInfoWindow) {
                activeInfoWindow.close();
            }
            infowindow.open(map, marker);
            activeInfoWindow = infowindow;
            
            // Se o local estiver na mesma cidade da origem, destacar visualmente
            if (isSameCity(location, locations.find(loc => loc.isOrigin))) {
                marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(() => marker.setAnimation(null), 1500);
            }
        });
        
        // Armazenar o marcador na array
        markers.push({ marker, location, infowindow });
    }

    // Atualiza a lista de locais no sidebar com base na ordem dos marcadores
    function updateLocationsList() {
        const container = document.getElementById('locations-list');
        container.innerHTML = '';
        
        // Extrair os locais não-origem dos marcadores para preservar a ordem
        const orderedLocations = markers
            .map(m => m.location)
            .filter(loc => !loc.isOrigin);
        
        // Adicionar cada local à lista na ordem dos marcadores
        orderedLocations.forEach((location, index) => {
            const locationItem = document.createElement('div');
            locationItem.className = 'location-item';
            locationItem.innerHTML = `
                <div>
                    <div><span class="badge bg-primary">${index + 1}</span> ${location.name}</div>
                    <div class="location-address">${location.address}</div>
                </div>
                <button class="btn btn-sm btn-danger" onclick="removeLocation(${location.id})">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                </button>
            `;
            container.appendChild(locationItem);
        });
    }

    // Remove um local da lista e do mapa
    function removeLocation(id) {
        // Remover o local da lista
        locations = locations.filter(loc => loc.id !== id);
        
        // Remover o marcador do mapa
        const markerIndex = markers.findIndex(m => m.location.id === id);
        if (markerIndex !== -1) {
            markers[markerIndex].marker.setMap(null);
            markers.splice(markerIndex, 1);
        }
        
        // Atualizar a lista e reindexar os marcadores
        updateLocationsList();
        reindexMarkers();
        
        // Se houver uma rota atual, limpá-la
        clearRoute();
    }

    // Reindexar os marcadores após remoção
    function reindexMarkers() {
        markers.forEach((markerObj, index) => {
            if (!markerObj.location.isOrigin) {
                markerObj.marker.setLabel({
                    text: index.toString(),
                    color: 'white',
                    fontSize: '14px',
                    fontWeight: 'bold'
                });
            }
        });
    }

    // Limpar rota atual e marcadores relacionados
    function clearRoute() {
        if (directionsRenderer) {
            directionsRenderer.setDirections({ routes: [] });
        }
        
        // Limpar timeout de animação se existir
        if (routeAnimationTimeout) {
            clearTimeout(routeAnimationTimeout);
        }
        
        // Limpar caminho da rota se existir
        if (routePath) {
            routePath.setMap(null);
            routePath = null;
        }
        
        // Limpar marcadores de POI
        clearPOIMarkers();
        
        // Limpar marcadores de eventos
        clearEventMarkers();
        
        // Resetar o resumo da rota
        document.getElementById('route-summary').style.display = 'none';
        document.getElementById('save-route').disabled = true;
        document.getElementById('print-route').disabled = true;
    }

    // Limpar marcadores de pontos de interesse
    function clearPOIMarkers() {
        poiMarkers.forEach(marker => marker.setMap(null));
        poiMarkers = [];
    }

    // Limpar marcadores de eventos
    function clearEventMarkers() {
        eventMarkers.forEach(marker => marker.setMap(null));
        eventMarkers = [];
    }

    // Otimizar a rota
    function optimizeRoute() {
        console.log("Função optimizeRoute iniciada");
        
        // Verificar se há pelo menos um destino além da origem
        if (locations.length <= 1) {
            alert("Adicione pelo menos um destino para calcular a rota.");
            return;
        }
        
        // Limpar rota anterior
        clearRoute();
        
        // Mostrar loading no botão
        const optimizeBtn = document.getElementById('optimize-route');
        optimizeBtn.innerHTML = '<span class="spinner-border" role="status" aria-hidden="true"></span> Calculando...';
        
        // Usar setTimeout para não bloquear a UI
        setTimeout(() => {
            try {
                optimizeBtn.disabled = true;
                
                // Obter o tipo de veículo selecionado com fallback seguro
                const vehicleTypeElement = document.querySelector('input[name="vehicle-type"]:checked');
                const vehicleType = vehicleTypeElement ? vehicleTypeElement.value : 'truck1';
                
                console.log("Tipo de veículo selecionado:", vehicleType);
                console.log("Número de locais:", locations.length);
                
                // Imprimir detalhes das localizações para debug
                locations.forEach((loc, idx) => {
                    console.log(`Local ${idx}: ${loc.name}, Lat: ${loc.latitude}, Lng: ${loc.longitude}`);
                });
                
                // Calcular a rota otimizada (versão simplificada do TSP)
                calculateOptimizedRoute(vehicleType, false);
            } catch (error) {
                console.error("Erro ao otimizar rota:", error);
                // Restaurar o botão em caso de erro
                optimizeBtn.innerHTML = 'Otimizar Rota';
                optimizeBtn.disabled = false;
                alert("Erro ao otimizar rota. Verifique o console para detalhes.");
            }
        }, 200);
    }

    // Calcular rota otimizada pelo algoritmo TSP
    function calculateOptimizedRoute(vehicleType, includeOriginReturn) {
        console.log("Iniciando cálculo de rota otimizada");
        
        try {
            // Verificar o número mínimo de destinos
            if (locations.length < 2) {
                throw new Error("Você precisa adicionar pelo menos um destino além da origem");
            }
            
            // Na versão GitHub Pages, tentar usar a implementação mais simples
            // para evitar problemas de compatibilidade
            const isGitHubPages = window.location.href.includes('github.io');
            console.log("Ambiente detectado:", isGitHubPages ? "GitHub Pages" : "Aplicação normal");
            
            // Primeiro vamos resolver o TSP para encontrar a ordem ideal dos pontos
            const origin = locations.find(loc => loc.isOrigin);
            if (!origin) {
                throw new Error("Origem não encontrada!");
            }
            
            const destinations = locations.filter(loc => !loc.isOrigin);
            console.log("Destinos encontrados:", destinations.length);
            
            // Verificar coordenadas
            for (const loc of [origin, ...destinations]) {
                if (typeof loc.latitude !== 'number' || typeof loc.longitude !== 'number' ||
                    isNaN(loc.latitude) || isNaN(loc.longitude)) {
                    console.error("Coordenadas inválidas para:", loc);
                    throw new Error(`Coordenadas inválidas para o local ${loc.name}`);
                }
            }
            
            // Resolver o TSP usando algoritmo apropriado para a plataforma
            console.log("Resolvendo TSP");
            
            // Usar o algoritmo mais simples no GitHub Pages
            let tspResult;
            if (window.location.href.includes('github.io')) {
                console.log("Usando algoritmo simples para GitHub Pages");
                tspResult = solveBasicTSP(origin, destinations, includeOriginReturn);
            } else {
                tspResult = solveAdvancedTSP(origin, destinations, includeOriginReturn);
            }
            
            console.log("Resultado do TSP:", tspResult);
            
            // Reordenar os marcadores visualmente para corresponder à nova sequência
            reorderMarkers(tspResult.path);
            
            // Traçar a rota usando o Google Directions Service
            drawRouteOnMap(tspResult.path, vehicleType);
            
            // Mostrar pontos de interesse ao longo da rota
            showPointsOfInterestOnRoute(tspResult.path);
            
            // Mostrar eventos nas cidades da rota
            showEventsForCitiesOnRoute(tspResult.path);
            
            // Mostrar restrições para caminhões nas cidades da rota
            showTruckRestrictionsForCitiesOnRoute(tspResult.path, vehicleType);
            
            // Atualizar o resumo da rota
            updateRouteSummary(tspResult, vehicleType);
            
            // Habilitar botões de salvar e imprimir
            document.getElementById('save-route').disabled = false;
            document.getElementById('print-route').disabled = false;
            
            // Restaurar o botão de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
            
            // Navegar para a aba de relatório
            document.querySelector('.tab-button[data-tab="report"]').click();
        } catch (error) {
            console.error("Erro no cálculo da rota otimizada:", error);
            
            // Restaurar o botão de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
            
            // Alertar o usuário
            alert("Ocorreu um erro ao calcular a rota otimizada. Por favor tente novamente ou adicione outros locais.");
        }
    }
    
    // Reordenar os marcadores para corresponder à sequência otimizada
    function reorderMarkers(optimizedPath) {
        // Remover os marcadores existentes do mapa
        markers.forEach(markerObj => {
            markerObj.marker.setMap(null);
        });
        
        // Limpar o array de marcadores
        markers = [];
        
        // Adicionar marcadores novamente na ordem otimizada
        optimizedPath.forEach((location, index) => {
            addMarkerForLocation(location, index);
        });
        
        // Atualizar a lista de locais
        updateLocationsList();
    }

    // Função auxiliar para verificar se dois locais estão na mesma cidade
    function isSameCity(loc1, loc2) {
        if (!loc1 || !loc2) return false;
        
        // Extrair cidade dos endereços
        const getCity = (address) => {
            const parts = address.split(',');
            if (parts.length > 0) {
                return parts[0].trim().toLowerCase();
            }
            return '';
        };
        
        const city1 = getCity(loc1.address);
        const city2 = getCity(loc2.address);
        
        return city1 === city2;
    }
    
    // Traçar a rota no mapa
    function drawRouteOnMap(pathLocations, vehicleType) {
        console.log("Iniciando drawRouteOnMap com", pathLocations.length, "locais");
        
        if (pathLocations.length < 2) {
            console.error("Pelo menos 2 pontos são necessários para traçar uma rota");
            // Restaurar o botão de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
            alert("Não há locais suficientes para traçar uma rota. Adicione mais locais.");
            return;
        }
        
        try {
            // Verificar e destacar pontos na mesma cidade da origem
            const origin = locations.find(loc => loc.isOrigin);
            
            if (origin) {
                pathLocations.forEach(location => {
                    if (!location.isOrigin && isSameCity(location, origin)) {
                        console.log(`Ponto ${location.name} está na mesma cidade da origem (${origin.name})`);
                        
                        // Encontrar o marcador correspondente e destacá-lo
                        const marker = markers.find(m => m.location.id === location.id);
                        if (marker) {
                            marker.marker.setIcon({
                                path: google.maps.SymbolPath.CIRCLE,
                                fillColor: '#FF4500', // Cor mais destacada
                                fillOpacity: 1,
                                strokeWeight: 2,
                                strokeColor: '#000',
                                scale: 12
                            });
                        }
                    }
                });
            }
            
            // Criar waypoints para o serviço de direções dentro do bloco try
            const waypoints = pathLocations.slice(1, -1).map(location => {
                console.log(`Waypoint: ${location.name}, Lat: ${location.latitude}, Lng: ${location.longitude}`);
                return {
                    location: new google.maps.LatLng(location.latitude, location.longitude),
                    stopover: true
                };
            });
            
            const originPoint = new google.maps.LatLng(
                pathLocations[0].latitude,
                pathLocations[0].longitude
            );
            console.log(`Origem: Lat: ${pathLocations[0].latitude}, Lng: ${pathLocations[0].longitude}`);
            
            const destinationPoint = new google.maps.LatLng(
                pathLocations[pathLocations.length - 1].latitude,
                pathLocations[pathLocations.length - 1].longitude
            );
            console.log(`Destino: Lat: ${pathLocations[pathLocations.length - 1].latitude}, Lng: ${pathLocations[pathLocations.length - 1].longitude}`);
            
            const request = {
                origin: originPoint,
                destination: destinationPoint,
                waypoints: waypoints,
                optimizeWaypoints: false, // Não otimizar, já temos a ordem do TSP
                travelMode: google.maps.TravelMode.DRIVING,
                avoidTolls: false
            };
            
            console.log("Solicitação directions:", request);
            
            // Versão GitHub Pages usa uma abordagem simplificada para evitar problemas
            if (window.location.href.includes('github.io')) {
                console.log("Usando método simplificado de rota para GitHub Pages");
                
                // No GitHub Pages, tentar um método mais direto com tolerância a falhas
                directionsService.route(request, (result, status) => {
                    if (status === google.maps.DirectionsStatus.OK) {
                        console.log("Rota obtida com sucesso");
                        directionsRenderer.setDirections(result);
                        
                        // Animar a rota (opcional)
                        animateRoute(result.routes[0].overview_path);
                        
                        // Ajustar o mapa para mostrar toda a rota
                        const bounds = new google.maps.LatLngBounds();
                        pathLocations.forEach(location => {
                            bounds.extend(new google.maps.LatLng(location.latitude, location.longitude));
                        });
                        map.fitBounds(bounds);
                    } else {
                        console.error("Erro ao traçar rota:", status);
                        
                        // Restaurar o botão de otimizar
                        const optimizeBtn = document.getElementById('optimize-route');
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        optimizeBtn.disabled = false;
                        
                        alert(`Não foi possível calcular a rota (${status}). Tente novamente com outros locais.`);
                    }
                });
            } else {
                // Versão normal com timeout e Promise
                // Adicionar timeout para evitar problemas de API
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("Timeout ao solicitar rota do Google Maps")), 10000);
                });
                
                // Converter o callback do Google Maps em Promise para poder usar com timeout
                const directionsPromise = new Promise((resolve, reject) => {
                    directionsService.route(request, (result, status) => {
                        if (status === google.maps.DirectionsStatus.OK) {
                            resolve(result);
                        } else {
                            reject(new Error(`Erro ao traçar rota: ${status}`));
                        }
                    });
                });
                
                // Usar Promise.race para implementar o timeout
                Promise.race([directionsPromise, timeoutPromise])
                .then(result => {
                    console.log("Rota obtida com sucesso");
                    directionsRenderer.setDirections(result);
                    
                    // Animar a rota (opcional)
                    animateRoute(result.routes[0].overview_path);
                    
                    // Ajustar o mapa para mostrar toda a rota
                    const bounds = new google.maps.LatLngBounds();
                    pathLocations.forEach(location => {
                        bounds.extend(new google.maps.LatLng(location.latitude, location.longitude));
                    });
                    map.fitBounds(bounds);
                })
                .catch(error => {
                    console.error("Erro ao traçar rota:", error);
                    
                    // Limpar estado de carregamento
                    const optimizeBtn = document.getElementById('optimize-route');
                    optimizeBtn.innerHTML = 'Otimizar Rota';
                    optimizeBtn.disabled = false;
                    
                    // Mostrar mensagem amigável
                    alert("Não foi possível calcular a rota. Por favor, tente novamente ou adicione outros destinos.");
                    
                    // Reverter para a visualização normal dos marcadores
                    markers.forEach(markerObj => {
                        const idx = locations.findIndex(loc => loc.id === markerObj.location.id);
                        const isOrigin = markerObj.location.isOrigin;
                        
                        if (idx >= 0) {
                            const markerLabel = isOrigin ? 'O' : (idx).toString();
                            const markerColor = isOrigin ? '#FF0000' : '#1976D2';
                            
                            markerObj.marker.setIcon({
                                path: google.maps.SymbolPath.CIRCLE,
                                fillColor: markerColor,
                                fillOpacity: 1,
                                strokeWeight: 0,
                                scale: 12
                            });
                            
                            markerObj.marker.setLabel({
                                text: markerLabel,
                                color: 'white',
                                fontSize: '14px',
                                fontWeight: 'bold'
                            });
                        }
                    });
                });
            
        } catch (error) {
            console.error("Erro ao processar a rota:", error);
            
            // Restaurar o botão de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
            
            // Alertar o usuário
            alert("Ocorreu um erro ao processar a rota. Por favor, tente novamente.");
        }
    }

    // Animar a rota desenhando progressivamente
    function animateRoute(path) {
        // Se já existir uma rota, removê-la
        if (routePath) {
            routePath.setMap(null);
        }
        
        // Criar uma nova polyline para a rota
        routePath = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: '#1976D2',
            strokeOpacity: 1.0,
            strokeWeight: 5,
            map: map
        });
        
        // Animação step-by-step
        let index = 0;
        const interval = 20; // ms entre cada ponto
        
        function animate() {
            if (index < path.length) {
                routePath.getPath().push(path[index]);
                index++;
                routeAnimationTimeout = setTimeout(animate, interval);
            }
        }
        
        animate();
    }

    // Mostrar pontos de interesse ao longo da rota
    function showPointsOfInterestOnRoute(pathLocations) {
        // Limpar marcadores anteriores
        clearPOIMarkers();
        
        // Se a opção de mostrar POIs estiver desativada, retornar
        if (!showPOIs) return;
        
        // Extrair nomes das cidades na rota
        const citiesOnRoute = pathLocations.map(loc => {
            // Extrair nome da cidade do endereço
            const parts = loc.address.split(',');
            return parts[0].trim();
        });
        
        // Filtrar POIs que estão nas cidades da rota
        const poisOnRoute = mockData.pointsOfInterest.filter(poi => 
            citiesOnRoute.some(city => poi.cityName.includes(city))
        );
        
        // Adicionar marcadores para os POIs
        poisOnRoute.forEach(poi => {
            let icon;
            
            // Ícone baseado no tipo de POI
            switch (poi.type) {
                case 'toll':
                    icon = {
                        path: 'M-2,-2 L2,-2 L2,2 L-2,2 Z', // Quadrado
                        fillColor: '#4caf50',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#007700',
                        scale: 6,
                        labelOrigin: new google.maps.Point(0, 0)
                    };
                    break;
                case 'weighStation':
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#ff9800',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#b26a00',
                        scale: 6
                    };
                    break;
                case 'gasStation':
                    icon = {
                        path: 'M-2,-2 L2,-2 L0,2 Z', // Triângulo
                        fillColor: '#2196f3',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#0069c0',
                        scale: 6
                    };
                    break;
                default:
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#9c27b0',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#6a0080',
                        scale: 6
                    };
            }
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: { lat: poi.latitude, lng: poi.longitude },
                map: map,
                title: poi.name,
                icon: icon,
                zIndex: 50
            });
            
            // Adicionar listener para mostrar tooltip ao passar o mouse
            marker.addListener('mouseover', function() {
                showTooltip(marker, poi);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Armazenar o marcador
            poiMarkers.push(marker);
        });
    }

    // Mostrar eventos para as cidades na rota
    function showEventsForCitiesOnRoute(pathLocations) {
        console.log("Exibindo eventos para locais na rota");
        
        // Limpar a lista de eventos
        const eventsListContainer = document.getElementById('events-list');
        eventsListContainer.innerHTML = '';
        
        // Limpar marcadores anteriores
        clearEventMarkers();
        
        // Verificar se há eventos disponíveis
        if (!mockData.cityEvents || mockData.cityEvents.length === 0) {
            console.error("Dados de eventos não disponíveis!");
            eventsListContainer.innerHTML = '<p class="text-muted">Erro: Dados de eventos não disponíveis.</p>';
            return;
        }
        
        // Ajustar as datas para o formato atual (maio de 2025 mencionado no cabeçalho)
        const currentYear = 2025;
        const currentMonth = 5; // maio
        
        // Extrair nomes das cidades na rota
        const citiesOnRoute = pathLocations.map(loc => {
            const parts = loc.address.split(',');
            if (parts.length > 0) {
                // Limpar a parte do CEP se estiver presente
                let city = parts[0].trim();
                if (city.startsWith('CEP:')) {
                    city = parts[1].trim();
                }
                return city;
            }
            return '';
        }).filter(city => city !== '');
        
        // Listar cidades na rota para debug
        console.log("Procurando eventos nas cidades:", citiesOnRoute);
        
        // Obter datas do filtro
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        console.log("Intervalo de datas:", startDate, "a", endDate);
        
        // Se não tiver cidades na rota, mostrar mensagem
        if (citiesOnRoute.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Adicione locais e calcule uma rota para ver eventos.</p>';
            return;
        }
        
        // Criação de eventos para o ano atual se não existirem
        if (mockData.cityEvents.length === 0 || 
            (mockData.cityEvents[0].startDate && 
             new Date(mockData.cityEvents[0].startDate).getFullYear() < currentYear)) {
            
            // Atualizar as datas dos eventos existentes para o ano atual
            mockData.cityEvents.forEach(event => {
                const oldStartDate = new Date(event.startDate);
                const oldEndDate = new Date(event.endDate);
                
                event.startDate = new Date(
                    currentYear,
                    oldStartDate.getMonth(),
                    oldStartDate.getDate()
                ).toISOString().split('T')[0];
                
                event.endDate = new Date(
                    currentYear,
                    oldEndDate.getMonth(),
                    oldEndDate.getDate()
                ).toISOString().split('T')[0];
            });
            
            console.log("Datas dos eventos atualizadas para", currentYear);
        }
    
        // Verificar datas do filtro
        let filterStart = null;
        let filterEnd = null;
        
        // Se houver datas no filtro, usá-las, senão usar maio como padrão
        if (startDate) {
            filterStart = new Date(startDate);
            console.log("Data de início do filtro:", filterStart);
        } else {
            filterStart = new Date(currentYear, 4, 1); // Maio (mês 4)
            console.log("Usando data de início padrão (1º de maio):", filterStart);
        }
        
        if (endDate) {
            filterEnd = new Date(endDate);
            console.log("Data de fim do filtro:", filterEnd);
        } else {
            filterEnd = new Date(currentYear, 4, 31); // 31 de maio
            console.log("Usando data de fim padrão (31 de maio):", filterEnd);
        }
        
        // Adicionar 1 dia ao final para inclusão completa
        filterEnd.setDate(filterEnd.getDate() + 1);
        
        // Debug das datas
        console.log("Período de filtro aplicado:", 
                    filterStart.toLocaleDateString('pt-BR'), 
                    "a", 
                    (new Date(filterEnd - 86400000)).toLocaleDateString('pt-BR'));
        
        // Filtrar eventos que estão nas cidades da rota e no período selecionado
        let eventsOnRoute = mockData.cityEvents.filter(event => {
            const eventCity = event.cityName;
            
            // Garantir que as datas dos eventos estão corretas (formato string YYYY-MM-DD)
            if (typeof event.startDate === 'string' && event.startDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
                var eventStart = new Date(event.startDate + "T00:00:00");
            } else {
                console.warn(`Data de início inválida para o evento ${event.name}:`, event.startDate);
                return false;
            }
            
            if (typeof event.endDate === 'string' && event.endDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
                var eventEnd = new Date(event.endDate + "T23:59:59");
            } else {
                console.warn(`Data de fim inválida para o evento ${event.name}:`, event.endDate);
                return false;
            }
            
            console.log(`Avaliando evento: ${event.name}, ${eventCity}, ${event.startDate} - ${event.endDate}`);
            
            // Verificar se a cidade do evento está na rota (comparação mais flexível)
            const isInCity = citiesOnRoute.some(city => {
                if (!city || !eventCity) return false;
                return eventCity.toLowerCase().includes(city.toLowerCase()) || 
                       city.toLowerCase().includes(eventCity.toLowerCase());
            });
            
            // Verificar se está dentro do intervalo de datas
            const isInDateRange = eventStart <= filterEnd && eventEnd >= filterStart;
            
            // Depuração detalhada
            console.log(`Evento ${event.name} - Na rota: ${isInCity ? 'SIM' : 'NÃO'}, No período: ${isInDateRange ? 'SIM' : 'NÃO'}`);
            
            // Para debug
            if (isInCity && isInDateRange) {
                console.log(`Evento qualificado: ${event.name} em ${eventCity} (${event.startDate} a ${event.endDate})`);
            }
            
            return isInCity && isInDateRange;
        });
        
        // Se não houver eventos, mostrar mensagem
        if (eventsOnRoute.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado para o período e cidades selecionados.</p>';
            return;
        }
        
        // Limpar marcadores anteriores
        clearEventMarkers();
        
        // Ordenar eventos por data
        eventsOnRoute.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        
        // Adicionar cada evento à lista
        eventsOnRoute.forEach(event => {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Garantir que as datas são objetos Date válidos
            let startDate, endDate;
            
            try {
                // Tentar criar objetos Date a partir das strings de data
                if (typeof event.startDate === 'string') {
                    startDate = new Date(event.startDate + "T00:00:00");
                } else {
                    startDate = new Date(event.startDate);
                }
                
                if (typeof event.endDate === 'string') {
                    endDate = new Date(event.endDate + "T00:00:00");
                } else {
                    endDate = new Date(event.endDate);
                }
                
                // Verificar se as datas são válidas
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    throw new Error("Data inválida");
                }
            } catch (e) {
                console.error("Erro ao processar data para o evento:", event.name, e);
                // Usar a data atual como fallback
                startDate = new Date();
                endDate = new Date();
            }
            
            // Formatar para exibição usando o locale pt-BR
            const formattedStartDate = startDate.toLocaleDateString('pt-BR');
            const formattedEndDate = endDate.toLocaleDateString('pt-BR');
            const dateText = formattedStartDate === formattedEndDate ? 
                            formattedStartDate : 
                            `${formattedStartDate} - ${formattedEndDate}`;
                            
            console.log(`Evento listado: ${event.name}, Datas: ${event.startDate} -> ${formattedStartDate}`);
            
            // Definir classe baseada no tipo de evento
            const eventTypeClass = event.isHoliday ? 'holiday' : 'event';
            
            eventItem.innerHTML = `
                <div class="event-name">${event.name} 
                    <span class="event-type ${eventTypeClass}">${event.isHoliday ? 'Feriado' : 'Evento'}</span>
                    <span class="restriction-level ${event.restrictionLevel}">${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</span>
                </div>
                <div class="event-date">${event.cityName} | ${dateText}</div>
                <div class="event-description">${event.description}</div>
            `;
            
            eventsListContainer.appendChild(eventItem);
            
            // Adicionar marcador no mapa para o evento
            addEventMarker(event, eventsOnRoute.indexOf(event));
            
            // Criar linkagem visual - clicar no evento da lista centraliza o mapa no evento
            eventItem.addEventListener('click', () => {
                // Encontrar o marcador correspondente
                const marker = eventMarkers.find(m => m.getTitle()?.includes(event.name));
                if (marker) {
                    // Centralizar o mapa no evento
                    map.panTo(marker.getPosition());
                    map.setZoom(13); // Aproximar o mapa
                    
                    // Simular um hover para mostrar o tooltip
                    google.maps.event.trigger(marker, 'mouseover');
                    
                    // Piscar o marcador para chamar atenção
                    const originalIcon = marker.getIcon();
                    marker.setAnimation(google.maps.Animation.BOUNCE);
                    
                    // Parar a animação após um curto período
                    setTimeout(() => {
                        marker.setAnimation(null);
                    }, 1500);
                }
            });
        });
    }

    // Adicionar marcador para um evento
    function addEventMarker(event, index) {
        // Tentar obter as coordenadas do evento usando a função de geocodificação
        const eventCity = event.cityName;
        
        // Se não tiver a cidade, não pode adicionar o marcador
        if (!eventCity) {
            console.warn(`Cidade não encontrada para o evento ${event.name}`);
            return;
        }
        
        // Verificar se já existe um marcador para este evento
        const existingMarker = eventMarkers.find(m => 
            m.getTitle && m.getTitle().includes(event.name)
        );
        
        if (existingMarker) {
            console.log(`Marcador para evento ${event.name} já existe. Ignorando duplicidade.`);
            return;
        }
        
        // Obter coordenadas da cidade usando a nossa função de geocodificação ou Replit
        let position;
        
        // Usar findCityByName para localidades conhecidas
        if (findCityByName) {
            const cityCoords = findCityByName(eventCity.toLowerCase());
            if (cityCoords) {
                position = {
                    lat: cityCoords.lat,
                    lng: cityCoords.lng
                };
                console.log(`Encontrou coordenadas para ${eventCity} via findCityByName`);
            }
        }
        
        // Se não encontrou posição, tentar pelo objeto de localização
        if (!position) {
            const cityLocation = locations.find(loc => 
                loc.address && 
                loc.address.toLowerCase().includes(eventCity.toLowerCase())
            );
            
            if (cityLocation && cityLocation.latitude && cityLocation.longitude) {
                position = {
                    lat: cityLocation.latitude,
                    lng: cityLocation.longitude
                };
                console.log(`Encontrou coordenadas para ${eventCity} via objeto location`);
            }
        }
        
        // Se ainda não encontrou, usar uma aproximação baseada em Dois Córregos
        if (!position) {
            // Criar uma posição próxima a Dois Córregos
            position = {
                lat: -22.3673 + (Math.random() - 0.5) * 0.05,
                lng: -48.3822 + (Math.random() - 0.5) * 0.05
            };
            console.log(`Usando posição aproximada para ${eventCity}`);
        }
        
        // Escolher ícone baseado no tipo de evento
        const isHoliday = event.isHoliday;
        const markerColor = isHoliday ? '#f44336' : '#ff9800';
        const markerPath = isHoliday 
            ? 'M -8,0 L 0,-8 L 8,0 L 0,8 Z' // losango para feriados
            : google.maps.SymbolPath.CIRCLE; // círculo para eventos
        
        const markerIcon = {
            path: markerPath,
            fillColor: markerColor,
            fillOpacity: 1,
            strokeWeight: 1,
            strokeColor: '#000',
            scale: isHoliday ? 1.2 : 8
        };
        
        // Criar o marcador
        const marker = new google.maps.Marker({
            position: position,
            map: map,
            title: `${event.name} (${eventCity})`,
            icon: markerIcon,
            zIndex: isHoliday ? 50 : 30 // Feriados ficam acima
        });
        
        // Conteúdo do tooltip com informações detalhadas
        const tooltipContent = `
            <div class="tooltip-title">${event.name}</div>
            <div>${eventCity}</div>
            <div>${formatarDataEvento(event.startDate)} - ${formatarDataEvento(event.endDate)}</div>
            <div>${event.description}</div>
            <div>Nível de restrição: ${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'Médio' : 'Baixo')}</div>
            ${isHoliday ? '<div class="holiday-badge">Feriado/Aniversário da Cidade</div>' : ''}
        `;
        
        // Adicionar listener para mostrar tooltip ao passar o mouse
        marker.addListener('mouseover', function() {
            showTooltip(marker, { tooltipContent });
        });
        
        marker.addListener('mouseout', function() {
            hideTooltip();
        });
        
        // Armazenar o marcador
        eventMarkers.push(marker);
    }

    // Mostrar restrições para caminhões nas cidades da rota
    function showTruckRestrictionsForCitiesOnRoute(pathLocations, vehicleType) {
        console.log("Exibindo restrições para veículo:", vehicleType);
        
        // Limpar a lista de restrições
        const restrictionsListContainer = document.getElementById('restrictions-list');
        restrictionsListContainer.innerHTML = '';
        
        // Verificar se há restrições disponíveis
        if (!mockData.truckRestrictions || mockData.truckRestrictions.length === 0) {
            console.error("Dados de restrições não disponíveis!");
            restrictionsListContainer.innerHTML = '<p class="text-muted">Erro: Dados de restrições não disponíveis.</p>';
            return;
        }
        
        // Extrair nomes das cidades na rota
        const citiesOnRoute = pathLocations.map(loc => {
            const parts = loc.address.split(',');
            if (parts.length > 0) {
                // Limpar a parte do CEP se estiver presente
                let city = parts[0].trim();
                if (city.startsWith('CEP:')) {
                    city = parts[1].trim();
                }
                return city;
            }
            return '';
        }).filter(city => city !== '');
        
        // Se não tiver cidades na rota, mostrar mensagem
        if (citiesOnRoute.length === 0) {
            restrictionsListContainer.innerHTML = '<p class="text-muted">Adicione locais e calcule uma rota para ver restrições de caminhões.</p>';
            return;
        }
        
        console.log("Verificando restrições para o veículo:", vehicleType, "nas cidades:", citiesOnRoute);
        
        // Filtrar restrições que afetam o tipo de veículo selecionado e estão nas cidades da rota
        const restrictionsOnRoute = mockData.truckRestrictions.filter(restriction => {
            const restrictionCity = restriction.cityName;
            
            // Verificar se a cidade da restrição está na rota (comparação mais flexível)
            const isInCity = citiesOnRoute.some(city => {
                if (!city || !restrictionCity) return false;
                return restrictionCity.toLowerCase().includes(city.toLowerCase()) || 
                       city.toLowerCase().includes(restrictionCity.toLowerCase());
            });
            
            const affectsVehicle = restriction.affectedVehicles.includes(vehicleType);
            
            // Debug
            if (isInCity && affectsVehicle) {
                console.log(`Restrição encontrada em ${restrictionCity} que afeta o veículo ${vehicleType}`);
            }
            
            return isInCity && affectsVehicle;
        });
        
        // Se não houver restrições, mostrar mensagem
        if (restrictionsOnRoute.length === 0) {
            restrictionsListContainer.innerHTML = '<p class="text-muted">Nenhuma restrição encontrada para o tipo de veículo selecionado nas cidades da rota.</p>';
            return;
        }
        
        // Adicionar cada restrição à lista
        restrictionsOnRoute.forEach(restriction => {
            const restrictionItem = document.createElement('div');
            restrictionItem.className = 'restriction-item';
            
            // Texto para tipo de dia
            let dayTypeText = '';
            switch (restriction.dayType) {
                case 'weekday': dayTypeText = 'Dias úteis'; break;
                case 'weekend': dayTypeText = 'Fins de semana'; break;
                case 'all': dayTypeText = 'Todos os dias'; break;
            }
            
            restrictionItem.innerHTML = `
                <div class="restriction-city">${restriction.cityName} 
                    <span class="restriction-type ${restriction.restrictionType}">${restriction.restrictionType === 'partial' ? 'Parcial' : (restriction.restrictionType === 'total' ? 'Total' : 'Rodízio')}</span>
                </div>
                <div class="restriction-time">${dayTypeText} | ${restriction.startTime} - ${restriction.endTime}</div>
                <div class="restriction-description">${restriction.description}</div>
            `;
            
            restrictionsListContainer.appendChild(restrictionItem);
        });
    }

    // Atualizar o resumo da rota
    function updateRouteSummary(tspResult, vehicleType) {
        // Obter os dados do veículo selecionado
        const selectedVehicle = mockData.vehicleTypes.find(v => v.type === vehicleType);
        
        // Calcular custos
        const tollCost = mockData.pointsOfInterest
            .filter(poi => poi.type === 'toll')
            .reduce((sum, toll) => sum + (toll.cost || 0), 0);
        
        const fuelConsumption = tspResult.distance * selectedVehicle.fuelConsumption / 100; // L/100km
        const fuelCost = fuelConsumption * 5.0; // Preço médio do diesel: R$ 5,00/L
        const totalCost = fuelCost + tollCost + (tspResult.distance * selectedVehicle.costPerKm);
        
        // Tempo estimado (baseado na velocidade média do veículo)
        const estimatedTime = tspResult.distance / selectedVehicle.averageSpeed; // em horas
        
        // Atualizar o conteúdo do resumo
        const summaryContainer = document.getElementById('route-summary');
        summaryContainer.style.display = 'block';
        
        // Formatar o tempo em horas e minutos
        const hours = Math.floor(estimatedTime);
        const minutes = Math.round((estimatedTime - hours) * 60);
        const timeFormatted = `${hours}h ${minutes}min`;
        
        // Construir a lista de cidades na rota
        const citiesOnRoute = tspResult.path.map(loc => {
            const parts = loc.address.split(',');
            return parts[0].trim();
        });
        const uniqueCities = [...new Set(citiesOnRoute)];
        
        // Contar pedágios na rota
        const tollsOnRoute = mockData.pointsOfInterest.filter(poi => 
            poi.type === 'toll' && uniqueCities.some(city => poi.cityName.includes(city))
        );
        
        summaryContainer.innerHTML = `
            <div class="summary-header">Resumo da Rota Otimizada</div>
            <div class="row">
                <div class="col-md-6">
                    <p><strong>Distância total:</strong> ${tspResult.distance.toFixed(1)} km</p>
                    <p><strong>Tempo estimado:</strong> ${timeFormatted}</p>
                    <p><strong>Consumo de combustível:</strong> ${fuelConsumption.toFixed(1)} litros</p>
                </div>
                <div class="col-md-6">
                    <p><strong>Custo de combustível:</strong> R$ ${fuelCost.toFixed(2)}</p>
                    <p><strong>Custo de pedágios:</strong> R$ ${tollCost.toFixed(2)} (${tollsOnRoute.length} pedágios)</p>
                    <p><strong>Custo total estimado:</strong> R$ ${totalCost.toFixed(2)}</p>
                </div>
            </div>
            
            <div class="mt-3">
                <div class="summary-header">Sequência de Cidades</div>
                <ol id="route-steps">
                    ${tspResult.path.map(location => `<li>${location.name} (${location.address})</li>`).join('')}
                </ol>
            </div>
        `;
    }

    // Filtrar eventos por data - agora aplicado a todas as cidades conhecidas
    function filterEventsByDate() {
        // Obter o tipo de veículo selecionado
        const vehicleType = document.querySelector('input[name="vehicle-type"]:checked')?.value || 'truck1';
        console.log("Filtrando eventos por data para veículo:", vehicleType);
            
        // Sempre tentamos mostrar eventos, mesmo sem uma rota calculada
        if (locations && locations.length > 0) {
            console.log("Atualizando eventos com novas datas...");
            
            // Obter datas do filtro
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            // Verificar se ambas as datas estão presentes
            if (!startDate || !endDate) {
                alert("Por favor selecione as datas de início e fim para filtrar os eventos.");
                return;
            }
            
            console.log(`Filtrando eventos no período: ${startDate} até ${endDate}`);
            
            try {
                // Preparar dados de mockData para verificar se estão corretos
                if (!mockData.cityEvents || !Array.isArray(mockData.cityEvents)) {
                    console.error("Dados de eventos inválidos:", mockData.cityEvents);
                    mockData.cityEvents = []; // Redefine para evitar erros
                }
                
                if (!mockData.truckRestrictions || !Array.isArray(mockData.truckRestrictions)) {
                    console.error("Dados de restrições inválidos:", mockData.truckRestrictions);
                    mockData.truckRestrictions = []; // Redefine para evitar erros
                }
                
                // Mostrar eventos para as cidades da rota ativa ou todas as cidades
                showEventsForCitiesOnRoute(locations);
                
                // Também atualizar restrições de caminhões
                showTruckRestrictionsForCitiesOnRoute(locations, vehicleType);
            } catch (error) {
                console.error("Erro ao filtrar eventos por data:", error);
                alert("Ocorreu um erro ao filtrar os eventos. Veja o console para detalhes.");
            }
        } else {
            alert("Adicione ao menos um local para ver eventos nas cidades.");
        }
    }

    // Salvar a rota
    function saveRoute() {
        const routeName = document.getElementById('route-name').value;
        if (!routeName) {
            alert("Por favor, dê um nome para a rota antes de salvar.");
            return;
        }
        
        alert(`Rota "${routeName}" salva com sucesso!`);
    }

    // Imprimir a rota
    function printRoute() {
        window.print();
    }

    // Zoom para mostrar todos os marcadores
    function zoomToFitAllMarkers() {
        if (markers.length === 0) return;
        
        const bounds = new google.maps.LatLngBounds();
        markers.forEach(markerObj => {
            bounds.extend(markerObj.marker.getPosition());
        });
        
        map.fitBounds(bounds);
    }

    // Alternador para mostrar/esconder pontos de interesse
    function togglePointsOfInterest() {
        showPOIs = !showPOIs;
        
        // Ajustar visibilidade dos marcadores
        poiMarkers.forEach(marker => {
            marker.setVisible(showPOIs);
        });
        
        // Se tivermos uma rota ativa e quisermos mostrar POIs, recarregar os POIs
        if (showPOIs && directionsRenderer.getDirections()) {
            showPointsOfInterestOnRoute(locations);
        }
    }

    // Criar tooltip personalizado
    function createCustomTooltip() {
        customTooltip = document.createElement('div');
        customTooltip.className = 'custom-tooltip';
        customTooltip.style.display = 'none';
        document.body.appendChild(customTooltip);
    }

    // Mostrar tooltip
    function showTooltip(marker, data) {
        // Se o dado tiver conteúdo de tooltip predefinido, usar esse
        if (data.tooltipContent) {
            customTooltip.innerHTML = data.tooltipContent;
        } else {
            // Caso contrário, construir baseado no tipo de ponto de interesse
            let content = `<div class="tooltip-title">${data.name}</div>`;
            
            if (data.type === 'toll') {
                content += `
                    <div>Pedágio na rodovia ${data.highway}</div>
                    <div>Valor: R$ ${data.cost.toFixed(2)}</div>
                `;
            } else if (data.type === 'weighStation') {
                content += `
                    <div>Balança na rodovia ${data.highway}</div>
                    <div>Status: ${data.isActive ? 'Ativa' : 'Inativa'}</div>
                `;
            } else if (data.type === 'gasStation') {
                content += `
                    <div>Posto de combustível</div>
                    <div>Serviços: ${formatServices(data.services)}</div>
                `;
            } else {
                content += `
                    <div>Ponto de interesse em ${data.cityName}</div>
                `;
            }
            
            customTooltip.innerHTML = content;
        }
        
        // Posicionar o tooltip acima do marcador
        const projection = map.getProjection();
        const position = marker.getPosition();
        const pixelOffset = overlay.getProjection().fromLatLngToDivPixel(position);
        
        customTooltip.style.left = pixelOffset.x + 'px';
        customTooltip.style.top = (pixelOffset.y - 120) + 'px'; // Posicionar acima do marcador
        customTooltip.style.display = 'block';
    }

    // Esconder tooltip
    function hideTooltip() {
        if (customTooltip) {
            customTooltip.style.display = 'none';
        }
    }

    // Formatar lista de serviços
    function formatServices(services) {
        if (!services || !Array.isArray(services)) return '';
        
        const serviceNames = {
            'food': 'Alimentação',
            'rest': 'Área de descanso',
            'shower': 'Chuveiro',
            'mechanic': 'Mecânico',
            'tire': 'Borracharia'
        };
        
        return services.map(s => serviceNames[s] || s).join(', ');
    }

    // Implementação avançada do algoritmo do Caixeiro Viajante (TSP)
    // Idêntico ao comportamento da versão Replit
    function solveAdvancedTSP(origin, destinations, includeReturn) {
        // Se não houver destinos, retornar apenas a origem
        if (!destinations.length) {
            return {
                path: [origin],
                distance: 0
            };
        }
        
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Verificar se há pontos na mesma cidade da origem
        // Se houver, devem ser visitados primeiro
        const sameCity = [];
        const otherCities = [];
        
        destinations.forEach(dest => {
            if (isSameCity(dest, origin)) {
                sameCity.push(dest);
            } else {
                otherCities.push(dest);
            }
        });
        
        // Se há pontos na mesma cidade, priorizá-los
        if (sameCity.length > 0) {
            // Colocar os pontos da mesma cidade primeiro, depois resolver o restante
            console.log(`Encontrado ${sameCity.length} pontos na mesma cidade da origem. Priorizando.`);
            
            // Calcular a distância para priorizar essa ordem
            let sameCityDist = 0;
            const sameCityPath = [origin, ...sameCity];
            
            for (let i = 0; i < sameCityPath.length - 1; i++) {
                sameCityDist += calculateDistance(
                    sameCityPath[i].latitude, sameCityPath[i].longitude,
                    sameCityPath[i+1].latitude, sameCityPath[i+1].longitude
                );
            }
            
            // Se não temos outros pontos, retornar apenas os da mesma cidade
            if (otherCities.length === 0) {
                return {
                    path: sameCityPath,
                    distance: sameCityDist
                };
            }
            
            // Resolver o TSP para os outros pontos
            const otherResult = solveBasicTSP(sameCityPath[sameCityPath.length-1], otherCities, includeReturn);
            
            // Combinar os caminhos
            const fullPath = [...sameCityPath.slice(0, -1), ...otherResult.path];
            const fullDistance = sameCityDist + otherResult.distance;
            
            return {
                path: fullPath,
                distance: fullDistance
            };
        }
        
        return solveBasicTSP(origin, destinations, includeReturn);
    }
    
    // Versão básica do TSP para cidades diferentes
    function solveBasicTSP(origin, destinations, includeReturn) {
        // Inicializar a distância total
        let totalDistance = 0;
        
        // Matriz de distâncias entre todos os pontos
        const points = [origin, ...destinations];
        const numPoints = points.length;
        const distMatrix = Array(numPoints).fill().map(() => Array(numPoints).fill(0));
        
        // Preencher a matriz de distâncias
        for (let i = 0; i < numPoints; i++) {
            for (let j = i + 1; j < numPoints; j++) {
                const dist = calculateDistance(
                    points[i].latitude, points[i].longitude,
                    points[j].latitude, points[j].longitude
                );
                distMatrix[i][j] = dist;
                distMatrix[j][i] = dist; // A matriz é simétrica
            }
        }
        
        // Método Nearest Insertion: começamos com a rota origem -> ponto mais próximo -> origem
        // e iterativamente adicionamos o melhor ponto para inserir na rota atual
        
        // Inicializar com o ponto mais próximo da origem
        let bestDist = Infinity;
        let bestIdx = -1;
        
        for (let i = 1; i < numPoints; i++) {
            if (distMatrix[0][i] < bestDist) {
                bestDist = distMatrix[0][i];
                bestIdx = i;
            }
        }
        
        // Rota inicial: origem -> ponto mais próximo
        let tour = [0, bestIdx];
        let remaining = Array.from({length: numPoints - 1}, (_, i) => i + 1);
        remaining.splice(remaining.indexOf(bestIdx), 1);
        
        // Calcular a distância inicial
        totalDistance = bestDist;
        
        // Usar a função auxiliar para completar o algoritmo
        const result = finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn);
        tour = result.tour;
        totalDistance = result.totalDistance;
        
        // Se não for para incluir retorno, remover o último link (do último ponto de volta à origem)
        if (!includeReturn && tour.length > 1) {
            const last = tour[tour.length - 1];
            totalDistance -= distMatrix[last][0];
            // Não removemos a origem do início porque a rota deve começar na origem
        }
        
        // Converter os índices de tour de volta para os pontos reais
        const path = tour.map(idx => points[idx]);
        
        // Ajustar a rota se não for para incluir retorno à origem
        if (!includeReturn) {
            // Garante que a rota não termine voltando para a origem
            if (path[path.length - 1] === origin) {
                path.pop();
            }
        } else {
            // Garante que a rota termine na origem
            if (path[path.length - 1] !== origin) {
                path.push(origin);
                
                // Adicionar a distância de retorno
                const lastPoint = path[path.length - 2];
                const returnDistance = calculateDistance(
                    lastPoint.latitude, lastPoint.longitude,
                    origin.latitude, origin.longitude
                );
                totalDistance += returnDistance;
            }
        }
        
        return {
            path: path,
            distance: totalDistance
        };
    }
    
    // Manteremos a versão simples para compatibilidade
    function solveTSP(origin, destinations, includeReturn) {
        return solveAdvancedTSP(origin, destinations, includeReturn);
    }
    
    // Função para finalizar o algoritmo TSP básico
    function finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn) {
        // Enquanto houver pontos não visitados
        while (remaining.length > 0) {
            let bestInsertion = {
                point: -1,
                position: -1,
                cost: Infinity
            };
            
            // Para cada ponto restante
            for (let i = 0; i < remaining.length; i++) {
                const point = remaining[i];
                
                // Para cada possível posição de inserção no tour atual
                for (let j = 1; j <= tour.length; j++) {
                    const prev = tour[j-1];
                    const next = j < tour.length ? tour[j] : tour[0]; // Se estamos no final, o próximo é o início
                    
                    // Calcular o custo de inserção = dist(prev, point) + dist(point, next) - dist(prev, next)
                    const insertionCost = distMatrix[prev][point] + 
                                         distMatrix[point][next] -
                                         distMatrix[prev][next];
                    
                    if (insertionCost < bestInsertion.cost) {
                        bestInsertion = {
                            point: point,
                            position: j,
                            cost: insertionCost
                        };
                    }
                }
            }
            
            // Inserir o melhor ponto na melhor posição
            tour.splice(bestInsertion.position, 0, bestInsertion.point);
            remaining.splice(remaining.indexOf(bestInsertion.point), 1);
            
            // Atualizar a distância total
            totalDistance += bestInsertion.cost;
        }
        
        return { tour, totalDistance };
    }

    // Calcular distância entre dois pontos usando a fórmula de Haversine
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Raio da Terra em km
        const dLat = deg2rad(lat2 - lat1);
        const dLon = deg2rad(lon2 - lon1);
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
            Math.sin(dLon/2) * Math.sin(dLon/2); 
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        const distance = R * c; // Distância em km
        return distance;
    }

    // Converter graus para radianos
    function deg2rad(deg) {
        return deg * (Math.PI/180);
    }

    // Classe para projeção de overlay personalizado
    class OverlayProjection {
        fromLatLngToDivPixel(latLng) {
            const scale = Math.pow(2, map.getZoom());
            const proj = map.getProjection();
            const bounds = map.getBounds();
            
            if (!proj || !bounds) {
                return { x: 0, y: 0 };
            }
            
            const nw = proj.fromLatLngToPoint(
                new google.maps.LatLng(
                    bounds.getNorthEast().lat(),
                    bounds.getSouthWest().lng()
                )
            );
            
            const point = proj.fromLatLngToPoint(latLng);
            
            return {
                x: Math.floor((point.x - nw.x) * scale),
                y: Math.floor((point.y - nw.y) * scale)
            };
        }
        
        fromDivPixelToLatLng(pixel) {
            return null; // Não precisamos desta funcionalidade
        }
    }

    // Criar um overlay personalizado para a projeção
    const overlay = new google.maps.OverlayView();
    overlay.draw = function() {};
    overlay.setMap(map);
    overlay.getProjection = function() {
        return new OverlayProjection();
    };

    // Expor funções necessárias globalmente
    window.removeLocation = removeLocation;
    </script>
</body>
</html>