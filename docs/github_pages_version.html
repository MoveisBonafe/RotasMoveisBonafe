<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Otimizador de Rotas para log√≠stica e transporte, com suporte a c√°lculo de rotas entre m√∫ltiplos pontos, otimiza√ß√£o de sequ√™ncia, e visualiza√ß√£o de eventos e restri√ß√µes em cidades brasileiras." />
    <meta name="keywords" content="otimizador de rotas, problema do caixeiro viajante, log√≠stica, transporte, planejamento de rotas, otimiza√ß√£o de entregas, Brasil, Google Maps, ped√°gios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas - Vers√£o GitHub Pages</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 380px;
            height: 100%;
            background-color: #f8f9fa;
            overflow-y: auto;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .map-container {
            flex: 1;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        /* Estilo para abas */
        .nav-tabs {
            margin-bottom: 15px;
        }
        .nav-tabs .nav-link {
            color: #495057;
            font-weight: 500;
        }
        .nav-tabs .nav-link.active {
            color: #1976D2;
            font-weight: 600;
        }
        /* Lista de localiza√ß√µes */
        .locations-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-address {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn-container {
            position: sticky;
            bottom: 0;
            background-color: #f8f9fa;
            padding: 15px 0;
            margin-top: 20px;
        }
        #optimize-route {
            width: 100%;
        }
        .marker-label {
            color: white;
            background-color: #1976D2;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 50%;
        }
        /* Controles do mapa */
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .map-control-btn {
            background-color: white;
            border: none;
            border-radius: 4px;
            margin-bottom: 5px;
            padding: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Estilo para o spinner de carregamento */
        .spinner-border {
            width: 1rem;
            height: 1rem;
        }
        /* Form de importa√ß√£o de arquivo */
        #file-import-form {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        /* Card para sele√ß√£o de ve√≠culo */
        .vehicle-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .vehicle-card {
            flex: 0 0 calc(33.33% - 10px);
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }
        .vehicle-card:hover {
            border-color: #1976D2;
            background-color: #f0f7ff;
        }
        .vehicle-card.selected {
            border-color: #1976D2;
            background-color: #e3f2fd;
            box-shadow: 0 0 5px rgba(25, 118, 210, 0.5);
        }
        .vehicle-icon {
            font-size: 24px;
            margin-bottom: 5px;
            color: #1976D2;
        }
        .vehicle-name {
            font-size: 12px;
            color: #333;
        }
        /* Tooltip personalizado */
        .custom-tooltip {
            position: absolute;
            background-color: white;
            border-radius: 4px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            max-width: 250px;
            z-index: 1000;
            display: none;
            pointer-events: none;
        }
        /* Quando a tela for pequena, a barra lateral ocupa toda a tela */
        @media (max-width: 768px) {
            .app-container {
                position: relative;
            }
            .sidebar {
                position: absolute;
                z-index: 1000;
                width: 100%;
                transform: translateX(-100%);
            }
            .sidebar.open {
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar com controles -->
        <div class="sidebar" id="sidebar">
            <h2 class="mb-4 text-center">Otimizador de Rotas</h2>
            
            <ul class="nav nav-tabs" id="appTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="locations-tab" data-bs-toggle="tab" data-bs-target="#locations" type="button" role="tab" aria-controls="locations" aria-selected="true">Localiza√ß√µes</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="events-tab" data-bs-toggle="tab" data-bs-target="#events" type="button" role="tab" aria-controls="events" aria-selected="false">Eventos</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="report-tab" data-bs-toggle="tab" data-bs-target="#report" type="button" role="tab" aria-controls="report" aria-selected="false">Relat√≥rio</button>
                </li>
            </ul>
            
            <div class="tab-content" id="appTabsContent">
                <!-- Aba de Localiza√ß√µes -->
                <div class="tab-pane fade show active" id="locations" role="tabpanel" aria-labelledby="locations-tab">
                    <!-- Formul√°rio de busca -->
                    <div class="mb-3">
                        <label for="location-search" class="form-label">Adicionar localiza√ß√£o</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="location-search" placeholder="Digite um endere√ßo...">
                            <button class="btn btn-primary" type="button" id="add-location">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Formul√°rio de importa√ß√£o de arquivo -->
                    <div id="file-import-form">
                        <label for="file-input" class="form-label">Importar localiza√ß√µes por arquivo</label>
                        <div class="input-group mb-2">
                            <input type="file" class="form-control" id="file-input" accept=".txt,.csv">
                            <button class="btn btn-outline-secondary" type="button" id="process-file">Importar</button>
                        </div>
                        <small class="text-muted">Formato: CEP,Nome (um por linha)</small>
                    </div>
                    
                    <!-- Filtro de data para eventos -->
                    <div class="row g-2 mb-3">
                        <div class="col-md-6">
                            <label for="locations-start-date" class="form-label">Data inicial</label>
                            <input type="date" class="form-control" id="locations-start-date">
                        </div>
                        <div class="col-md-6">
                            <label for="locations-end-date" class="form-label">Data final</label>
                            <input type="date" class="form-control" id="locations-end-date">
                        </div>
                    </div>
                    
                    <!-- Sele√ß√£o de ve√≠culo -->
                    <div class="mb-3">
                        <label class="form-label">Tipo de ve√≠culo</label>
                        <div class="vehicle-options" id="vehicle-options">
                            <!-- Os cards de ve√≠culos ser√£o adicionados pelo JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Lista de localiza√ß√µes -->
                    <h5>Pontos na rota</h5>
                    <div class="alert alert-primary" role="alert">
                        <strong>Origem:</strong> Dois C√≥rregos, SP
                    </div>
                    <div class="locations-list" id="locations-list">
                        <!-- Localiza√ß√µes ser√£o adicionadas aqui pelo JavaScript -->
                    </div>
                    
                    <!-- Bot√£o para otimizar -->
                    <div class="optimize-btn-container">
                        <button class="btn btn-primary" id="optimize-route">
                            <span id="optimize-button-text">Otimizar Rota</span>
                            <span id="optimize-spinner" class="spinner-border spinner-border-sm ms-2 d-none" role="status" aria-hidden="true"></span>
                        </button>
                    </div>
                </div>
                
                <!-- Aba de Eventos -->
                <div class="tab-pane fade" id="events" role="tabpanel" aria-labelledby="events-tab">
                    <!-- Filtro de data para eventos -->
                    <div class="row g-2 mb-3">
                        <div class="col-md-6">
                            <label for="events-start-date" class="form-label">Data inicial</label>
                            <input type="date" class="form-control" id="events-start-date">
                        </div>
                        <div class="col-md-6">
                            <label for="events-end-date" class="form-label">Data final</label>
                            <input type="date" class="form-control" id="events-end-date">
                        </div>
                    </div>
                    <div class="mb-3">
                        <button class="btn btn-primary w-100" id="filter-events">Filtrar Eventos</button>
                    </div>
                    <div id="events-list" class="list-group">
                        <!-- Eventos ser√£o adicionados aqui pelo JavaScript -->
                        <div class="text-center py-3 text-muted">
                            Nenhum evento encontrado. Adicione localiza√ß√µes e otimize a rota para ver eventos nas cidades do percurso.
                        </div>
                    </div>
                </div>
                
                <!-- Aba de Relat√≥rio -->
                <div class="tab-pane fade" id="report" role="tabpanel" aria-labelledby="report-tab">
                    <div id="route-report">
                        <div class="alert alert-info">
                            Otimize uma rota para gerar o relat√≥rio de viagem com dist√¢ncias, tempo estimado e custos.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div class="map-container">
            <button class="toggle-sidebar" id="toggle-sidebar">‚ò∞</button>
            <div id="map"></div>
            
            <!-- Controles do mapa -->
            <div class="map-controls">
                <button class="map-control-btn" id="zoom-to-fit" title="Ajustar zoom para ver todos os pontos">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z"/>
                    </svg>
                </button>
                <button class="map-control-btn" id="toggle-poi" title="Mostrar/ocultar pontos de interesse">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Primeiro load o script do bootstrap -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Agora definimos a fun√ß√£o callback para inicializar o maps -->
    <script>
        // Vari√°veis globais
        let map, directionsService, directionsRenderer, autocomplete;
        let markers = [];
        let poiMarkers = [];
        let eventMarkers = [];
        let customTooltip;
        let currentRoute = null;
        let showPOIs = false;
        
        // Fun√ß√£o callback que ser√° chamada quando o Google Maps API estiver carregado
        function initMapCallback() {
            console.log("Google Maps API carregada! Inicializando aplica√ß√£o...");
            
            // Inicializar o mapa
            initMap();
            
            // Inicializar autocompletar
            initAutocomplete();
            
            // Inicializar navega√ß√£o por abas
            initTabNavigation();
            
            // Inicializar eventos da UI
            initEventListeners();
            
            // Exibir a origem no mapa
            addMarkerForLocation(mockData.origin, 0);
            
            // Inicializar datas para o filtro de eventos
            const today = new Date();
            const nextMonth = new Date();
            nextMonth.setMonth(today.getMonth() + 1);
            
            document.getElementById('locations-start-date').valueAsDate = today;
            document.getElementById('locations-end-date').valueAsDate = nextMonth;
            document.getElementById('events-start-date').valueAsDate = today;
            document.getElementById('events-end-date').valueAsDate = nextMonth;
            
            // Adicionar eventos para selecionar o tipo de ve√≠culo nos cards
            setupVehicleOptions();
        }
        
        // Fun√ß√£o para lidar com erros de carregamento da API
        function handleGoogleMapsError() {
            console.error("Erro ao carregar Google Maps API");
            document.getElementById('map').innerHTML = 
                '<div style="text-align: center; padding: 20px; color: red; background-color: #ffe6e6; border-radius: 5px;">' +
                '<h3>Erro ao carregar o Google Maps</h3>' +
                '<p>Verifique sua conex√£o com a internet ou recarregue a p√°gina.</p>' +
                '<button class="btn btn-danger mt-3" onclick="window.location.reload()">Recarregar P√°gina</button>' +
                '</div>';
        }
        
        // Inicializa o mapa
        function initMap() {
            // Op√ß√µes do mapa
            const mapOptions = {
                center: { lat: -22.3673, lng: -48.3822 }, // Dois C√≥rregos
                zoom: 8,
                mapTypeControl: true,
                fullscreenControl: true,
                streetViewControl: true,
                zoomControl: true,
                gestureHandling: 'greedy' // Permite zoom com scroll sem precionar Ctrl
            };
            
            // Criar o mapa
            map = new google.maps.Map(document.getElementById("map"), mapOptions);
            console.log("Google Maps inicializado com sucesso!");
            
            // Inicializar o servi√ßo de dire√ß√µes
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true, // N√£o mostrar marcadores padr√£o do Google
                preserveViewport: true
            });
            directionsRenderer.setMap(map);
            
            // Criar o tooltip personalizado
            createCustomTooltip();
        }
        
        // Inicializa o autocomplete
        function initAutocomplete() {
            const input = document.getElementById('location-search');
            const options = {
                types: ['geocode'],
                componentRestrictions: { country: 'br' }
            };
            
            autocomplete = new google.maps.places.Autocomplete(input, options);
            autocomplete.addListener('place_changed', onPlaceSelected);
            console.log("Google Places API carregado com sucesso!");
        }
        
        // Inicializa a navega√ß√£o por abas
        function initTabNavigation() {
            const tabs = document.querySelectorAll('button[data-bs-toggle="tab"]');
            tabs.forEach(tab => {
                tab.addEventListener('shown.bs.tab', event => {
                    if (event.target.id === 'events-tab') {
                        updateEventsForRoute();
                    }
                });
            });
        }
        
        // Inicializa listeners de eventos
        function initEventListeners() {
            // Toggle da barra lateral em dispositivos m√≥veis
            document.getElementById('toggle-sidebar').addEventListener('click', function() {
                document.getElementById('sidebar').classList.toggle('open');
            });
            
            // Adicionar localiza√ß√£o
            document.getElementById('add-location').addEventListener('click', addLocationFromInput);
            
            // Importar arquivo
            document.getElementById('process-file').addEventListener('click', processFile);
            
            // Otimizar rota
            document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
            
            // Filtrar eventos
            document.getElementById('filter-events').addEventListener('click', filterEvents);
            
            // Bot√£o de ajuste de zoom
            document.getElementById('zoom-to-fit').addEventListener('click', zoomToFitMarkers);
            
            // Bot√£o de toggle de pontos de interesse
            document.getElementById('toggle-poi').addEventListener('click', togglePointsOfInterest);
        }
        
        // Configurar as op√ß√µes de ve√≠culo
        function setupVehicleOptions() {
            const vehicleOptionsContainer = document.getElementById('vehicle-options');
            vehicleOptionsContainer.innerHTML = '';
            
            mockData.vehicleTypes.forEach((vehicle, index) => {
                const vehicleCard = document.createElement('div');
                vehicleCard.className = 'vehicle-card' + (index === 0 ? ' selected' : '');
                vehicleCard.dataset.vehicleId = vehicle.id;
                
                // Selecionar √≠cone baseado no tipo de ve√≠culo
                let icon = '';
                switch(vehicle.type) {
                    case 'truck1':
                        icon = 'üöö';
                        break;
                    case 'truck2':
                        icon = 'üöõ';
                        break;
                    case 'truck3':
                        icon = 'üöö';
                        break;
                    case 'van':
                        icon = 'üöê';
                        break;
                    case 'car':
                        icon = 'üöó';
                        break;
                    default:
                        icon = 'üöó';
                }
                
                vehicleCard.innerHTML = `
                    <div class="vehicle-icon">${icon}</div>
                    <div class="vehicle-name">${vehicle.name}</div>
                `;
                
                vehicleCard.addEventListener('click', function() {
                    document.querySelectorAll('.vehicle-card').forEach(card => {
                        card.classList.remove('selected');
                    });
                    this.classList.add('selected');
                });
                
                vehicleOptionsContainer.appendChild(vehicleCard);
            });
        }
    </script>

    <!-- Carregamento dos dados de exemplo (substitua com chamadas de API em produ√ß√£o) -->
    <script>
        // Dados de amostra para a aplica√ß√£o GitHub Pages
        const mockData = {
            // Origem (Dois C√≥rregos)
            origin: {
                id: 1,
                name: "Dois C√≥rregos",
                address: "Dois C√≥rregos, SP, Brasil",
                zipCode: "17300-000",
                latitude: -22.3673,
                longitude: -48.3800,
                isOrigin: true
            },
            
            // Tipos de ve√≠culos
            vehicleTypes: [
                { id: 1, name: "Caminh√£o 1 eixo", type: "truck1", fuelEfficiency: 5, tollMultiplier: 2, costPerKm: 4.50 },
                { id: 2, name: "Caminh√£o 2 eixos", type: "truck2", fuelEfficiency: 4, tollMultiplier: 4, costPerKm: 6.75 },
                { id: 3, name: "Caminh√£o 3 eixos", type: "truck3", fuelEfficiency: 3.5, tollMultiplier: 6, costPerKm: 8.25 },
                { id: 4, name: "Caminh√£o 4 eixos", type: "truck4", fuelEfficiency: 3, tollMultiplier: 8, costPerKm: 9.50 },
                { id: 5, name: "Caminh√£o 5 eixos", type: "truck5", fuelEfficiency: 2.5, tollMultiplier: 10, costPerKm: 12.00 },
                { id: 6, name: "Caminh√£o 6 eixos", type: "truck6", fuelEfficiency: 2.3, tollMultiplier: 12, costPerKm: 14.50 },
                { id: 7, name: "Van de carga", type: "van", fuelEfficiency: 8, tollMultiplier: 1.5, costPerKm: 3.50 },
                { id: 8, name: "Carro", type: "car", fuelEfficiency: 12, tollMultiplier: 1, costPerKm: 2.00 }
            ],
            
            // Pontos de interesse
            pointsOfInterest: [
                { id: 1, name: "Ped√°gio SP-225 (Brotas)", type: "toll", latitude: -22.2794, longitude: -48.1241, cost: 11.20, roadName: "SP-225" },
                { id: 2, name: "Ped√°gio SP-225 (Ja√∫)", type: "toll", latitude: -22.2589, longitude: -48.6020, cost: 9.80, roadName: "SP-225" },
                { id: 3, name: "Ped√°gio SP-300 (Bauru)", type: "toll", latitude: -22.3211, longitude: -49.0495, cost: 10.50, roadName: "SP-300" },
                { id: 4, name: "Balan√ßa SP-225 (Brotas)", type: "weighStation", latitude: -22.2702, longitude: -48.1598, restrictions: "24h / todos os ve√≠culos acima de 3.5t" },
                { id: 5, name: "Balan√ßa SP-300 (Bauru)", type: "weighStation", latitude: -22.3156, longitude: -49.0912, restrictions: "Seg-Sex 7h √†s 17h / ve√≠culos acima de 6t" },
                { id: 6, name: "Posto da PRF (Ja√∫)", type: "policeStation", latitude: -22.2541, longitude: -48.5580 },
                { id: 7, name: "Posto de Combust√≠vel BR (Dois C√≥rregos)", type: "fuelStation", latitude: -22.3628, longitude: -48.3848 },
                { id: 8, name: "Posto de Combust√≠vel Ipiranga (Brotas)", type: "fuelStation", latitude: -22.2856, longitude: -48.1414 }
            ],
            
            // Eventos em cidades
            cityEvents: [
                { id: 1, cityName: "Dois C√≥rregos", name: "Festa da Padroeira", date: new Date(2025, 4, 15), endDate: new Date(2025, 4, 19), description: "Celebra√ß√µes e prociss√£o no centro da cidade." },
                { id: 2, cityName: "Brotas", name: "Festival de Aventura", date: new Date(2025, 4, 10), endDate: new Date(2025, 4, 12), description: "Evento de esportes radicais e ecoturismo." },
                { id: 3, cityName: "Ja√∫", name: "Feira de Cal√ßados", date: new Date(2025, 4, 20), endDate: new Date(2025, 4, 22), description: "Exposi√ß√£o de cal√ßados e acess√≥rios." },
                { id: 4, cityName: "Bauru", name: "ExpoAgro", date: new Date(2025, 5, 5), endDate: new Date(2025, 5, 10), description: "Exposi√ß√£o agropecu√°ria e shows." }
            ],
            
            // Restri√ß√µes de circula√ß√£o
            truckRestrictions: [
                { id: 1, cityName: "Dois C√≥rregos", restriction: "Caminh√µes acima de 3 eixos", dayType: "weekday", startTime: "07:00", endTime: "09:00", applicableVehicles: "truck3,truck4,truck5,truck6", description: "Restri√ß√£o no per√≠odo de maior movimento" },
                { id: 2, cityName: "Ja√∫", restriction: "Todos os caminh√µes no centro", dayType: "all", startTime: "08:00", endTime: "18:00", applicableVehicles: "truck1,truck2,truck3,truck4,truck5,truck6", description: "Restri√ß√£o na √°rea central" },
                { id: 3, cityName: "Bauru", restriction: "Caminh√µes acima de 2 eixos", dayType: "weekday", startTime: "07:00", endTime: "20:00", applicableVehicles: "truck3,truck4,truck5,truck6", description: "Restri√ß√£o nas vias principais" },
                { id: 4, cityName: "S√£o Paulo", restriction: "Rod√≠zio municipal", dayType: "weekday", startTime: "07:00", endTime: "10:00", applicableVehicles: "all", description: "Rod√≠zio por placas" }
            ]
        };
    </script>
    
    <!-- Carregamento da API do Google Maps - √© carregado no final para garantir que a fun√ß√£o de callback esteja definida -->
    <script 
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places&callback=initMapCallback" 
        async 
        defer
        onerror="handleGoogleMapsError()">
    </script>
    
    <!-- Resto do c√≥digo da aplica√ß√£o -->
    <script>
        // Adiciona localiza√ß√£o a partir do input de texto
        function addLocationFromInput() {
            const inputField = document.getElementById('location-search');
            if (!inputField.value.trim()) {
                return;
            }
            
            const place = autocomplete.getPlace();
            if (!place || !place.geometry) {
                alert("Por favor, selecione um local v√°lido da lista de sugest√µes.");
                return;
            }
            
            const location = {
                id: Date.now(),
                name: place.name,
                address: place.formatted_address,
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            // Adicionar ao estado da aplica√ß√£o
            addLocation(location);
            
            // Limpar o campo
            inputField.value = '';
        }
        
        // Adiciona uma localiza√ß√£o √† lista e ao mapa
        function addLocation(location) {
            // Impedir duplicatas pelo endere√ßo
            const locationsList = document.getElementById('locations-list');
            for (const child of locationsList.children) {
                if (child.dataset.address === location.address) {
                    alert(`Localiza√ß√£o "${location.name}" j√° foi adicionada.`);
                    return;
                }
            }
            
            // Criar elemento da lista
            const locationIndex = locationsList.children.length + 1;
            const locationItem = document.createElement('div');
            locationItem.className = 'location-item';
            locationItem.dataset.id = location.id;
            locationItem.dataset.address = location.address;
            
            locationItem.innerHTML = `
                <div>
                    <div><strong>${location.name}</strong></div>
                    <div class="location-address">${location.address}</div>
                </div>
                <button class="btn btn-sm btn-outline-danger remove-location" title="Remover localiza√ß√£o">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6Z"/>
                        <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1ZM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118ZM2.5 3h11V2h-11v1Z"/>
                    </svg>
                </button>
            `;
            
            // Adicionar evento para remover
            locationItem.querySelector('.remove-location').addEventListener('click', function() {
                removeLocation(location.id);
            });
            
            // Adicionar √† lista
            locationsList.appendChild(locationItem);
            
            // Adicionar marcador ao mapa
            addMarkerForLocation(location, locationIndex);
        }
        
        // Remove uma localiza√ß√£o da lista e do mapa
        function removeLocation(id) {
            // Remover da lista
            const locationItem = document.querySelector(`.location-item[data-id="${id}"]`);
            if (locationItem) {
                locationItem.remove();
            }
            
            // Remover marcador do mapa
            for (let i = 0; i < markers.length; i++) {
                if (markers[i].id === id) {
                    markers[i].marker.setMap(null);
                    markers.splice(i, 1);
                    break;
                }
            }
            
            // Renumerar os marcadores restantes
            updateMarkerLabels();
            
            // Limpar rota se existir
            if (currentRoute) {
                directionsRenderer.setDirections({routes: []});
                currentRoute = null;
                
                // Limpar relat√≥rio
                document.getElementById('route-report').innerHTML = `
                    <div class="alert alert-info">
                        Otimize uma rota para gerar o relat√≥rio de viagem com dist√¢ncias, tempo estimado e custos.
                    </div>
                `;
                
                // Limpar eventos
                updateEventsForRoute();
            }
        }
        
        // Adiciona um marcador no mapa para uma localiza√ß√£o
        function addMarkerForLocation(location, index) {
            const position = {
                lat: parseFloat(location.latitude),
                lng: parseFloat(location.longitude)
            };
            
            // Configurar o √≠cone do marcador
            const isOrigin = location.isOrigin;
            const label = isOrigin ? 'O' : index.toString();
            const icon = {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: isOrigin ? '#FF0000' : '#1976D2',
                fillOpacity: 0.9,
                strokeColor: 'white',
                strokeWeight: 2,
                scale: 12
            };
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: position,
                map: map,
                icon: icon,
                label: {
                    text: label,
                    color: 'white',
                    fontSize: '12px',
                    fontWeight: 'bold'
                },
                title: location.name,
                animation: google.maps.Animation.DROP
            });
            
            // Adicionar evento hover para mostrar tooltip
            marker.addListener('mouseover', function() {
                showTooltip(marker, `
                    <strong>${location.name}</strong><br>
                    ${location.address}
                `);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Adicionar evento de clique
            marker.addListener('click', function() {
                map.setZoom(15);
                map.setCenter(marker.getPosition());
            });
            
            // Adicionar ao array de marcadores
            markers.push({
                id: location.id,
                marker: marker,
                position: position,
                isOrigin: isOrigin
            });
            
            // Ajustar o zoom para incluir todos os marcadores
            if (markers.length > 1) {
                zoomToFitMarkers();
            } else {
                map.setCenter(position);
                map.setZoom(12);
            }
        }
        
        // Atualiza as labels dos marcadores ap√≥s remover um
        function updateMarkerLabels() {
            let index = 1;
            for (const markerObj of markers) {
                if (!markerObj.isOrigin) {
                    markerObj.marker.setLabel({
                        text: index.toString(),
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    });
                    index++;
                }
            }
        }
        
        // Processa o arquivo de localiza√ß√µes
        function processFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                alert("Por favor, selecione um arquivo para importar.");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                parseFileContents(contents);
            };
            reader.readAsText(file);
        }
        
        // Parse do conte√∫do do arquivo
        function parseFileContents(contents) {
            // Separar linhas
            const lines = contents.split(/\r?\n/).filter(line => line.trim() !== '');
            
            if (lines.length === 0) {
                alert("Arquivo vazio. Por favor, verifique o conte√∫do do arquivo.");
                return;
            }
            
            // Processamento de linha-a-linha
            const locations = [];
            const errors = [];
            
            lines.forEach((line, index) => {
                // Format: CEP,Nome
                const match = line.match(/^([0-9-]+),(.+)$/);
                
                if (!match) {
                    errors.push(`Linha ${index + 1}: Formato inv√°lido. Use "CEP,Nome".`);
                    return;
                }
                
                const cep = match[1].trim();
                const name = match[2].trim();
                
                if (!/^[0-9]{5}-?[0-9]{3}$/.test(cep)) {
                    errors.push(`Linha ${index + 1}: CEP ${cep} inv√°lido. Use formato 00000-000 ou 00000000.`);
                    return;
                }
                
                // Limpeza de formata√ß√£o do CEP
                const cleanCep = cep.replace('-', '');
                
                locations.push({
                    cep: cleanCep,
                    name: name
                });
            });
            
            if (errors.length > 0) {
                alert(`Foram encontrados ${errors.length} erros no arquivo:\n\n${errors.join('\n')}`);
                return;
            }
            
            if (locations.length > 0) {
                loadLocationsFromZipCodes(locations);
            }
        }
        
        // Carrega informa√ß√µes de localiza√ß√£o a partir de CEPs
        async function loadLocationsFromZipCodes(locations) {
            document.getElementById('optimize-button-text').textContent = "Processando importa√ß√£o...";
            document.getElementById('optimize-spinner').classList.remove('d-none');
            
            for (const location of locations) {
                try {
                    await geocodeLocation(location);
                } catch (error) {
                    console.error("Erro ao geocodificar localiza√ß√£o:", error);
                }
            }
            
            document.getElementById('optimize-button-text').textContent = "Otimizar Rota";
            document.getElementById('optimize-spinner').classList.add('d-none');
            
            // Reset file input
            document.getElementById('file-input').value = '';
        }
        
        // Fun√ß√£o mock para geocodificar CEP
        function geocodeLocation(location) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Gerar coordenadas fict√≠cias em torno de S√£o Paulo
                    // Em produ√ß√£o, voc√™ usaria uma API de geocoding real
                    const baseCoords = {
                        lat: -23.55 + (Math.random() * 2 - 1),
                        lng: -46.64 + (Math.random() * 2 - 1)
                    };
                    
                    const newLocation = {
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        name: location.name,
                        address: `${location.name}, CEP ${location.cep}, Brasil`,
                        zipCode: location.cep,
                        latitude: baseCoords.lat,
                        longitude: baseCoords.lng,
                        isOrigin: false
                    };
                    
                    addLocation(newLocation);
                    resolve(newLocation);
                }, 500);
            });
        }
        
        // Extrai o CEP de um objeto place do Google Places
        function getZipCodeFromPlace(place) {
            if (!place.address_components) {
                return null;
            }
            
            for (const component of place.address_components) {
                if (component.types.includes('postal_code')) {
                    return component.long_name;
                }
            }
            
            return null;
        }
        
        // Cria um tooltip personalizado
        function createCustomTooltip() {
            if (!customTooltip) {
                customTooltip = document.createElement('div');
                customTooltip.className = 'custom-tooltip';
                document.querySelector('.map-container').appendChild(customTooltip);
            }
        }
        
        // Mostra o tooltip
        function showTooltip(marker, content) {
            if (!customTooltip) return;
            
            customTooltip.innerHTML = content;
            customTooltip.style.display = 'block';
            
            const projection = map.getProjection();
            if (projection) {
                const point = projection.fromLatLngToPoint(marker.getPosition());
                const mapContainer = document.querySelector('.map-container');
                const mapRect = mapContainer.getBoundingClientRect();
                
                const scale = Math.pow(2, map.getZoom());
                const worldPoint = new google.maps.Point(
                    point.x * scale,
                    point.y * scale
                );
                
                const pixelOffset = new google.maps.Point(
                    Math.floor((worldPoint.x - point.x) + mapRect.left),
                    Math.floor((worldPoint.y - point.y) + mapRect.top)
                );
                
                customTooltip.style.left = (pixelOffset.x - customTooltip.offsetWidth / 2) + 'px';
                customTooltip.style.top = (pixelOffset.y - customTooltip.offsetHeight - 25) + 'px';
            }
        }
        
        // Esconde o tooltip
        function hideTooltip() {
            if (customTooltip) {
                customTooltip.style.display = 'none';
            }
        }
        
        // Otimiza a rota
        function optimizeRoute() {
            // Verificar se h√° destinos suficientes
            if (markers.length <= 1) {
                alert("Adicione pelo menos 1 destino para calcular uma rota.");
                return;
            }
            
            // Encontrar origem
            const origin = markers.find(m => m.isOrigin);
            if (!origin) {
                alert("Origem n√£o definida.");
                return;
            }
            
            // Encontrar destinos
            const destinations = markers.filter(m => !m.isOrigin);
            
            // Mostrar spinner
            document.getElementById('optimize-button-text').textContent = "Otimizando...";
            document.getElementById('optimize-spinner').classList.remove('d-none');
            
            // Calculando a solu√ß√£o do caixeiro viajante
            const tspResult = solveTSP(origin, destinations, false);
            
            // Exibir a rota no mapa
            displayRoute(tspResult.path);
            
            // Gerar relat√≥rio
            generateRouteReport(tspResult);
            
            // Atualizar eventos para a rota
            updateEventsForRoute();
            
            // Esconder spinner
            document.getElementById('optimize-button-text').textContent = "Otimizar Rota";
            document.getElementById('optimize-spinner').classList.add('d-none');
            
            // Armazenar rota atual
            currentRoute = tspResult;
        }
        
        // Implementa√ß√£o simplificada do algoritmo do Caixeiro Viajante
        function solveTSP(origin, destinations, includeReturn) {
            // Se n√£o houver destinos, retornar apenas a origem
            if (!destinations.length) {
                return {
                    path: [origin],
                    distance: 0
                };
            }
            
            // Nearest Neighbor heuristic
            let currentPoint = origin;
            let unvisited = [...destinations];
            let path = [origin];
            let totalDistance = 0;
            
            // Enquanto houver pontos n√£o visitados
            while (unvisited.length > 0) {
                // Encontrar o ponto mais pr√≥ximo
                let closestIdx = 0;
                let closestDistance = calculateDistance(
                    currentPoint.position.lat, currentPoint.position.lng,
                    unvisited[0].position.lat, unvisited[0].position.lng
                );
                
                for (let i = 1; i < unvisited.length; i++) {
                    const distance = calculateDistance(
                        currentPoint.position.lat, currentPoint.position.lng,
                        unvisited[i].position.lat, unvisited[i].position.lng
                    );
                    
                    if (distance < closestDistance) {
                        closestIdx = i;
                        closestDistance = distance;
                    }
                }
                
                // Adicionar o ponto mais pr√≥ximo √† rota
                const nextPoint = unvisited[closestIdx];
                path.push(nextPoint);
                totalDistance += closestDistance;
                
                // Atualizar o ponto atual e remover o ponto visitado
                currentPoint = nextPoint;
                unvisited.splice(closestIdx, 1);
            }
            
            // Se for para incluir retorno √† origem
            if (includeReturn && path.length > 1) {
                const lastPoint = path[path.length - 1];
                const returnDistance = calculateDistance(
                    lastPoint.position.lat, lastPoint.position.lng,
                    origin.position.lat, origin.position.lng
                );
                
                path.push(origin);
                totalDistance += returnDistance;
            }
            
            return {
                path: path,
                distance: totalDistance
            };
        }
        
        // Calcula a dist√¢ncia entre dois pontos geogr√°ficos usando a f√≥rmula de Haversine
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // raio da Terra em km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c; // Dist√¢ncia em km
            return distance;
        }
        
        // Converte graus para radianos
        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }
        
        // Exibe a rota no mapa
        function displayRoute(path) {
            if (path.length < 2) return;
            
            // Preparar waypoints
            const waypoints = path.slice(1, path.length - 1).map(point => ({
                location: point.position,
                stopover: true
            }));
            
            const request = {
                origin: path[0].position,
                destination: path[path.length - 1].position,
                waypoints: waypoints,
                optimizeWaypoints: false,
                travelMode: google.maps.TravelMode.DRIVING
            };
            
            directionsService.route(request, function(response, status) {
                if (status === google.maps.DirectionsStatus.OK) {
                    directionsRenderer.setDirections(response);
                    
                    // Atualize as informa√ß√µes sobre ped√°gios
                    collectTollInfo(response);
                    
                    // Detectar cidades na rota
                    detectCitiesInRoute(response);
                } else {
                    alert("N√£o foi poss√≠vel calcular a rota: " + status);
                }
            });
        }
        
        // Gera o relat√≥rio da rota
        function generateRouteReport(tspResult) {
            // Verificar se temos uma rota
            if (!tspResult || !tspResult.path || tspResult.path.length < 2) {
                return;
            }
            
            // Estimar o tempo baseado na dist√¢ncia (velocidade m√©dia de 70 km/h)
            const speed = 70; // km/h
            const distance = tspResult.distance;
            const timeHours = distance / speed;
            
            // Converter para horas e minutos
            const hours = Math.floor(timeHours);
            const minutes = Math.round((timeHours - hours) * 60);
            
            // Obter o ve√≠culo selecionado
            const selectedVehicleCard = document.querySelector('.vehicle-card.selected');
            let vehicle = { name: "N/A", costPerKm: 0, fuelEfficiency: 0, tollMultiplier: 1 };
            
            if (selectedVehicleCard) {
                const vehicleId = parseInt(selectedVehicleCard.dataset.vehicleId);
                const foundVehicle = mockData.vehicleTypes.find(v => v.id === vehicleId);
                if (foundVehicle) {
                    vehicle = foundVehicle;
                }
            }
            
            // Calcular custos
            const fuelPrice = 5.50; // Pre√ßo m√©dio por litro
            const fuelConsumptionLiters = distance / vehicle.fuelEfficiency;
            const fuelCost = fuelConsumptionLiters * fuelPrice;
            const driverCost = (hours + (minutes / 60)) * 50; // R$ 50 por hora
            const maintenanceCost = distance * vehicle.costPerKm;
            
            // Estimar custo de ped√°gios
            const approxTollsPerKm = 0.11; // Custo m√©dio aproximado de ped√°gios por km em SP
            const tollCost = distance * approxTollsPerKm * vehicle.tollMultiplier;
            
            // Calcular custo total
            const totalCost = fuelCost + driverCost + maintenanceCost + tollCost;
            
            // Gerar o HTML do relat√≥rio
            const reportHTML = `
                <div class="card mb-3">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Resumo da Rota</h5>
                    </div>
                    <div class="card-body">
                        <table class="table table-sm">
                            <tr>
                                <th>Dist√¢ncia total:</th>
                                <td>${distance.toFixed(1)} km</td>
                            </tr>
                            <tr>
                                <th>Tempo estimado:</th>
                                <td>${hours}h ${minutes}min</td>
                            </tr>
                            <tr>
                                <th>Ve√≠culo:</th>
                                <td>${vehicle.name}</td>
                            </tr>
                        </table>
                    </div>
                </div>
                
                <div class="card mb-3">
                    <div class="card-header bg-success text-white">
                        <h5 class="mb-0">Custos Estimados</h5>
                    </div>
                    <div class="card-body">
                        <table class="table table-sm">
                            <tr>
                                <th>Combust√≠vel:</th>
                                <td>R$ ${fuelCost.toFixed(2)}</td>
                            </tr>
                            <tr>
                                <th>Motorista:</th>
                                <td>R$ ${driverCost.toFixed(2)}</td>
                            </tr>
                            <tr>
                                <th>Manuten√ß√£o:</th>
                                <td>R$ ${maintenanceCost.toFixed(2)}</td>
                            </tr>
                            <tr>
                                <th>Ped√°gios (estimativa):</th>
                                <td>R$ ${tollCost.toFixed(2)}</td>
                            </tr>
                            <tr class="table-primary">
                                <th>Custo Total:</th>
                                <td>R$ ${totalCost.toFixed(2)}</td>
                            </tr>
                        </table>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">Sequ√™ncia de Paradas</h5>
                    </div>
                    <div class="card-body">
                        <ol class="list-group list-group-numbered">
                            ${tspResult.path.map(point => {
                                const marker = markers.find(m => m.id === point.id);
                                if (!marker) return '';
                                
                                return `<li class="list-group-item">${marker.marker.getTitle()}</li>`;
                            }).join('')}
                        </ol>
                    </div>
                </div>
            `;
            
            document.getElementById('route-report').innerHTML = reportHTML;
        }
        
        // Colete informa√ß√µes sobre ped√°gios na rota
        function collectTollInfo(response) {
            // Em uma aplica√ß√£o real, voc√™ obteria essas informa√ß√µes de uma API de ped√°gios
            // Para esta demonstra√ß√£o, usaremos dados fict√≠cios
            console.log("Coletando informa√ß√µes sobre ped√°gios na rota...");
            
            // Aqui voc√™ poderia percorrer os steps da rota e verificar a proximidade de ped√°gios conhecidos
        }
        
        // Detectar cidades na rota para filtrar eventos
        function detectCitiesInRoute(response) {
            const cities = [];
            
            // Adicionar a cidade de origem
            if (mockData.origin && mockData.origin.name) {
                cities.push(mockData.origin.name.split(',')[0].trim());
            }
            
            // Adicionar cidades dos destinos
            markers.forEach(marker => {
                if (!marker.isOrigin && marker.marker && marker.marker.getTitle()) {
                    const city = marker.marker.getTitle().split(',')[0].trim();
                    if (!cities.includes(city)) {
                        cities.push(city);
                    }
                }
            });
            
            // Log das cidades detectadas
            console.log("Cidades detectadas para eventos:", cities);
            
            // Armazenar para uso no filtro de eventos
            window.citiesInRoute = cities;
            
            // Atualizar os eventos
            updateEventsForRoute();
        }
        
        // Atualizar os eventos com base na rota atual
        function updateEventsForRoute() {
            const eventsList = document.getElementById('events-list');
            eventsList.innerHTML = '';
            
            // Verificar se temos cidades na rota
            if (!window.citiesInRoute || window.citiesInRoute.length === 0) {
                eventsList.innerHTML = `
                    <div class="text-center py-3 text-muted">
                        Nenhum evento encontrado. Adicione localiza√ß√µes e otimize a rota para ver eventos nas cidades do percurso.
                    </div>
                `;
                return;
            }
            
            // Obter datas do filtro
            const startDateInput = document.getElementById('events-start-date');
            const endDateInput = document.getElementById('events-end-date');
            
            let startDate = null;
            let endDate = null;
            
            if (startDateInput.value) {
                startDate = new Date(startDateInput.value);
                startDate.setHours(0, 0, 0, 0);
            }
            
            if (endDateInput.value) {
                endDate = new Date(endDateInput.value);
                endDate.setHours(23, 59, 59, 999);
            }
            
            // Filtrar eventos por cidade e data
            let filteredEvents = mockData.cityEvents.filter(event => {
                // Verificar se a cidade est√° na rota
                const cityInRoute = window.citiesInRoute.some(city => 
                    event.cityName.toLowerCase().includes(city.toLowerCase()) || 
                    city.toLowerCase().includes(event.cityName.toLowerCase())
                );
                
                // Se a cidade n√£o estiver na rota, ignorar o evento
                if (!cityInRoute) return false;
                
                // Se n√£o houver filtro de data, mostrar o evento
                if (!startDate && !endDate) return true;
                
                // Verificar se o evento est√° dentro do intervalo de datas
                const eventStartDate = new Date(event.date);
                const eventEndDate = event.endDate ? new Date(event.endDate) : eventStartDate;
                
                // Verificar sobreposi√ß√£o de per√≠odos
                if (startDate && endDate) {
                    // Verifica se h√° sobreposi√ß√£o entre os dois per√≠odos
                    return eventStartDate <= endDate && eventEndDate >= startDate;
                } else if (startDate) {
                    // Apenas data inicial informada
                    return eventEndDate >= startDate;
                } else if (endDate) {
                    // Apenas data final informada
                    return eventStartDate <= endDate;
                }
                
                return true;
            });
            
            // Exibir eventos
            if (filteredEvents.length === 0) {
                eventsList.innerHTML = `
                    <div class="text-center py-3 text-muted">
                        Nenhum evento encontrado para o per√≠odo selecionado nas cidades da rota.
                    </div>
                `;
            } else {
                // Ordenar eventos por data
                filteredEvents.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // Criar elementos HTML para cada evento
                filteredEvents.forEach(event => {
                    const eventStart = new Date(event.date);
                    const eventEnd = event.endDate ? new Date(event.endDate) : null;
                    
                    const dateDisplay = eventEnd ? 
                        `${formatDate(eventStart)} at√© ${formatDate(eventEnd)}` : 
                        formatDate(eventStart);
                    
                    const eventItem = document.createElement('div');
                    eventItem.className = 'list-group-item';
                    eventItem.innerHTML = `
                        <div class="d-flex w-100 justify-content-between">
                            <h5 class="mb-1">${event.name}</h5>
                            <small>${event.cityName}</small>
                        </div>
                        <p class="mb-1">${event.description || 'Sem descri√ß√£o'}</p>
                        <small class="text-muted">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-calendar-event" viewBox="0 0 16 16">
                                <path d="M11 6.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1z"/>
                                <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/>
                            </svg>
                            ${dateDisplay}
                        </small>
                    `;
                    
                    eventsList.appendChild(eventItem);
                    
                    // Adicionar marcador para o evento no mapa
                    addEventMarker(event);
                });
            }
        }
        
        // Formatar data
        function formatDate(date) {
            if (!date) return '';
            
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            
            return `${day}/${month}/${year}`;
        }
        
        // Filtra eventos por data
        function filterEvents() {
            updateEventsForRoute();
        }
        
        // Adiciona marcador para evento
        function addEventMarker(event) {
            // Em uma aplica√ß√£o real, voc√™ teria as coordenadas do evento
            // Para esta demonstra√ß√£o, usaremos coordenadas fict√≠cias baseadas no nome da cidade
            
            // Verificar se j√° existe um marcador para este evento
            for (const marker of eventMarkers) {
                if (marker.eventId === event.id) {
                    return; // J√° existe um marcador para este evento
                }
            }
            
            // Usamos os pontos de interesse para encontrar coordenadas pr√≥ximas √† cidade
            const cityPOI = mockData.pointsOfInterest.find(poi => 
                poi.name.toLowerCase().includes(event.cityName.toLowerCase())
            );
            
            if (!cityPOI) return; // N√£o encontramos refer√™ncia de coordenadas para a cidade
            
            const position = {
                lat: parseFloat(cityPOI.latitude) + (Math.random() * 0.01 - 0.005),
                lng: parseFloat(cityPOI.longitude) + (Math.random() * 0.01 - 0.005)
            };
            
            const eventStart = new Date(event.date);
            const eventStartStr = formatDate(eventStart);
            const eventEnd = event.endDate ? formatDate(new Date(event.endDate)) : eventStartStr;
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: position,
                map: map,
                icon: {
                    url: 'https://maps.google.com/mapfiles/ms/icons/pink-dot.png',
                    scaledSize: new google.maps.Size(32, 32),
                    anchor: new google.maps.Point(16, 32)
                },
                title: event.name
            });
            
            // Adicionar evento hover para mostrar tooltip
            marker.addListener('mouseover', function() {
                showTooltip(marker, `
                    <strong>${event.name}</strong><br>
                    ${event.cityName}<br>
                    <small>${eventStartStr}${eventEnd !== eventStartStr ? ` at√© ${eventEnd}` : ''}</small><br>
                    ${event.description || ''}
                `);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Adicionar ao array de marcadores de eventos
            eventMarkers.push({
                eventId: event.id,
                marker: marker
            });
        }
        
        // Mostrar/esconder pontos de interesse
        function togglePointsOfInterest() {
            showPOIs = !showPOIs;
            
            if (showPOIs) {
                showPointsOfInterest();
            } else {
                hidePointsOfInterest();
            }
        }
        
        // Exibir pontos de interesse
        function showPointsOfInterest() {
            // Limpar marcadores existentes
            hidePointsOfInterest();
            
            // Adicionar marcadores para cada ponto de interesse
            mockData.pointsOfInterest.forEach(poi => {
                const position = {
                    lat: parseFloat(poi.latitude),
                    lng: parseFloat(poi.longitude)
                };
                
                // Determinar o √≠cone baseado no tipo de POI
                let icon = {
                    url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                    scaledSize: new google.maps.Size(24, 24)
                };
                
                switch(poi.type) {
                    case 'toll':
                        icon.url = 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png';
                        break;
                    case 'weighStation':
                        icon.url = 'https://maps.google.com/mapfiles/ms/icons/green-dot.png';
                        break;
                    case 'policeStation':
                        icon.url = 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png';
                        break;
                    case 'fuelStation':
                        icon.url = 'https://maps.google.com/mapfiles/ms/icons/red-dot.png';
                        break;
                }
                
                // Criar o marcador
                const marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    icon: icon,
                    title: poi.name
                });
                
                // Adicionar evento hover para mostrar tooltip
                marker.addListener('mouseover', function() {
                    let tooltipContent = `<strong>${poi.name}</strong>`;
                    
                    if (poi.type === 'toll') {
                        tooltipContent += `<br>Custo: R$ ${poi.cost || 'N/A'}`;
                        tooltipContent += poi.roadName ? `<br>Rodovia: ${poi.roadName}` : '';
                    } else if (poi.type === 'weighStation') {
                        tooltipContent += poi.restrictions ? `<br>${poi.restrictions}` : '';
                    }
                    
                    showTooltip(marker, tooltipContent);
                });
                
                marker.addListener('mouseout', function() {
                    hideTooltip();
                });
                
                // Adicionar ao array de marcadores POI
                poiMarkers.push(marker);
            });
        }
        
        // Esconder pontos de interesse
        function hidePointsOfInterest() {
            poiMarkers.forEach(marker => {
                marker.setMap(null);
            });
            poiMarkers = [];
        }
        
        // Ajusta o zoom para visualizar todos os marcadores
        function zoomToFitMarkers() {
            if (markers.length === 0) return;
            
            const bounds = new google.maps.LatLngBounds();
            markers.forEach(markerObj => {
                bounds.extend(markerObj.position);
            });
            
            map.fitBounds(bounds);
            
            // Ajuste m√≠nimo de zoom
            if (map.getZoom() > 15) {
                map.setZoom(15);
            }
        }
        
        // Quando o lugar √© selecionado no autocomplete
        function onPlaceSelected() {
            const place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("N√£o foi poss√≠vel encontrar detalhes para o local selecionado");
                return;
            }
            
            // Adicionar o local
            const location = {
                id: Date.now(),
                name: place.name || place.formatted_address.split(',')[0],
                address: place.formatted_address,
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            addLocation(location);
            
            // Limpar o campo
            document.getElementById('location-search').value = '';
        }
    </script>
</body>
</html>