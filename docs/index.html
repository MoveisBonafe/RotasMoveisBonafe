<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ffc107">
    <meta name="description" content="Otimizador de Rotas M√≥veis Bonaf√© - Solu√ß√£o para log√≠stica e transporte, com suporte a c√°lculo de rotas entre m√∫ltiplos pontos, otimiza√ß√£o de sequ√™ncia, e visualiza√ß√£o de eventos e restri√ß√µes em cidades brasileiras." />
    <meta name="keywords" content="Bonaf√©, otimizador de rotas, problema do caixeiro viajante, log√≠stica, transporte, planejamento de rotas, otimiza√ß√£o de entregas, Brasil, Google Maps, ped√°gios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas M√≥veis Bonaf√©" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas M√≥veis Bonaf√©</title>
    <!-- Script de intercepta√ß√£o de erros - deve ser o primeiro para evitar erros no console -->
    <script src="script-fallback.js"></script>
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="apple-touch-icon" href="assets/icon-192.png">
    <link rel="manifest" href="assets/manifest.json">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para o r√≥tulo no marcador de contagem */
        .counter-marker-label {
            font-size: 14px !important;
            font-weight: bold !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
            width: 26px !important;
            height: 26px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            color: white !important;
            border-radius: 50% !important;
            padding: 2px !important;
            text-align: center !important;
            text-shadow: 1px 1px 2px black !important;
            border: 1px solid white !important;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5) !important;
        }
        
        /* Estilos globais */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Impedir rolagem na p√°gina inteira */
        }
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            width: 100%;
            position: relative; /* Importante para posicionamento absoluto das abas */
        }
        
        .main-content-area {
            display: flex;
            flex-direction: row;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 60px; /* Espa√ßo para a barra inferior de bot√µes */
            overflow: hidden;
        }
        
        .map-container {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 380px; /* Alinhado com o fim da sidebar */
            overflow: hidden;
        }
        
        #map {
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .sidebar {
            width: 380px;
            background-color: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            scrollbar-width: thin; /* Para Firefox */
            scrollbar-color: #adb5bd #f8f9fa; /* Para Firefox */
        }
        
        /* Garantir que o conte√∫do da sidebar tenha rolagem adequada */
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px; /* Espa√ßo para a barra de rolagem */
            scrollbar-width: thin;
            scrollbar-color: #ffc107 #f8f9fa;
        }
        
        .sidebar-content::-webkit-scrollbar {
            width: 6px; 
        }
        
        .sidebar-content::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        
        .sidebar-content::-webkit-scrollbar-thumb {
            background-color: #ffc107;
            border-radius: 6px;
            border: 2px solid #f8f9fa;
        }
        
        /* Estilizar scrollbar para navegadores baseados em WebKit (Chrome, Safari) */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f8f9fa;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background-color: #adb5bd;
            border-radius: 10px;
            border: 2px solid #f8f9fa;
        }
        
        /* Melhorar layout da sidebar para GitHub Pages */
        .sidebar-header {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Estiliza√ß√£o do t√≠tulo da aplica√ß√£o */
        .app-title {
            display: flex;
            flex-direction: column;
            line-height: 1.1;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.5px;
            position: relative;
            padding: 8px 0;
        }
        
        .app-title::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            height: 100%;
            width: 3px;
            background: linear-gradient(to bottom, #000000, #ffc107);
            border-radius: 3px;
            animation: heightGrow 1.2s ease-in-out;
        }
        
        .app-title-text {
            font-size: 1.4rem;
            font-weight: 600;
            color: #000000;
            animation: fadeIn 1.5s ease-in-out;
        }
        
        .app-title-highlight {
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ffc107 0%, #ffab00 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: slideInRight 1s ease-in-out;
            margin-top: -5px;
            letter-spacing: -0.2px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideInRight {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes heightGrow {
            from { height: 0; }
            to { height: 100%; }
        }
        
        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .map-container {
            flex: 1;
            height: 100%;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        /* Bot√£o toggle-sidebar removido */
        .form-group {
            margin-bottom: 15px;
        }
        .location-list {
            max-height: 250px; /* Reduzido para deixar espa√ßo para rotas alternativas */
            overflow-y: auto;
            margin-top: 10px;
            margin-bottom: 10px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            background-color: #fff;
        }
        /* Spinner de carregamento */
        #loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            display: none;
            text-align: center;
        }
        
        #loading-spinner::after {
            content: "";
            display: block;
            width: 40px;
            height: 40px;
            margin: 10px auto;
            border-radius: 50%;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            animation: spin 2s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-address {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn-container {
            position: sticky;
            bottom: 0;
            background-color: #f8f9fa;
            padding: 15px 0;
            margin-top: 20px;
        }
        #optimize-route {
            width: 100%;
            padding: 10px 0;
            font-weight: 600;
            background-color: #ffc107;
            border-color: #ffab00;
            color: #000;
            transition: all 0.3s ease;
        }
        
        #optimize-route:hover {
            background-color: #ffab00;
            border-color: #ff9800;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 171, 0, 0.3);
        }
        
        .optimize-btn-container {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .marker-label {
            color: black;
            background-color: #ffc107;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 50%;
            font-size: 14px;
        }
        
        /* Estilo para o cart√£o de rotas alternativas */
        .route-option-card {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .route-option-card:hover {
            border-color: #ffc107;
            box-shadow: 0 3px 6px rgba(255, 193, 7, 0.2);
            transform: translateY(-2px);
        }
        .route-option-card.selected {
            border-color: #ffab00;
            background-color: #fff8e1;
        }
        
        /* Estilo para a se√ß√£o de rotas alternativas na sidebar */
        .alternative-routes-section {
            margin-top: 5px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .alternative-routes-section h5 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            color: #495057;
        }
        .pac-container {
            z-index: 9999; /* Garantir que as sugest√µes apare√ßam acima de outros elementos */
        }
        .truck-icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
        }
        .truck-type {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .truck-type label {
            margin-left: 10px;
            cursor: pointer;
        }
        #route-summary {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #fff8e1;
            border-radius: 8px;
            border: 1px solid #ffe082;
        }
        #route-steps {
            margin-top: 15px;
            padding-left: 15px;
        }
        .summary-header {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 16px;
        }
        /* Estilos para a √°rea de upload de arquivo */
        .file-upload-container {
            position: relative;
            margin-top: 15px;
            margin-bottom: 20px;
        }
        
        .file-upload {
            margin-top: 10px;
            border: 2px dashed #ffc107;
            padding: 15px 10px;
            text-align: center;
            border-radius: 8px;
            background-color: #fffbeb;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }
        
        .file-upload:hover, .file-upload.dragover {
            border-color: #ffab00;
            background-color: #fff8e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 171, 0, 0.15);
        }
        
        .file-upload p {
            margin-bottom: 10px;
            color: #444;
            font-weight: 500;
        }
        
        .file-upload-icon {
            display: block;
            margin: 0 auto 5px;
            font-size: 24px;
            color: #ffc107;
        }
        
        .file-format-example {
            background-color: #fff8e1;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            display: inline-block;
            margin: 4px auto;
            color: #2c3e50;
            border: 1px solid #ffe082;
            font-size: 12px;
        }
        
        .file-upload input[type="file"] {
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-upload-text {
            display: block;
            margin-top: 5px;
            color: #5a5a5a;
            font-size: 13px;
        }
        
        /* Status de upload */
        .file-upload-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
            display: none;
            animation: fadeIn 0.3s ease;
            position: relative;
        }
        
        .file-upload-status.error {
            background-color: #ffe2e2;
            color: #d32f2f;
            border: 1px solid #ffcdd2;
            display: block;
        }
        
        .file-upload-status.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilos para notifica√ß√£o de sucesso no upload */
        .upload-success {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            height: 100%;
        }
        .upload-success-icon {
            font-size: 48px;
            color: #ffc107;
            margin-bottom: 10px;
            animation: scale-in 0.3s ease-out;
        }
        .upload-success-text {
            color: #555;
            font-size: 16px;
            margin-top: 5px;
        }
        .file-upload.success {
            border-color: #2ecc71;
            background-color: #ebfaf0;
            transition: all 0.3s ease;
        }
        .file-upload.fading {
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        @keyframes scale-in {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            80% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        /* Bot√£o para fechar o sidebar em telas pequenas */
        .sidebar-close {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        /* Estilo quando o sidebar est√° fechado */
        .sidebar-hidden {
            transform: translateX(-100%);
        }
        
        /* Estilos para o container de status de upload de arquivo */
        .file-upload-container {
            position: relative;
            border: 2px dashed #ffd06e;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background-color: #fffbf0;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload-container.dragover {
            background-color: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }
        
        .file-upload-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 0.9em;
            display: none; /* Inicialmente oculto */
        }
        
        .file-upload-status.error {
            background-color: #ffe2e2;
            color: #d32f2f;
            border: 1px solid #ffcdd2;
            display: block; /* Apenas mostrar quando tiver erro */
        }
        
        .file-upload-status.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
            display: block; /* Apenas mostrar quando tiver sucesso */
        }
        
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 100%;
                max-width: 320px;
                overflow-y: auto; /* Garantir rolagem quando necess√°rio */
            }
            
            .map-container {
                left: 320px; /* Menor largura da sidebar em telas pequenas */
            }
            
            .bottom-tabs-container {
                left: 320px;
                width: calc(100% - 320px);
            }
        }
        /* Estilo para o ponto de origem na lista da rota, usando o mesmo estilo do summary-header */
        .origin-point {
            font-weight: bold;
            border-bottom: 1px solid #ffc107;
            padding-bottom: 3px;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        /* Estilo para os marcadores de pontos de interesse */
        .poi-marker {
            background-color: #ffc107;
            border-radius: 50%;
            color: black;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            font-size: 12px;
        }
        /* Estilos para anima√ß√£o de input */
        .input-animation-container {
            position: relative;
            overflow: hidden;
        }

        .input-animation-effect {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background-color: #ffc107;
            transition: width 0.3s ease;
        }

        .input-animation-container input:focus + .input-animation-effect {
            width: 100%;
        }
        
        /* Estilos para tooltip personalizado */
        .custom-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
        }
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        /* Estilos para abas - Nova vers√£o com anima√ß√£o e layout inferior */
        .tab-container {
            width: 100%;
            margin-top: 40px;
            position: relative;
            transition: all 0.5s ease;
        }
        .tab-buttons {
            display: flex;
            justify-content: center;
            background: #fff8e1;
            border-top: 1px solid #ffe082;
            border-bottom: 1px solid #ffe082;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 -2px 10px rgba(255, 193, 7, 0.1);
        }
        .tab-button {
            padding: 10px 20px;
            margin: 0 5px;
            background-color: #f8f9fa;
            border: 1px solid #ffe082;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            color: #495057;
            position: relative;
            overflow: hidden;
        }
        .tab-button::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #ffc107;
            transform: translateY(3px);
            transition: transform 0.3s ease;
        }
        .tab-button:hover {
            background-color: #fff8e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.2);
        }
        .tab-button:hover::after {
            transform: translateY(0);
        }
        .tab-button.active {
            background-color: #ffc107;
            color: black;
            border-color: #ffab00;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 171, 0, 0.3);
        }
        .tab-button.active::after {
            background-color: white;
            transform: translateY(0);
        }
        .tab-content {
            display: none;
            padding: 25px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            margin-top: 20px;
            animation: fadeInUp 0.5s ease forwards;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        .tab-content.active {
            display: block;
            max-height: 2000px;
            overflow-y: auto;
        }
        
        /* Anima√ß√µes para as abas e conte√∫do */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Estilo para personalizar a lista de sequ√™ncia da rota */
        .custom-route-list {
            list-style-type: none;
            padding-left: 10px;
            margin-top: 10px;
        }
        
        .custom-route-list li {
            margin-bottom: 5px;
            padding: 4px 0;
        }
        
        /* Estilo para datas */
        .date-range-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .date-range-container input {
            flex: 1;
            border: 1px solid #ffe082;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }
        .date-range-container input:focus {
            border-color: #ffc107;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
            outline: none;
        }
        .date-range-label {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #333;
            display: block;
        }
        
        /* Estilos para √≠cones de evento */
        .event-marker {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: black;
            font-size: 14px;
        }
        .event-marker.holiday {
            background-color: #ffc107; /* Amarelo Bonaf√© para feriados */
            color: black;
        }
        .event-marker.event {
            background-color: #ffab00; /* Amarelo escuro para eventos */
            color: black;
        }
        
        /* Estilos para legenda de regi√µes */
        .region-legend {
            position: absolute;
            top: 50%;
            left: 80px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            max-width: 220px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .region-legend h5 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            color: #333;
        }
        
        .region-legend .close-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: transparent;
            border: none;
            font-size: 18px;
            line-height: 1;
            padding: 0;
            margin: 0;
            cursor: pointer;
            color: #777;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .region-legend .close-button:hover {
            opacity: 1;
            color: #444;
        }
        
        .region-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            padding: 3px 2px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .region-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .region-name {
            font-size: 11px;
        }
        
        /* Estilos para bot√µes de legenda */
        .legend-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }
        
        .legend-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
        }
        
        .legend-btn svg {
            width: 16px;
            height: 16px;
        }
        
        /* Estilo para lista de eventos */
        .events-list {
            margin-top: 15px;
            min-height: 300px; /* Altura m√≠nima */
            overflow-y: auto;
            width: 100%; /* Garantir que ocupe toda a largura dispon√≠vel */
            height: 100%; /* Garantir que ocupe toda a altura dispon√≠vel */
            transition: all 0.3s ease; /* Transi√ß√£o suave ao expandir */
        }
        .event-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .event-name {
            font-weight: bold;
            color: #ffc107;
        }
        .event-date {
            font-size: 0.8em;
            color: #666;
        }
        .event-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .event-type.holiday {
            background-color: #f44336;
        }
        .event-type.event {
            background-color: #ff9800;
        }
        .restriction-level {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: white;
        }
        .restriction-level.low {
            background-color: #4caf50;
        }
        .restriction-level.medium {
            background-color: #ff9800;
        }
        .restriction-level.high {
            background-color: #f44336;
        }
        
        /* Estilos para restri√ß√µes de caminh√µes */
        .restrictions-list {
            margin-top: 10px;
            min-height: 300px; /* Altura m√≠nima */
            overflow-y: auto;
            width: 100%; /* Garantir que ocupe toda a largura dispon√≠vel */
            height: 100%; /* Garantir que ocupe toda a altura dispon√≠vel */
            transition: all 0.3s ease; /* Transi√ß√£o suave ao expandir */
        }
        .restriction-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .restriction-city {
            font-weight: bold;
            color: #ffc107;
        }
        .restriction-time {
            font-size: 0.8em;
            color: #666;
        }
        .restriction-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            margin-left: 5px;
            color: black;
        }
        .restriction-type.partial {
            background-color: #ffc107;
        }
        .restriction-type.total {
            background-color: #ffab00;
        }
        .restriction-type.rodizio {
            background-color: #ffe082;
        }

        /* Estilos para anima√ß√£o da rota */
        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
            }
        }
        .animated-path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawPath 3s ease-in-out forwards;
        }

        /* Bot√µes de controle da visualiza√ß√£o */
        .map-controls {
            position: absolute;
            bottom: 24px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* Bot√£o de zoom espec√≠fico */
        #zoom-to-fit {
            position: absolute;
            left: 0px;
            top: 0px;
            width: 66px;
            height: 26px;
            user-select: none;
            border: 0px;
            padding: 0px;
            margin: 0px;
            z-index: 1000;
            background-color: white;
        }
        .map-control-btn {
            background: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Estilo para o spinner de carregamento */
        .spinner-border {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
        }
        
        /* NOVO LAYOUT - Tabs na parte inferior do mapa (fixas) */
        .bottom-tabs-container {
            width: calc(100% - 380px); /* Ajustado para n√£o sobrepor a sidebar */
            margin: 0;
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.5s ease;
            background-color: #f9f9f9;
            border-top: 1px solid #ddd;
            overflow: auto; /* Alterado para auto para permitir rolagem */
            height: 60px; /* Altura padr√£o quando minimizada */
            position: absolute; /* Alinhado com layout principal */
            bottom: 0;
            left: 380px; /* Inicia √† direita da sidebar */
            right: 0;
            z-index: 1000; /* Aumentado para ficar sobre todos os elementos */
            transition: height 0.3s ease-in-out;
            box-sizing: border-box; /* Garantir que padding e border n√£o afetem o tamanho */
        }
        
        /* Media query para garantir que o layout permane√ßa est√°vel em diferentes tamanhos de tela */
        @media (min-width: 1024px) {
            .bottom-tabs-container {
                width: calc(100% - 380px);
                left: 380px;
            }
        }
        
        /* Estado minimizado para container de abas */
        .bottom-tabs-container.minimized {
            height: 60px; /* Altura quando minimizado */
            overflow: hidden;
        }
        
        /* Estado expandido para container de abas */
        .bottom-tabs-container:not(.minimized) {
            height: calc(100vh - 10px); /* Quase altura total da tela quando expandido */
            border-top: 2px solid #1976D2; /* Borda mais vis√≠vel quando expandido */
            border-left: 2px solid #1976D2; /* Borda na lateral para separar da sidebar */
            box-shadow: -5px -5px 15px rgba(0,0,0,0.2); /* Sombra ajustada */
        }
        
        /* Bot√£o de fechar removido - usando apenas os bot√µes das abas para controlar expandir/minimizar */
        
        /* Ajuste para que o mapa ocupe todo o espa√ßo dispon√≠vel */
        .map-container {
            position: fixed !important; /* Posicionamento fixo para cobrir toda a √°rea */
            top: 0 !important;
            right: 0 !important;
            bottom: 60px !important; /* Altura das abas minimizadas */
            left: 380px !important; /* Come√ßa onde termina a sidebar */
            width: calc(100% - 380px) !important; /* Largura ajustada para alinhar com a sidebar */
            height: calc(100vh - 60px) !important; /* Altura total menos as abas minimizadas */
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
            z-index: 5; /* Garantir que fique acima do corpo da p√°gina, mas abaixo da sidebar e abas */
        }
        
        /* Bot√£o de controle para esconder/mostrar marcadores de contagem */
        #counter-toggle {
            position: absolute;
            bottom: 70px; /* Posicionado na parte inferior */
            right: 10px; /* Alinhado √† direita */
            z-index: 100;
            padding: 5px 8px;
            background-color: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        #counter-toggle:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }
        
        /* Garantir que o mapa ocupe 100% do container */
        #map {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Classe especial para for√ßar tamanho completo */
        .full-size-map {
            width: 100% !important;
            height: 100% !important;
            min-height: 100% !important;
            max-height: none !important;
            display: block !important;
            position: absolute !important;
        }
        
        /* Estilo para garantir que a estrutura HTML permita que o mapa ocupe 100% */
        html, body {
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }
        
        /* Estilo para cont√™iner principal */
        .container-fluid {
            height: 100vh !important;
            width: 100% !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }
        
        /* Bot√£o de expandir/minimizar removido - funcionalidade incorporada nos bot√µes das abas */
        
        .bottom-tabs-nav {
            display: flex;
            justify-content: space-around; /* Espa√ßamento melhor distribu√≠do */
            gap: 8px; /* Aumentado o espa√ßo entre os bot√µes */
            padding: 12px 0 6px; /* Aumentado padding vertical */
            background: linear-gradient(to bottom, #fff8e1, #ffffff);
            border-bottom: 1px solid #ffe082;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        
        .bottom-tab-btn {
            padding: 10px 20px; /* Aumentado o padding */
            background-color: #f8f9fa;
            border: 1px solid #ffe082;
            border-radius: 20px; /* Aumentado o arredondamento */
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            color: #495057;
            position: relative;
            overflow: hidden;
            font-size: 0.9rem; /* Texto um pouco maior */
            white-space: nowrap; /* Evita quebra de linha */
            min-width: 120px; /* Tamanho m√≠nimo para bot√µes maiores */
            text-align: center; /* Centralizar o texto */
        }
        
        .bottom-tab-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #ffc107;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .bottom-tab-btn:hover {
            background-color: #fff8e1;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(255, 193, 7, 0.2);
        }
        
        .bottom-tab-btn:hover::before {
            opacity: 0.8;
            transform: scale(1.1);
        }
        
        .bottom-tab-btn.active {
            background-color: #ffc107;
            color: #000000;
            border-color: #ffab00;
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(255, 171, 0, 0.3);
            position: relative;
            overflow: hidden;
            font-weight: 600;
        }
        
        /* Adicionar indicador sob a aba ativa */
        .bottom-tab-btn.active::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: #ffeb3b;
            transform: scaleX(1);
            animation: pulseWidth 2s infinite;
        }
        
        @keyframes pulseWidth {
            0%, 100% { transform: scaleX(0.95); }
            50% { transform: scaleX(1.05); }
        }
        
        /* Adicione um √≠cone adequado a cada tab inferior */
        .bottom-tab-btn[data-tab="bottom-events"]::before {
            content: "üéâ";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-restrictions"]::before {
            content: "üö´";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-report"]::before {
            content: "üìä";
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-content {
            display: none; /* Todas as abas come√ßam ocultas */
            padding: 20px;
            background-color: white;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
            transform: translateY(20px);
            overflow-y: auto; /* Permite rolagem vertical para todos os conte√∫dos */
            width: 100%; /* Usa toda a largura dispon√≠vel */
        }
        
        /* Mostra apenas o conte√∫do ativo */
        .bottom-tab-content.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Ajustes para quando as abas est√£o minimizadas */
        .bottom-tabs-container.minimized .bottom-tab-content {
            height: 300px; /* Altura fixa quando minimizado */
        }
        
        /* Ajustes para quando as abas est√£o expandidas at√© o topo */
        .bottom-tabs-container:not(.minimized) .bottom-tab-content {
            height: calc(100vh - 140px); /* Quase altura total da tela quando expandido */
            padding: 25px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
            border-radius: 0 0 8px 8px;
            border: 1px solid #e0e0e0;
            margin: 0 15px 15px;
            flex: 1; /* Cresce para preencher o espa√ßo dispon√≠vel */
        }
        
        /* Para garantir que os containers internos preencham o espa√ßo dispon√≠vel */
        .bottom-tabs-container:not(.minimized) .events-container,
        .bottom-tabs-container:not(.minimized) .restrictions-container {
            flex: 1;
            height: 100%; /* Usa toda a altura dispon√≠vel */
            min-height: 300px;
        }
        
        /* Ajustes espec√≠ficos para a aba de restri√ß√µes */
        #bottom-restrictions-content {
            overflow-y: auto;
        }
        
        .bottom-tab-content.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOutDown {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Ajustes para o layout responsivo */
        @media (max-width: 768px) {
            .bottom-tabs-nav {
                flex-wrap: wrap;
            }
            
            .bottom-tab-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }
        
        /* Estilo para o marcador contador de regi√µes (tipo agulha) */
        .region-counter-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 40px;
            border-radius: 15px 15px 0 15px;
            transform: rotate(-45deg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            position: relative;
            font-weight: bold;
        }
        
        .region-counter-marker div {
            transform: rotate(45deg);
            color: white;
            font-size: 14px;
            font-family: Arial, sans-serif;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        /* Estilo para os controles personalizados do mapa */
        .custom-map-control {
            margin: 10px;
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }
        
        .map-control-button {
            background-color: #fff;
            border: none;
            color: #666;
            font-size: 16px;
            line-height: 24px;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .map-control-button:hover {
            background-color: #f1f1f1;
            color: #000;
        }
        
        .map-control-button.active {
            background-color: #ffc107;
            color: #000;
        }
    </style>
<link rel="stylesheet" href="modern-inputs.css"><script src="unified-file-upload.js"></script><script src="fix-duplicated-upload.js"></script><script src="header-origin-sync.js"></script><link rel="stylesheet" href="compact-form.css"></head>
<body>
    <div class="app-container">
        <div class="main-content-area">
            <!-- Sidebar para controles e informa√ß√µes -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="d-flex flex-column">
                    <h2 class="m-0 app-title">
                        <span class="app-title-text">Otimizador de Rotas</span>
                        <span class="app-title-highlight">M√≥veis Bonaf√©</span>
                    </h2>
                    <div class="origin-mini mt-2 d-flex align-items-center">
                        <span class="origin-icon-mini me-1">üìç</span>
                        <span class="origin-text-mini" id="origin-mini">Dois C√≥rregos, SP</span>
                    </div>
                </div>
            </div>
            <div class="sidebar-content">
            
            <!-- A aba de Locais fica no sidebar -->
            <div id="locations-content">
                    <!-- O conte√∫do de locais fica no sidebar -->
                
                    <!-- Filtro de eventos por data - DESIGN MODERNO -->
                    <div class="filter-container">
                        <h3>Filtrar eventos por data</h3>
                        <div class="date-filters">
                            <div class="date-input">
                                <label>Data inicial</label>
                                <input type="date" id="start-date" class="modern-input">
                            </div>
                            <div class="date-input">
                                <label>Data final</label>
                                <input type="date" id="end-date" class="modern-input">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Se√ß√£o de origem movida para o cabe√ßalho -->
                    
                    <!-- Campo de busca para adicionar novo local - DESIGN MODERNO -->
                    <div class="location-form">
                        <h3>Adicionar local</h3>
                        <div class="input-group">
                            <input type="text" id="location-search" placeholder="Digite um endere√ßo" class="animated-input">
                            <span class="input-icon">üîç</span>
                        </div>
                    </div>
                    
                    <!-- Sele√ß√£o de ve√≠culo removida, agora usa caminh√£o padr√£o automaticamente -->
                    
                    <!-- Upload de arquivo - DESIGN MODERNO ANIMADO -->
                    <div class="file-upload-container" id="upload-area">
                        <div class="upload-icon">üìÇ</div>
                        <h3>Importar CEPs via arquivo</h3>
                        <div class="file-format-example">Formato: CEP,Nome</div>
                        <div class="upload-animation">
                            <span class="upload-text">Arraste arquivo ou clique aqui</span>
                            <span class="upload-pulse"></span>
                        </div>
                        <input type="file" id="file-upload" accept=".txt,.csv">
                        <div id="upload-status" style="display: none; padding: 10px; margin-top: 10px; border-radius: 4px; font-weight: 600;"></div>
                    </div>
                    
                    <!-- Lista de locais adicionados -->
                    <h5 class="mt-3 mb-2" style="font-size: 14px;">Locais adicionados:</h5>
                    <div class="location-list" id="locations-list" style="max-height: 400px; overflow-y: auto;">
                        <!-- Locais ser√£o adicionados aqui dinamicamente -->
                    </div>
                    
                    <!-- Bot√£o para otimizar rota -->
                    <div class="optimize-btn-container">
                        <button id="optimize-route" class="btn" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00;">
                            Otimizar Rota
                        </button>
                    </div>
                    
                    <!-- Sele√ß√£o de Rota Alternativa na sidebar (redesenhada) -->
                    <div id="route-alternatives-sidebar" class="alternative-routes-section" style="display: none;">
                        <h5>Rotas Alternativas</h5>
                        <p class="text-muted small mb-3">Escolha a melhor op√ß√£o para seu trajeto:</p>
                        
                        <div id="route-options-container">
                            <!-- Cards gerados dinamicamente -->
                            <div class="route-option-card selected" data-route="0" id="route-card-0">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Rota Otimizada</strong>
                                    <span class="badge bg-primary">Recomendada</span>
                                </div>
                                <div class="text-muted small" id="route-0-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Dist√¢ncia total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                            
                            <div class="route-option-card" data-route="1" id="route-card-1" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Alternativa 1</strong>
                                </div>
                                <div class="text-muted small" id="route-1-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Dist√¢ncia total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                            
                            <div class="route-option-card" data-route="2" id="route-card-2" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <strong>Alternativa 2</strong>
                                </div>
                                <div class="text-muted small" id="route-2-details">
                                    <span class="me-2"><i class="bi bi-truck"></i> Dist√¢ncia total</span>
                                    <span><i class="bi bi-clock"></i> Tempo estimado</span>
                                </div>
                            </div>
                        </div>
                        
                        <small class="text-muted d-block mt-3" style="font-size: 0.75rem;">
                            Cada rota usa um algoritmo diferente com trade-offs entre dist√¢ncia e tempo.
                        </small>
                        
                        <!-- Seletor escondido para compatibilidade com c√≥digo existente -->
                        <select id="alternative-routes-sidebar" class="d-none">
                            <option value="0">Rota Otimizada (Padr√£o)</option>
                            <!-- Op√ß√µes de rotas alternativas ser√£o adicionadas dinamicamente -->
                        </select>
                    </div>
                </div>
                
                <!-- Conte√∫do do sidebar apenas com a se√ß√£o de Locais -->
            </div>
        </div>
        
        <!-- Container do mapa -->
        <div class="map-container">
            <div id="map">
                <!-- Bot√£o para mostrar/esconder marcadores de contagem (movido para canto inferior direito) -->
                <button id="counter-toggle" class="btn btn-sm btn-info map-control-button active" style="position: absolute; bottom: 70px; right: 10px; z-index: 1000; padding: 5px 8px; background-color: rgba(0, 0, 0, 0.7); color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3);" title="Esconder contadores regionais" onclick="toggleCountMarkers()">
                    üî¢
                </button>
            </div>
            <div id="loading-spinner">Calculando rota...</div>
            
            <!-- Controles do mapa -->
            <div class="map-controls">
<!-- Bot√£o de ajustar zoom removido conforme solicitado -->
                <button class="map-control-btn" id="toggle-poi" title="Mostrar/ocultar pontos de interesse">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                    </svg>
                </button>
                <button class="map-control-btn" id="show-legend" onclick="createRegionLegend()" title="Mostrar/ocultar legenda de regi√µes">
                    <span style="font-weight: bold; font-family: Arial, sans-serif; font-size: 16px;">L</span>
                </button>
            </div>
        </div>
        </div>
        
        <!-- NOVO: Tabs fixas na parte inferior do layout (inicialmente minimizadas) -->
        <div class="bottom-tabs-container minimized">
            <!-- Sem bot√£o adicional - os pr√≥prios bot√µes das abas controlam expandir/minimizar -->
            <!-- Navega√ß√£o das abas inferiores -->
            <div class="bottom-tabs-nav">
                <button class="bottom-tab-btn" data-tab="bottom-events">Eventos na Rota</button>
                <button class="bottom-tab-btn" data-tab="bottom-restrictions">Restri√ß√µes de Tr√°fego</button>
                <button class="bottom-tab-btn" data-tab="bottom-report">Relat√≥rio da Rota</button>
            </div>
            
            <!-- Conte√∫do da aba Eventos -->
            <div class="bottom-tab-content" id="bottom-events-content">
                <h5>Eventos nas cidades da rota:</h5>
                <!-- Container que se adapta √† janela -->
                <div class="events-container" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex-grow: 1;">
                    <div class="events-list" id="events-list" style="height: 100%;">
                        <p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                    </div>
                </div>
            </div>
            
            <!-- Conte√∫do da aba Restri√ß√µes -->
            <div class="bottom-tab-content" id="bottom-restrictions-content">
                <h5>Restri√ß√µes para caminh√µes do percurso:</h5>
                <p class="small text-muted mb-3">Filtrando para: caminh√£o de 1 eixo, 2 eixos, truck, comercial e toco</p>
                <!-- Container que se adapta √† janela -->
                <div class="restrictions-container" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex-grow: 1;">
                    <div class="restrictions-list" id="restrictions-list" style="height: 100%;">
                        <p class="text-muted">Nenhuma restri√ß√£o encontrada. Adicione locais e otimize a rota para ver restri√ß√µes nas cidades do percurso.</p>
                    </div>
                </div>
            </div>
            
            <!-- Conte√∫do da aba Relat√≥rio -->
            <div class="bottom-tab-content" id="bottom-report-content">
                <div id="route-summary" class="mb-4" style="width: 100%; height: 100%; min-height: 300px; overflow-y: auto; flex: 1; background-color: #fff8e1; border-radius: 8px; border: 1px solid #ffe082; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.03);">
                    <p class="text-muted">Otimize uma rota para ver o relat√≥rio detalhado.</p>
                </div>
                
                <!-- Se√ß√£o de Rotas Alternativas removida - movida para a sidebar -->
                
                <div class="form-group">
                    <label class="date-range-label">Nome da rota:</label>
                    <div class="input-animation-container position-relative">
                        <input type="text" id="report-route-name" placeholder="Ex: Entrega Regi√£o Sul" 
                               style="border: 1px solid #ffe082; border-radius: 8px; padding: 10px 12px; 
                               width: 100%; max-width: 400px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
                               transition: all 0.3s ease;">
                        <div class="input-animation-effect"></div>
                    </div>
                </div>
                
                <div class="mt-3">
                    <button id="save-route" class="btn" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00;" disabled>Salvar Rota</button>
                    <button id="print-route" class="btn ms-2" style="background-color: #ffc107; color: #000000; font-weight: 600; border-color: #ffab00;" disabled>Imprimir</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts externos -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="cep-database.js"></script>
    <script src="geocode-fix.js"></script>
    <script src="map-controls.js"></script>
    <script src="route-optimizer.js"></script>
    <script src="tsp.js"></script>
    <script src="cep-uploader.js"></script>
    <script src="fix-map-controls.js"></script>
    
    <script>
    // Dados de amostra para a aplica√ß√£o standalone
    const mockData = {
        // Origem (Dois C√≥rregos)
        origin: {
            id: 1,
            name: "Dois C√≥rregos",
            address: "Dois C√≥rregos, SP, Brasil",
            zipCode: "17300-000",
            latitude: -22.3673,
            longitude: -48.3822,
            isOrigin: true
        },
        
        // Tipos de ve√≠culos
        vehicleTypes: [
            { id: 1, name: "Caminh√£o 1 eixo", type: "truck1", costPerKm: 3.5, fuelConsumption: 4.5, averageSpeed: 75 },
            { id: 2, name: "Caminh√£o 2 eixos", type: "truck2", costPerKm: 4.2, fuelConsumption: 5.2, averageSpeed: 70 },
            { id: 3, name: "Caminh√£o truck", type: "truck3", costPerKm: 5.0, fuelConsumption: 6.0, averageSpeed: 65 },
            { id: 4, name: "Caminh√£o comercial", type: "truck4", costPerKm: 4.0, fuelConsumption: 5.0, averageSpeed: 80 },
            { id: 5, name: "Caminh√£o toco", type: "truck5", costPerKm: 6.5, fuelConsumption: 8.0, averageSpeed: 55 }
        ],
        
        // Pontos de interesse
        pointsOfInterest: [
            { id: 1, name: "Ped√°gio SP-225 (Brotas)", type: "toll", latitude: -22.2544, longitude: -48.1247, highway: "SP-225", cityName: "Brotas", cost: 11.30 },
            { id: 2, name: "Ped√°gio SP-225 (Ja√∫)", type: "toll", latitude: -22.2877, longitude: -48.5325, highway: "SP-225", cityName: "Ja√∫", cost: 7.90 },
            { id: 3, name: "Ped√°gio SP-300 (Botucatu)", type: "toll", latitude: -22.8932, longitude: -48.4521, highway: "SP-300", cityName: "Botucatu", cost: 9.50 },
            { id: 4, name: "Balan√ßa SP-225 (Dois C√≥rregos)", type: "weighStation", latitude: -22.3532, longitude: -48.3301, highway: "SP-225", cityName: "Dois C√≥rregos", isActive: true },
            { id: 5, name: "Balan√ßa SP-300 (Botucatu)", type: "weighStation", latitude: -22.9011, longitude: -48.4402, highway: "SP-300", cityName: "Botucatu", isActive: true },
            { id: 6, name: "Posto de combust√≠vel Shell (Dois C√≥rregos)", type: "gasStation", latitude: -22.3673, longitude: -48.3900, highway: "SP-225", cityName: "Dois C√≥rregos", services: ["food", "rest", "shower"] },
            { id: 7, name: "Posto de combust√≠vel BR (Ja√∫)", type: "gasStation", latitude: -22.2870, longitude: -48.5400, highway: "SP-225", cityName: "Ja√∫", services: ["food", "mechanic"] },
            { id: 8, name: "Borracharia 24h (Botucatu)", type: "mechanic", latitude: -22.8900, longitude: -48.4500, highway: "SP-300", cityName: "Botucatu", services: ["tire"] }
        ],
        
        // Eventos de cidades (com anivers√°rios atualizados para 2025)
        cityEvents: [
            // Anivers√°rios das principais cidades (eventos fixos - feriados municipais)
            { id: 99, cityName: "Dois C√≥rregos", name: "Festival de Ver√£o", startDate: "2025-01-01", endDate: "2025-12-31", isHoliday: false, description: "Festival com atividades durante todo o ano", restrictionLevel: "low" },
            { id: 1, cityName: "Dois C√≥rregos", name: "Anivers√°rio da Cidade", startDate: "2025-02-04", endDate: "2025-02-04", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Dois C√≥rregos em 04/02/1883", restrictionLevel: "low" },
            { id: 2, cityName: "Ja√∫", name: "Anivers√°rio da Cidade", startDate: "2025-08-15", endDate: "2025-08-15", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Ja√∫ em 15/08/1853", restrictionLevel: "low" },
            { id: 3, cityName: "Botucatu", name: "Anivers√°rio da Cidade", startDate: "2025-04-14", endDate: "2025-04-14", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Botucatu em 14/04/1855", restrictionLevel: "low" },
            { id: 4, cityName: "Bauru", name: "Anivers√°rio da Cidade", startDate: "2025-08-01", endDate: "2025-08-01", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Bauru em 01/08/1896", restrictionLevel: "low" },
            { id: 5, cityName: "Ribeir√£o Preto", name: "Anivers√°rio da Cidade", startDate: "2025-06-19", endDate: "2025-06-19", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Ribeir√£o Preto em 19/06/1856", restrictionLevel: "low" },
            { id: 6, cityName: "S√£o Paulo", name: "Anivers√°rio da Cidade", startDate: "2025-01-25", endDate: "2025-01-25", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de S√£o Paulo em 25/01/1554", restrictionLevel: "high" },
            { id: 7, cityName: "Campinas", name: "Anivers√°rio da Cidade", startDate: "2025-07-14", endDate: "2025-07-14", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de Campinas em 14/07/1774", restrictionLevel: "medium" },
            { id: 8, cityName: "S√£o Carlos", name: "Anivers√°rio da Cidade", startDate: "2025-11-04", endDate: "2025-11-04", isHoliday: true, description: "Anivers√°rio de funda√ß√£o de S√£o Carlos em 04/11/1857", restrictionLevel: "low" },
            
            // Eventos regulares
            { id: 9, cityName: "Ja√∫", name: "Festa do Rodeio", startDate: "2025-06-10", endDate: "2025-06-20", isHoliday: false, description: "Evento com grande circula√ß√£o de ve√≠culos", restrictionLevel: "medium" },
            { id: 10, cityName: "Botucatu", name: "Festival de Inverno", startDate: "2025-07-15", endDate: "2025-07-30", isHoliday: false, description: "Evento cultural e gastron√¥mico", restrictionLevel: "low" },
            { id: 11, cityName: "Bauru", name: "Exposi√ß√£o Agropecu√°ria", startDate: "2025-08-05", endDate: "2025-08-15", isHoliday: false, description: "Feira agropecu√°ria com shows", restrictionLevel: "high" },
            { id: 12, cityName: "Ribeir√£o Preto", name: "Agrishow", startDate: "2025-04-25", endDate: "2025-04-29", isHoliday: false, description: "Maior feira de agroneg√≥cio da Am√©rica Latina com forte impacto no tr√°fego local", restrictionLevel: "high" },
            { id: 13, cityName: "S√£o Paulo", name: "Virada Cultural", startDate: "2025-05-17", endDate: "2025-05-18", isHoliday: false, description: "Festival de 24 horas com eventos culturais pela cidade", restrictionLevel: "medium" },
            { id: 14, cityName: "Ribeir√£o Preto", name: "Feira Tecnol√≥gica", startDate: "2025-05-15", endDate: "2025-05-18", isHoliday: false, description: "Exposi√ß√£o de novas tecnologias agr√≠colas", restrictionLevel: "medium" }
        ],
        
        // Restri√ß√µes para caminh√µes
        truckRestrictions: [
            { id: 1, cityName: "Dois C√≥rregos", dayType: "weekday", startTime: "07:00", endTime: "09:00", restrictionType: "partial", description: "Restri√ß√£o parcial para caminh√µes de grande porte no centro", affectedVehicles: ["truck1", "truck5", "truck6", "truck7", "truck9"] },
            { id: 2, cityName: "Ja√∫", dayType: "weekday", startTime: "17:00", endTime: "20:00", restrictionType: "partial", description: "Restri√ß√£o parcial para todos os caminh√µes no centro", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 3, cityName: "Botucatu", dayType: "weekend", startTime: "08:00", endTime: "18:00", restrictionType: "total", description: "Proibi√ß√£o total para caminh√µes na √°rea central", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 4, cityName: "Bauru", dayType: "all", startTime: "07:00", endTime: "22:00", restrictionType: "rodizio", description: "Sistema de rod√≠zio para todos os caminh√µes", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 5, cityName: "Campinas", dayType: "all", startTime: "06:00", endTime: "20:00", restrictionType: "total", description: "Zona de M√°xima Restri√ß√£o de Circula√ß√£o (ZMRC) - proibi√ß√£o total para caminh√µes", affectedVehicles: ["truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 6, cityName: "Campinas", dayType: "weekday", startTime: "07:00", endTime: "10:00", restrictionType: "partial", description: "Restri√ß√£o adicional para todos os tipos de caminh√µes nas vias principais", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 7, cityName: "S√£o Paulo", dayType: "all", startTime: "04:00", endTime: "22:00", restrictionType: "total", description: "Zona de M√°xima Restri√ß√£o de Circula√ß√£o - proibi√ß√£o total", affectedVehicles: ["truck1", "truck2", "truck3", "truck4", "truck5", "truck6", "truck7", "truck9"] },
            { id: 8, cityName: "Ribeir√£o Preto", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restri√ß√£o de circula√ß√£o no centro expandido", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 9, cityName: "Piracicaba", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restri√ß√£o na regi√£o central", affectedVehicles: ["truck3", "truck4", "truck5", "truck7"] },
            { id: 10, cityName: "S√£o Carlos", dayType: "all", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restri√ß√£o no centro comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 11, cityName: "Sorocaba", dayType: "weekday", startTime: "08:00", endTime: "17:00", restrictionType: "partial", description: "Restri√ß√£o para ve√≠culos pesados na √°rea central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 12, cityName: "Americana", dayType: "weekday", startTime: "07:00", endTime: "19:00", restrictionType: "partial", description: "Restri√ß√£o na zona comercial", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 13, cityName: "Limeira", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restri√ß√£o no per√≠metro central", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] },
            { id: 14, cityName: "Rio Claro", dayType: "weekday", startTime: "07:30", endTime: "18:30", restrictionType: "partial", description: "Restri√ß√£o na √°rea central", affectedVehicles: ["truck3", "truck4", "truck5"] },
            { id: 15, cityName: "Araraquara", dayType: "weekday", startTime: "08:00", endTime: "18:00", restrictionType: "partial", description: "Restri√ß√£o para ve√≠culos pesados no centro", affectedVehicles: ["truck2", "truck3", "truck4", "truck5"] }
        ]
    };

    // Vari√°veis globais
    let map;
    let directionsService;
    let directionsRenderer;
    let autocomplete;
    let markers = [];
    let currentOptimizedPath = []; // Array para armazenar os IDs do caminho otimizado atual
    let poiMarkers = [];
    let eventMarkers = [];
    let regionCounterMarkers = {}; // Armazenar marcadores de contagem por regi√£o
    let regionCounts = {}; // Armazenar contagem de locais por regi√£o
    let locationId = 2; // Come√ßa em 2 porque 1 √© reservado para a origem
    
    // Defini√ß√£o global das cores padr√£o das regi√µes - FONTE OFICIAL DE CORES
    // S√£o Paulo
    const CORES_SP = {
        'Ara√ßatuba': '#FF5733',        // Laranja
        'Araraquara': '#900C3F',       // Vinho
        'Bauru': '#FF8D33',            // Laranja claro
        'Campinas': '#C70039',         // Vermelho
        'Mar√≠lia': '#900C3F',          // Vinho
        'Presidente Prudente': '#C70039', // Vermelho
        'Ribeir√£o Preto': '#581845',   // Roxo escuro
        'S√£o Jos√© do Rio Preto': '#FFC300', // Amarelo
        'S√£o Jos√© dos Campos': '#FF5733', // Laranja
        'S√£o Paulo': '#337DFF',        // Azul
        'Sorocaba': '#33A8FF'          // Azul claro
    };
    
    // Minas Gerais
    const CORES_MG = {
        'Barbacena': '#008080',           // Turquesa
        'Belo Horizonte': '#AB4500',      // Laranja queimado
        'Divin√≥polis': '#9932CC',         // Roxo
        'Governador Valadares': '#20B2AA', // Verde √°gua
        'Ipatinga': '#800080',            // Roxo escuro
        'Juiz de Fora': '#8B008B',        // Magenta
        'Montes Claros': '#7B2343',       // Bord√¥
        'Patos de Minas': '#FFD700',      // Amarelo ouro
        'Pouso Alegre': '#4169E1',        // Azul royal
        'Te√≥filo Otoni': '#2F4F4F',       // Cinza escuro
        'Uberaba': '#DAA520',             // Dourado
        'Uberl√¢ndia': '#8FBC8F',          // Verde claro
        'Varginha': '#708090'             // Cinza ard√≥sia
    };
    let locations = [mockData.origin];
    let activeInfoWindow = null;
    let routePath = null;
    let routeAnimationTimeout = null;
    let showPOIs = true;
    let customTooltip = null;
    let directionsRendererInitialized = false; // Flag para rastrear inicializa√ß√£o correta do renderer
    // Vari√°veis para rotas alternativas
    let alternativeRoutes = [];
    let currentRouteIndex = 0;
    let currentDisplayedRoute = null; // Guarda refer√™ncia √† rota atualmente exibida
    let allRoutePolylines = []; // Armazena refer√™ncias a todas as polylines criadas
    let tspSolver = null; // Inst√¢ncia do solver TSP
    
    // Defini√ß√£o das regi√µes de S√£o Paulo e suas cidades para visualiza√ß√£o regional
    const regioesSP = {
        'S√£o Jos√© dos Campos': {
            cidades: [
                'S√£o Jos√© dos Campos', 'Ca√ßapava', 'Igarat√°', 'Jacare√≠', 'Jambeiro', 'Monteiro Lobato', 
                'Paraibuna', 'Santa Branca', 'Campos do Jord√£o', 'Lagoinha', 'Natividade da Serra', 
                'Pindamonhangaba', 'Reden√ß√£o da Serra', 'Santo Ant√¥nio do Pinhal', 'S√£o Bento do Sapuca√≠', 
                'S√£o Luiz do Paraitinga', 'Taubat√©', 'Trememb√©', 'Caraguatatuba', 'Ilhabela', 
                'S√£o Sebasti√£o', 'Ubatuba', 'Aparecida', 'Canas', 'Cunha', 'Guaratinguet√°', 
                'Lorena', 'Piquete', 'Potim', 'Roseira', 'Arape√≠', 'Areias', 'Bananal', 
                'Cachoeira Paulista', 'Cruzeiro', 'Lavrinhas', 'Queluz', 'S√£o Jos√© do Barreiro', 'Silveiras'
            ],
            cor: '#FF5733' // Vermelho-alaranjado
        },
        'Campinas': {
            cidades: [
                'Americana', 'Artur Nogueira', 'Campinas', 'Cosm√≥polis', 'Elias Fausto', 'Holambra',
                'Hortol√¢ndia', 'Indaiatuba', 'Jaguari√∫na', 'Monte Mor', 'Nova Odessa', 'Paul√≠nia',
                'Pedreira', 'Santa B√°rbara d\'Oeste', 'Santo Ant√¥nio de Posse', 'Sumar√©', 'Valinhos',
                'Vinhedo', 'Cabre√∫va', 'Campo Limpo Paulista', 'Itatiba', 'Itupeva', 'Jarinu', 'Jundia√≠',
                'Louveira', 'Morungaba', 'V√°rzea Paulista', '√Åguas de S√£o Pedro', 'Capivari',
                'Charqueada', 'Laranjal Paulista', 'Mombuca', 'Piracicaba', 'Rafard', 'Rio das Pedras',
                'Saltinho', 'Santa Maria da Serra', 'S√£o Pedro', 'Atibaia', 'Bom Jesus dos Perd√µes',
                'Bragan√ßa Paulista', 'Joan√≥polis', 'Nazar√© Paulista', 'Pedra Bela', 'Pinhalzinho',
                'Piracaia', 'Socorro', 'Tuiuti', 'Vargem', 'Cordeir√≥polis', 'Engenheiro Coelho',
                'Iracem√°polis', 'Limeira', 'Estiva Gerbi', 'Itapira', 'Mogi Gua√ßu', 'Mogi Mirim',
                'Agua√≠', '√Åguas da Prata', 'Casa Branca', 'Esp√≠rito Santo do Pinhal',
                'Santa Cruz das Palmeiras', 'Santo Ant√¥nio do Jardim', 'S√£o Jo√£o da Boa Vista',
                'Tamba√∫', 'Vargem Grande do Sul', 'Araras', 'Conchal', 'Leme', 'Santa Cruz da Concei√ß√£o',
                'Anal√¢ndia', 'Corumbata√≠', 'Ipe√∫na', 'Rio Claro', 'Santa Gertrudes', 'Caconde',
                'Divinol√¢ndia', 'Itobi', 'Mococa', 'S√£o Jos√© do Rio Pardo', 'S√£o Sebasti√£o da Grama',
                'Tapiratiba', '√Åguas de Lind√≥ia', 'Amparo', 'Lind√≥ia', 'Monte Alegre do Sul', 'Serra Negra'
            ],
            cor: '#33FF57' // Verde claro
        },
        'Araraquara': {
            cidades: [
                'Am√©rico Brasiliense', 'Araraquara', 'Boa Esperan√ßa do Sul', 'Borborema',
                'C√¢ndido Rodrigues', 'Dobrada', 'Gavi√£o Peixoto', 'Ibitinga', 'It√°polis',
                'Mat√£o', 'Motuca', 'Nova Europa', 'Rinc√£o', 'Santa L√∫cia', 'Tabatinga',
                'Taquaritinga', 'Trabiju', 'Descalvado', 'Dourado', 'Ibat√©', 'Itirapina',
                'Pirassununga', 'Porto Ferreira', 'Ribeir√£o Bonito', 'Santa Rita do Passa Quatro', 'S√£o Carlos'
            ],
            cor: '#3357FF' // Azul
        },
        'Ribeir√£o Preto': {
            cidades: [
                'Altin√≥polis', 'Barrinha', 'Batatais', 'Brodowski', 'Cajuru', 
                'C√°ssia dos Coqueiros', 'Cravinhos', 'Dumont', 'Guariba', 'Guatapar√°', 
                'Jaboticabal', 'Jardin√≥polis', 'Luiz Ant√¥nio', 'Monte Alto', 'Pitangueiras', 
                'Pontal', 'Prad√≥polis', 'Ribeir√£o Preto', 'Santa Cruz da Esperan√ßa', 'Santa Ernestina', 
                'Santa Rosa de Viterbo', 'Santo Ant√¥nio da Alegria', 'S√£o Sim√£o', 'Serra Azul', 
                'Serrana', 'Sert√£ozinho', 'Barretos', 'Bebedouro', 'Cajobi', 'Colina', 
                'Col√¥mbia', 'Gua√≠ra', 'Guaraci', 'Jaborandi', 'Monte Azul Paulista', 
                'Ol√≠mpia', 'Sever√≠nia', 'Taia√ßu', 'Tai√∫va', 'Taquaral', 
                'Terra Roxa', 'Viradouro', 'Cristais Paulista', 'Franca', 'Itirapu√£', 
                'Jeriquara', 'Patroc√≠nio Paulista', 'Pedregulho', 'Restinga', 'Ribeir√£o Corrente', 
                'Rifaina', 'S√£o Jos√© da Bela Vista', 'Ipu√£', 'Morro Agudo', 'Nuporanga', 
                'Orl√¢ndia', 'Sales Oliveira', 'S√£o Joaquim da Barra', 'Aramina', 'Buritizal', 
                'Guar√°', 'Igarapava', 'Ituverava', 'Miguel√≥polis'
            ],
            cor: '#FF33A8' // Rosa
        },
        'S√£o Jos√© do Rio Preto': {
            cidades: [
                'Adolfo', 'Altair', 'Bady Bassitt', 'B√°lsamo', 'Cedral', 'Guapia√ßu', 'Ibir√°', 
                'Ic√©m', 'Ipigu√°', 'Irapu√£', 'Jaci', 'Jos√© Bonif√°cio', 'Macaubal', 'Mendon√ßa', 
                'Mirassol', 'Mirassol√¢ndia', 'Monte Apraz√≠vel', 'Neves Paulista', 'Nipo√£', 
                'Nova Alian√ßa', 'Nova Granada', 'Novo Horizonte', 'Onda Verde', 'Orindi√∫va', 
                'Palestina', 'Paulo de Faria', 'Planalto', 'Poloni', 'Potirendaba', 'Sales', 
                'S√£o Jos√© do Rio Preto', 'Tanabi', 'Ubarana', 'Uchoa', 'Uni√£o Paulista', 'Urup√™s', 
                'Ariranha', 'Catanduva', 'Catigu√°', 'Elisi√°rio', 'Emba√∫ba', 'Fernando Prestes', 
                'Itajobi', 'Marapoama', 'Novais', 'Palmares Paulista', 'Para√≠so', 'Pindorama', 
                'Pirangi', 'Santa Ad√©lia', 'Tabapu√£', 'Vista Alegre do Alto', '√Ålvares Florence', 
                'Am√©rico de Campos', 'Cardoso', 'Cosmorama', 'Floreal', 'Nhandeara', 'Parisi', 
                'Pontes Gestal', 'Riol√¢ndia', 'Sebastian√≥polis do Sul', 'Valentim Gentil', 'Votuporanga', 
                'Aparecida d\'Oeste', 'Asp√°sia', 'Dirce Reis', 'Dolcin√≥polis', 'Jales', 'Marin√≥polis', 
                'Mes√≥polis', 'Palmeira d\'Oeste', 'Paranapu√£', 'Pontalinda', 'Populina', 'Santa Albertina', 
                'Santa Salete', 'S√£o Francisco', 'Suzan√°polis', 'Turmalina', 'Ur√¢nia', 'Vit√≥ria Brasil', 
                'Estrela d\'Oeste', 'Fernand√≥polis', 'Guarani d\'Oeste', 'Indiapor√£', 'Maced√¥nia', 
                'Meridiano', 'Mira Estrela', 'Ouroeste', 'Pedran√≥polis', 'S√£o Jo√£o das Duas Pontes', 
                'S√£o Jo√£o de Iracema', 'Nova Cana√£ Paulista', 'Rubin√©ia', 'Santa Clara d\'Oeste', 
                'Santa F√© do Sul', 'Santa Rita d\'Oeste', 'Santana da Ponte Pensa', 'Tr√™s Fronteiras'
            ],
            cor: '#33FFF6' // Ciano
        },
        'Ara√ßatuba': {
            cidades: [
                'Ara√ßatuba', 'Auriflama', 'Bento de Abreu', 'Gast√£o Vidigal', 'General Salgado',
                'Guararapes', 'Guzol√¢ndia', 'Magda', 'Mon√ß√µes', 'Nova Castilho', 'Nova Luzit√¢nia',
                'Rubi√°cea', 'Santo Ant√¥nio do Aracangu√°', 'Valpara√≠so', 'Alto Alegre', 'Avanhandava',
                'Barbosa', 'Bilac', 'Birigui', 'Bra√∫na', 'Brejo Alegre', 'Buritama', 'Clementina',
                'Coroados', 'Gabriel Monteiro', 'Glic√©rio', 'Lourdes', 'Luizi√¢nia', 'Pen√°polis',
                'Piacatu', 'Sant√≥polis do Aguape√≠', 'Turi√∫ba', 'Zacarias', 'Andradina', 'Castilho',
                'Guara√ßa√≠', 'Ilha Solteira', 'Itapura', 'Lav√≠nia', 'Mirand√≥polis', 'Murutinga do Sul',
                'Nova Independ√™ncia', 'Pereira Barreto', 'Sud Mennucci'
            ],
            cor: '#F6FF33' // Amarelo
        },
        'Presidente Prudente': {
            cidades: [
                'Alfredo Marcondes', '√Ålvares Machado', 'Anhumas', 'Caiabu', 'Emilian√≥polis',
                'Estrela do Norte', 'Euclides da Cunha Paulista', 'Iep√™', 'Indiana', 'Jo√£o Ramalho',
                'Martin√≥polis', 'Mirante do Paranapanema', 'Nantes', 'Narandiba', 'Pirapozinho',
                'Presidente Bernardes', 'Presidente Prudente', 'Quat√°', 'Rancharia', 'Regente Feij√≥',
                'Ribeir√£o dos √çndios', 'Rosana', 'Sandovalina', 'Santo Anast√°cio', 'Santo Expedito',
                'Taciba', 'Tarabai', 'Teodoro Sampaio', 'Adamantina', 'Fl√≥rida Paulista',
                'In√∫bia Paulista', 'Luc√©lia', 'Mari√°polis', 'Osvaldo Cruz', 'Pacaembu',
                'Pracinha', 'Sagres', 'Salmour√£o', 'Dracena', 'Flora Rica',
                'Irapuru', 'Junqueir√≥polis', 'Monte Castelo', 'Nova Guataporanga', 'Ouro Verde',
                'Panorama', 'Paulic√©ia', 'Santa Mercedes', 'S√£o Jo√£o do Pau d\'Alho', 'Tupi Paulista',
                'Caiu√°', 'Marab√° Paulista', 'Piquerobi', 'Presidente Epit√°cio', 'Presidente Venceslau'
            ],
            cor: '#FF33F6' // Magenta
        },
        'Mar√≠lia': {
            cidades: [
                '√Ålvaro de Carvalho', 'Alvinl√¢ndia', 'Campos Novos Paulista', 'Echapor√£', 'Fern√£o',
                'G√°lia', 'Gar√ßa', 'Getulina', 'Guaimb√™', 'J√∫lio Mesquita', 'Lup√©rcio', 'Mar√≠lia',
                'Ocau√ßu', 'Oriente', 'Oscar Bressane', 'Pomp√©ia', 'Quintana', 'Vera Cruz', 'Assis',
                'Bor√°', 'C√¢ndido Mota', 'Cruz√°lia', 'Flor√≠nea', 'Lut√©cia', 'Maraca√≠', 'Palmital',
                'Paragua√ßu Paulista', 'Pedrinhas Paulista', 'Platina', 'Tarum√£', 'Bernardino de Campos',
                'Canitar', 'Chavantes', 'Esp√≠rito Santo do Turvo', 'Ibirarema', 'Ipaussu', 'Ourinhos',
                'Ribeir√£o do Sul', 'Salto Grande', 'Santa Cruz do Rio Pardo', 'S√£o Pedro do Turvo',
                'Arco-√çris', 'Bastos', 'Hercul√¢ndia', 'Iacri', 'Parapu√£', 'Queiroz', 'Rin√≥polis',
                'Tup√£', 'Fartura', 'Piraju', 'Sarutai√°', 'Tejup√°', 'Timburi'
            ],
            cor: '#8A33FF' // Roxo
        },
        'Bauru': {
            cidades: [
                'Agudos', 'Arealva', 'Ava√≠', 'Balbinos', 'Bauru', 'Borebi', 'Cabr√°lia Paulista',
                'Duartina', 'Iacanga', 'Len√ß√≥is Paulista', 'Lucian√≥polis', 'Macatuba', 'Paulist√¢nia',
                'Pederneiras', 'Piraju√≠', 'Piratininga', 'Presidente Alves', 'Regin√≥polis', 'Ubirajara',
                'Bariri', 'Barra Bonita', 'Bocaina', 'Boraceia', 'Brotas', 'Dois C√≥rregos',
                'Igara√ßu do Tiet√™', 'Itaju', 'Itapu√≠', 'Ja√∫', 'Mineiros do Tiet√™', 'Torrinha',
                'Anhembi', 'Arei√≥polis', 'Bofete', 'Botucatu', 'Conchas', 'Itatinga', 'Pardinho',
                'Prat√¢nia', 'S√£o Manuel', 'Cafel√¢ndia', 'Guai√ßara', 'Guarant√£', 'Lins', 'Ponga√≠',
                'Promiss√£o', 'Sabino', 'Uru'
            ],
            cor: '#FF8A33' // Laranja
        },
        'Sorocaba': {
            cidades: [
                'Alum√≠nio', 'Ara√ßariguama', 'Ara√ßoiaba da Serra', 'Boituva', 'Capela do Alto',
                'Cerquilho', 'Ibi√∫na', 'Iper√≥', 'Itu', 'Jumirim', 'Mairinque', 'Piedade',
                'Pilar do Sul', 'Porto Feliz', 'Salto', 'Salto de Pirapora', 'S√£o Roque',
                'Sarapu√≠', 'Sorocaba', 'Tapira√≠', 'Tiet√™', 'Votorantim', 'Apia√≠',
                'Bar√£o de Antonina', 'Barra do Chap√©u', 'Bom Sucesso de Itarar√©', 'Buri',
                'Cap√£o Bonito', 'Guapiara', 'Itaber√°', 'Itaoca', 'Itapeva', 'Itapirapu√£ Paulista',
                'Itaporanga', 'Itarar√©', 'Nova Campina', 'Ribeira', 'Ribeir√£o Branco',
                'Ribeir√£o Grande', 'Riversul', 'Taquariva√≠', 'Barra do Turvo', 'Cajati',
                'Canan√©ia', 'Eldorado', 'Iguape', 'Ilha Comprida', 'Iporanga', 'Jacupiranga',
                'Juqui√°', 'Miracatu', 'Pariquera-A√ßu', 'Registro', 'Sete Barras', 'Itapetininga',
                'S√£o Miguel Arcanjo', 'Angatuba', 'Guare√≠', 'Campina do Monte Alegre', 'Alambari',
                '√Åguas de Santa B√°rbara', 'Arandu', 'Avar√©', 'Cerqueira C√©sar', 'Coronel Macedo',
                'Iaras', 'Ita√≠', 'Manduri', '√ìleo', 'Paranapanema', 'Tagua√≠', 'Taquarituba',
                'Ces√°rio Lange', 'Pereiras', 'Porangaba', 'Quadra', 'Tatu√≠', 'Torre de Pedra'
            ],
            cor: '#33FF8A' // Verde esmeralda
        },
        'S√£o Paulo': {
            cidades: [
                'Aruj√°', 'Barueri', 'Biritiba Mirim', 'Caieiras', 'Cajamar', 'Carapicu√≠ba', 'Cotia',
                'Diadema', 'Embu das Artes', 'Embu-Gua√ßu', 'Ferraz de Vasconcelos', 'Francisco Morato',
                'Franco da Rocha', 'Guararema', 'Guarulhos', 'Itapecerica da Serra', 'Itapevi',
                'Itaquaquecetuba', 'Jandira', 'Juquitiba', 'Mairipor√£', 'Mau√°', 'Mogi das Cruzes',
                'Osasco', 'Pirapora do Bom Jesus', 'Po√°', 'Ribeir√£o Pires', 'Rio Grande da Serra',
                'Sales√≥polis', 'Santa Isabel', 'Santana de Parna√≠ba', 'Santo Andr√©', 'S√£o Bernardo do Campo',
                'S√£o Caetano do Sul', 'S√£o Louren√ßo da Serra', 'S√£o Paulo', 'Suzano', 'Tabo√£o da Serra',
                'Vargem Grande Paulista', 'Bertioga', 'Cubat√£o', 'Guaruj√°', 'Itanha√©m', 'Itariri', 'Mongagu√°',
                'Pedro de Toledo', 'Peru√≠be', 'Praia Grande', 'Santos', 'S√£o Vicente'
            ],
            cor: '#338AFF' // Azul claro
        },
        // Regi√µes de Minas Gerais
        'Belo Horizonte': {
            cidades: [
                'Belo Horizonte', 'Betim', 'Contagem', 'Nova Lima', 'Sabar√°', 'Santa Luzia',
                'Ribeir√£o das Neves', 'Vespasiano', 'Ibirit√©', 'Lagoa Santa', 'Pedro Leopoldo',
                'Caet√©', 'Brumadinho', 'Esmeraldas', 'Igarap√©', 'Mateus Leme', 'Rio Acima',
                'Raposos', 'S√£o Jos√© da Lapa', 'Confins'
            ],
            cor: '#AB4500' // Marrom avermelhado
        },
        'Montes Claros': {
            cidades: [
                'Montes Claros', 'Jana√∫ba', 'Janu√°ria', 'Pirapora', 'Bocai√∫va', 'Salinas',
                'Taiobeiras', 'S√£o Francisco', 'Bras√≠lia de Minas', 'Porteirinha', 'V√°rzea da Palma',
                'Espinosa', 'Ja√≠ba', 'Monte Azul', 'Francisco S√°', 'Manga', 'Cora√ß√£o de Jesus',
                'Rio Pardo de Minas', 'Buritizeiro', 'S√£o Jo√£o do Para√≠so'
            ],
            cor: '#7B2343' // Bord√¥
        },
        'Te√≥filo Otoni': {
            cidades: [
                'Te√≥filo Otoni', 'Nanuque', '√Åguas Formosas', 'Ara√ßua√≠', 'Carlos Chagas',
                'Malacacheta', 'Almenara', 'Pedra Azul', 'Medina', 'Itaobim', 'Novo Cruzeiro',
                'Padre Para√≠so', 'Itambacuri', 'Joa√≠ma', 'Atal√©ia', 'Ladainha', 'Jacinto',
                'Rubim', 'Cara√≠', 'Jequitinhonha'
            ],
            cor: '#2F4F4F' // Cinza ard√≥sia escuro
        },
        'Governador Valadares': {
            cidades: [
                'Governador Valadares', 'Mantena', 'Aimor√©s', 'Resplendor', 'Guanh√£es',
                'Conselheiro Pena', 'Santa Maria do Sua√ßu√≠', 'Mutum', 'Concei√ß√£o do Mato Dentro',
                'Galil√©ia', '√Ågua Boa', 'Capelinha', 'Diamantina', 'Turmalina', 'Minas Novas',
                'Serro', 'Sabin√≥polis', 'S√£o Jo√£o Evangelista', 'Itamarandiba', 'Pe√ßanha'
            ],
            cor: '#20B2AA' // Verde-mar claro
        },
        'Ipatinga': {
            cidades: [
                'Ipatinga', 'Coronel Fabriciano', 'Tim√≥teo', 'Jo√£o Monlevade', 'Itabira',
                'Caratinga', 'Ponte Nova', 'Nova Era', 'Inhapim', 'S√£o Jo√£o do Oriente',
                'Manhua√ßu', 'Belo Oriente', 'Santana do Para√≠so', 'Rio Piracicaba', 'A√ßucena',
                'Mesquita', 'Santa B√°rbara', 'Mariana', 'Ouro Preto', 'S√£o Domingos do Prata'
            ],
            cor: '#800080' // P√∫rpura
        },
        'Juiz de Fora': {
            cidades: [
                'Juiz de Fora', 'Muria√©', 'Ub√°', 'Cataguases', 'Leopoldina', 'Al√©m Para√≠ba',
                'S√£o Jo√£o Nepomuceno', 'Carangola', 'Santos Dumont', 'Rio Pomba', 'Visconde do Rio Branco',
                'Vi√ßosa', 'Mar de Espanha', 'Mira√≠', 'Espera Feliz', 'Eugen√≥polis', 'Tombos',
                'Recreio', 'Pirapetinga', 'Palma'
            ],
            cor: '#8B008B' // Magenta escuro
        },
        'Barbacena': {
            cidades: [
                'Barbacena', 'Conselheiro Lafaiete', 'S√£o Jo√£o del-Rei', 'Ouro Branco',
                'Congonhas', 'Entre Rios de Minas', 'Lagoa Dourada', 'Caranda√≠', 'Barroso',
                'Resende Costa', 'Piranga', 'Alto Rio Doce', 'Dores de Campos', 'Prados',
                'Ressaquinha', 'Senhora dos Rem√©dios', 'Ibertioga', 'Capela Nova', 'Carana√≠ba', 'Cristiano Otoni'
            ],
            cor: '#008080' // Verde-azulado
        },
        'Varginha': {
            cidades: [
                'Varginha', 'Alfenas', 'Tr√™s Cora√ß√µes', 'Lavras', 'Tr√™s Pontas', 'Campo Belo',
                'Boa Esperan√ßa', 'Perd√µes', 'El√≥i Mendes', 'Nepomuceno', 'Formiga', 'Cambuquira',
                'Lambari', 'Caxambu', 'S√£o Louren√ßo', 'Guaxup√©', 'Campos Gerais', 'Itamonte',
                'Carmo de Minas', 'Itanhandu'
            ],
            cor: '#708090' // Cinza ard√≥sia
        },
        'Pouso Alegre': {
            cidades: [
                'Pouso Alegre', 'Itajub√°', 'Santa Rita do Sapuca√≠', 'Extrema', 'Camanducaia',
                'Cambu√≠', 'Ouro Fino', 'Jacutinga', 'Monte Si√£o', 'Andradas', 'Borda da Mata',
                'Parais√≥polis', 'Po√ßos de Caldas', 'Caldas', 'S√£o Sebasti√£o da Bela Vista',
                'S√£o Gon√ßalo do Sapuca√≠', 'Braz√≥polis', 'Congonhal', 'Itapeva', 'Cachoeira de Minas'
            ],
            cor: '#4169E1' // Azul real
        },
        'Uberaba': {
            cidades: [
                'Uberaba', 'Arax√°', 'Frutal', 'Iturama', 'Sacramento', 'Concei√ß√£o das Alagoas',
                'Campo Florido', 'Conquista', '√Ågua Comprida', 'Planura', 'Campos Altos',
                'Pedrin√≥polis', 'Perdizes', 'Santa Juliana', 'Fronteira', 'Comendador Gomes',
                'Verissimo', 'Pirajuba', 'Delta', 'Tapira'
            ],
            cor: '#DAA520' // Dourado
        },
        'Uberl√¢ndia': {
            cidades: [
                'Uberl√¢ndia', 'Araguari', 'Ituiutaba', 'Prata', 'Monte Alegre de Minas',
                'Tupaciguara', 'Capin√≥polis', 'Santa Vit√≥ria', 'Campina Verde', 'Centralina',
                'Monte Carmelo', 'Patroc√≠nio', 'Coromandel', 'Abadia dos Dourados', 'Can√°polis',
                'Gurinhat√£', 'Ipia√ßu', 'Cachoeira Dourada', 'Estrela do Sul', 'Cascalho Rico'
            ],
            cor: '#8FBC8F' // Verde-mar escuro
        },
        'Patos de Minas': {
            cidades: [
                'Patos de Minas', 'Paracatu', 'Una√≠', 'Jo√£o Pinheiro', 'Vazante', 'Arinos',
                'Buritis', 'Guarda-Mor', 'Lagamar', 'Presidente Oleg√°rio', 'Brasil√¢ndia de Minas',
                'Lagoa Grande', 'Bonfin√≥polis de Minas', 'Chapada Ga√∫cha', 'S√£o Gon√ßalo do Abaet√©',
                'Cabeceira Grande', 'Formoso', 'Uruana de Minas', 'Dom Bosco', 'Natal√¢ndia'
            ],
            cor: '#FFD700' // Ouro
        },
        'Divin√≥polis': {
            cidades: [
                'Divin√≥polis', 'Ita√∫na', 'Par√° de Minas', 'Nova Serrana', 'Bom Despacho',
                'Oliveira', 'Arcos', 'Cl√°udio', 'Carmo do Cajuru', 'Campo Belo', 'Bambu√≠',
                'Luz', 'Piumhi', 'Lagoa da Prata', 'Santo Ant√¥nio do Monte', 'Itapecerica',
                'Bom Sucesso', 'Pitangui', 'Pomp√©u', 'Martinho Campos'
            ],
            cor: '#9932CC' // Orqu√≠dea escura
        }
    };
    
    // Fun√ß√£o para processar CEP em formato x.y.z.w-abcd
    function formatCEP(cep) {
        // Remover qualquer caracter n√£o num√©rico
        let numericCEP = cep.replace(/\D/g, '');
        
        // Formatar como xxxxx-xxx
        if (numericCEP.length >= 8) {
            return numericCEP.substring(0, 5) + '-' + numericCEP.substring(5, 8);
        }
        
        return cep; // Retornar original se n√£o for poss√≠vel formatar
    }
    
    // Fun√ß√£o global auxiliar para exibir notifica√ß√µes de forma segura
    function showNotification(message, type = 'info', targetSelector = '.route-controls', autoRemove = true, duration = 5000) {
        console.log(`Notifica√ß√£o [${type}]: ${message}`);
        
        // Criar elemento de notifica√ß√£o
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} mt-2`;
        notification.innerHTML = message;
        
        // Tentar diferentes locais na ordem de prioridade
        const possibleTargets = [
            targetSelector,
            '.route-controls',
            '#sidebar',
            '.sidebar-content',
            '.tab-content:first-child',
            'body'
        ];
        
        let targetElement = null;
        
        // Tentar cada seletor at√© encontrar um elemento v√°lido
        for (const selector of possibleTargets) {
            try {
                const element = document.querySelector(selector);
                if (element) {
                    targetElement = element;
                    break;
                }
            } catch (err) {
                console.warn(`Erro ao buscar seletor ${selector}:`, err);
            }
        }
        
        // Anexar notifica√ß√£o se encontrou um elemento v√°lido
        if (targetElement) {
            try {
                targetElement.appendChild(notification);
                
                // Auto-remover ap√≥s um tempo, se solicitado
                if (autoRemove) {
                    setTimeout(() => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        } catch (err) {
                            console.warn("Erro ao remover notifica√ß√£o:", err);
                        }
                    }, duration);
                }
                
                return notification;
            } catch (err) {
                console.error("Erro ao adicionar notifica√ß√£o:", err);
            }
        } else {
            console.warn("N√£o foi poss√≠vel exibir notifica√ß√£o, nenhum elemento alvo encontrado");
        }
        
        return null;
    }

    // Inicializa√ß√£o
    document.addEventListener("DOMContentLoaded", function() {
        console.log("DOM carregado - inicializando aplica√ß√£o");
        
        // Event listener para o bot√£o de toggle das abas removido
        // A funcionalidade de toggle agora est√° incorporada nos pr√≥prios bot√µes das abas
        
        // Inicializar conte√∫do das abas com a origem
        // N√ÉO ativar nenhuma aba automaticamente - deixar para o usu√°rio decidir qual aba abrir
        
        // Mostrar informa√ß√µes iniciais nas abas
        showInitialTabsContent();
        
        // Verificar se temos acesso ao Google Maps
        if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
            console.error("Google Maps API n√£o carregada corretamente");
            showNotification("N√£o foi poss√≠vel carregar o Google Maps. Verifique sua conex√£o ou se h√° bloqueadores ativos no navegador.", "error");
        } else {
            console.log("Google Maps API dispon√≠vel");
        }
        
        // Inicializar componentes principais
        try {
            initMap();
            initAutocomplete();
            initTabNavigation();
            initEventListeners();
            
            // Verificar se estamos no GitHub Pages para ajustes adicionais
            if (window.location.href.includes('github.io')) {
                console.log("Detectado GitHub Pages - aplicando ajustes especiais de layout");
                
                // Aplicar corre√ß√µes espec√≠ficas para GitHub Pages ap√≥s um breve atraso
                setTimeout(() => {
                    const mapContainer = document.querySelector('.map-container');
                    const mapElement = document.getElementById('map');
                    
                    if (mapContainer && mapElement) {
                        // For√ßar tamanhos explicitamente
                        mapContainer.style.height = 'calc(100vh - 60px)';
                        mapElement.style.height = '100%';
                        
                        // For√ßar redesenho do mapa
                        if (typeof google !== 'undefined' && google.maps && map) {
                            google.maps.event.trigger(map, 'resize');
                        }
                        
                        console.log("Ajustes de layout para GitHub Pages aplicados");
                    }
                }, 500);
            }
        } catch (initError) {
            console.error("Erro ao inicializar a aplica√ß√£o:", initError);
        }
        
        // Exibir a origem no mapa
        addMarkerForLocation(mockData.origin, 0);
        
        // Definir data inicial como a data atual por padr√£o
        const today = new Date();
        const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
        
        // Calcular a data final (hoje + 7 dias)
        const endDate = new Date();
        endDate.setDate(today.getDate() + 7);
        const formattedEndDate = endDate.toISOString().split('T')[0];
        
        // Definir os valores dos campos de data
        document.getElementById('start-date').value = formattedToday;
        document.getElementById('end-date').value = formattedEndDate;
        
        console.log(`Datas definidas automaticamente: de ${formattedToday} at√© ${formattedEndDate}`);
        
        // Inicializar currentOptimizedPath com a origem para mostrar eventos/restri√ß√µes iniciais
        currentOptimizedPath = [mockData.origin.id];
        
        // Chamar fun√ß√µes para mostrar eventos e restri√ß√µes para a origem com base nas datas atuais
        filterEventsByDate();
        
        // Mostrar mensagem de ajuda
        console.log("Campos de data inicializados com datas atuais e eventos/restri√ß√µes para origem configurados");
    });

    // Extrai a cidade de um endere√ßo completo
    function extractCityFromAddress(address) {
        if (!address) return null;
        
        // Tenta encontrar o padr√£o "Cidade - UF" no endere√ßo
        const cityStateMatch = address.match(/([^,]+) - ([A-Z]{2})/);
        if (cityStateMatch && cityStateMatch.length > 1) {
            return cityStateMatch[1].trim();
        }
        
        // Tentar outro padr√£o comum "Cidade, UF"
        const cityStateCommaMatch = address.match(/([^,]+),\s*([A-Z]{2})/);
        if (cityStateCommaMatch && cityStateCommaMatch.length > 1) {
            return cityStateCommaMatch[1].trim();
        }
        
        // Lista de cidades conhecidas para detec√ß√£o direta
        const knownCities = [
            "Dois C√≥rregos", "Ja√∫", "Botucatu", "Bauru", "Ribeir√£o Preto", 
            "S√£o Paulo", "Campinas", "S√£o Carlos", "Piracicaba", "Araraquara",
            "Americana", "Sorocaba", "Limeira", "Rio Claro", "Len√ß√≥is Paulista"
        ];
        
        // Verificar se o endere√ßo cont√©m uma cidade conhecida
        for (const city of knownCities) {
            if (address.includes(city)) {
                return city;
            }
        }
        
        return null;
    }
    
    // Fun√ß√£o para extrair nome da cidade de um endere√ßo
    function extractCityName(addressOrName) {
        if (!addressOrName) return 'Desconhecido';
        
        // Lista de casos especiais que precisam de tratamento espec√≠fico
        const specialCases = {
            "taquarivai-eliana": "Taquariva√≠",
            "taquarivai": "Taquariva√≠",
            "oliveira ferreira": "Taquariva√≠", // Caso espec√≠fico relatado
            "ribeirao branco": "Ribeir√£o Branco",
            "ribeira": "Ribeir√£o Branco", // Caso espec√≠fico relatado
            "ribeir√£o branco-kelly": "Ribeir√£o Branco", // Caso espec√≠fico relatado
            "ribeirao branco-kelly": "Ribeir√£o Branco", // Caso espec√≠fico relatado
            "branco-kelly": "Ribeir√£o Branco", // Para evitar detec√ß√£o errada
            "cristina fernandes": "Ribeir√£o Branco", // Para evitar detec√ß√£o errada
            "buri": "Buri"
        };
        
        // Verificar casos especiais primeiro
        const lowerName = addressOrName.toLowerCase();
        for (const [pattern, city] of Object.entries(specialCases)) {
            if (lowerName.includes(pattern)) {
                return city;
            }
        }
        
        // Tentar extrair cidade de endere√ßo completo
        const cityFromAddress = extractCityFromAddress(addressOrName);
        if (cityFromAddress) return cityFromAddress;
        
        // Lista de cidades conhecidas para reconhecimento direto
        const knownCities = [
            "Dois C√≥rregos", "Ja√∫", "Botucatu", "Bauru", "Ribeir√£o Preto", 
            "S√£o Paulo", "Campinas", "S√£o Carlos", "Piracicaba", "Araraquara",
            "Americana", "Sorocaba", "Limeira", "Rio Claro", "Len√ß√≥is Paulista",
            "Taquariva√≠", "Ribeir√£o Branco", "Buri"
        ];
        
        // Verificar se o nome j√° cont√©m uma cidade conhecida
        for (const city of knownCities) {
            if (addressOrName.includes(city)) {
                return city;
            }
        }
        
        // Se chegamos at√© aqui, retornar o nome como est√°
        return addressOrName;
    }
    
    // Inicializa o mapa
    function initMap() {
        // Definir valores iniciais aos campos de data
        initDatePickers();
        
        // Invocar a filtragem de eventos inicial para exibir eventos para a origem
        filterEventsByDate();
        
        // Inicializar os contadores de regi√£o com base nos locais existentes (origem)
        refreshRegionCounters();
    }
    
    // Fun√ß√£o centralizada para inicializar os campos de data
    function initDatePickers() {
        try {
            console.log("Inicializando campos de data...");
            
            // Verificar se os campos existem
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            
            if (!startDateInput || !endDateInput) {
                console.error("Campos de data n√£o encontrados. Tentando encontrar container...");
                
                // Tentar criar os campos se n√£o existirem
                const dateContainer = document.querySelector('.date-filters');
                if (dateContainer) {
                    if (!startDateInput) {
                        const newStart = document.createElement('input');
                        newStart.type = 'date';
                        newStart.id = 'start-date';
                        newStart.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newStart);
                        console.log("Campo de data inicial criado");
                    }
                    
                    if (!endDateInput) {
                        const newEnd = document.createElement('input');
                        newEnd.type = 'date';
                        newEnd.id = 'end-date';
                        newEnd.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newEnd);
                        console.log("Campo de data final criado");
                    }
                } else {
                    console.error("Container de datas n√£o encontrado!");
                    return;
                }
            }
            
            // Referenciar os elementos (originais ou rec√©m-criados)
            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');
            
            // Verificar novamente
            if (!startDate || !endDate) {
                console.error("Imposs√≠vel criar ou localizar campos de data");
                return;
            }
            
            // Inicializar com a data atual e data atual + 7 dias
            const today = new Date();
            const formattedToday = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
            
            // Calcular a data final (hoje + 7 dias)
            const futureDate = new Date();
            futureDate.setDate(today.getDate() + 7);
            const formattedFuture = futureDate.toISOString().split('T')[0];
            
            // Definir os valores apenas se estiverem vazios
            if (!startDate.value) {
                startDate.value = formattedToday;
                console.log("Data inicial definida:", formattedToday);
            }
            
            if (!endDate.value) {
                endDate.value = formattedFuture;
                console.log("Data final definida:", formattedFuture);
            }
            
            console.log(`Datas inicializadas: de ${startDate.value} at√© ${endDate.value}`);
            
            // Adicionar listeners para atualizar os eventos quando as datas mudarem
            startDate.addEventListener('change', function() {
                console.log("Data de in√≠cio alterada para:", this.value);
                filterEventsByDate();
            });
            
            endDate.addEventListener('change', function() {
                console.log("Data de fim alterada para:", this.value);
                filterEventsByDate();
            });
            
            // Chamar o filtro de eventos inicialmente para aplicar as datas padr√£o
            setTimeout(filterEventsByDate, 500);
        } catch (error) {
            console.error("Erro ao inicializar seletores de data:", error);
        }
        
        // Ajustar a altura do container e do mapa para preencher todo o espa√ßo dispon√≠vel
        function resizeMap() {
            const mapContainer = document.querySelector('.map-container');
            const mapElement = document.getElementById('map');
            
            if (mapContainer && mapElement) {
                console.log('Redimensionando mapa');
                
                // N√£o precisamos mais definir estilos aqui pois os estilos CSS
                // j√° est√£o corretos e posicionados adequadamente
                
                // Apenas for√ßar o redimensionamento do mapa
                if (typeof google !== 'undefined' && google.maps && map) {
                    google.maps.event.trigger(map, 'resize');
                }
            } else {
                console.warn('Container do mapa ou elemento do mapa n√£o encontrados');
            }
        }
        
        // Op√ß√µes do mapa
        const mapOptions = {
            center: { lat: -22.3673, lng: -48.3822 }, // Dois C√≥rregos
            zoom: 8,
            mapTypeControl: true,
            fullscreenControl: true,
            fullscreenControlOptions: {
                position: google.maps.ControlPosition.RIGHT_TOP
            },
            streetViewControl: true,
            zoomControl: true,
            gestureHandling: 'greedy' // Permite zoom com scroll sem precionar Ctrl
        };
        
        // Criar o mapa
        map = new google.maps.Map(document.getElementById("map"), mapOptions);
        
        // Redimensionar o mapa agora e quando a janela for redimensionada
        resizeMap();
        window.addEventListener('resize', resizeMap);
        
        // Adicionar controle personalizado para os bal√µes contadores
        const counterControlDiv = document.createElement('div');
        counterControlDiv.className = 'custom-map-control';
        counterControlDiv.title = 'Mostrar/esconder contadores regionais';
        counterControlDiv.innerHTML = '<button id="counter-toggle" class="map-control-button active" title="Esconder contadores regionais">üî¢</button>';
        map.controls[google.maps.ControlPosition.LEFT_TOP].push(counterControlDiv);
        
        // O bot√£o de legenda j√° existe como elemento fixo, n√£o precisamos adicionar outro
        // Removido controle duplicado de legenda
        
        // Inicializar o servi√ßo de dire√ß√µes
        directionsService = new google.maps.DirectionsService();
        
        try {
            console.log("Inicializando DirectionsRenderer...");
            directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true, // N√£o mostrar marcadores padr√£o do Google
                preserveViewport: true,
                polylineOptions: {
                    strokeColor: '#1976D2',
                    strokeOpacity: 0.7,
                    strokeWeight: 4
                }
            });
            directionsRenderer.setMap(map);
            directionsRendererInitialized = true;
            console.log("DirectionsRenderer inicializado com sucesso");
        } catch (err) {
            console.error("Erro ao inicializar DirectionsRenderer:", err);
            showNotification("Erro ao inicializar o sistema de rotas. Recarregue a p√°gina.", "danger");
        }
        
        // Criar o tooltip personalizado
        createCustomTooltip();
        
        // Adicionar legenda das regi√µes
        createRegionLegend();
    }

    // Controla a visibilidade dos marcadores de contagem
    let countMarkersVisible = true;
    
    // Fun√ß√£o para esconder/mostrar os marcadores de contagem
    function toggleCountMarkers() {
        countMarkersVisible = !countMarkersVisible;
        
        // Atualizar todos os marcadores de contagem
        for (const key in regionCounterMarkers) {
            if (regionCounterMarkers[key]) {
                regionCounterMarkers[key].setVisible(countMarkersVisible);
            }
        }
        
        // Atualizar apar√™ncia do bot√£o - buscando todos os elementos que podem ser o bot√£o de contador
        const counterToggleBtns = [
            document.getElementById('counter-toggle'),
            document.querySelector('button[id="counter-toggle"]'),
            ...Array.from(document.querySelectorAll('[title*="contadores regionais"]'))
        ].filter(Boolean); // Remove null/undefined
        
        // Atualizar todos os bot√µes encontrados
        counterToggleBtns.forEach(btn => {
            if (countMarkersVisible) {
                btn.classList.add('active');
                btn.title = 'Esconder contadores regionais';
            } else {
                btn.classList.remove('active');
                btn.title = 'Mostrar contadores regionais';
            }
        });
        
        console.log("Estado dos contadores regionais:", countMarkersVisible ? "Vis√≠veis" : "Ocultos");
    }
    
    // Verifica se a legenda j√° est√° vis√≠vel
    function isLegendVisible() {
        return document.querySelector('.region-legend') !== null;
    }

    // Cria e adiciona a legenda das regi√µes no mapa
    function createRegionLegend(estado = null) {
        // Pegar o bot√£o de toggle da legenda para atualizar seu estado visual
        const legendToggleBtn = document.getElementById('show-legend');
        
        // Verificar se j√° existe uma legenda
        if (isLegendVisible()) {
            // Se j√° existe, simplesmente remova-a (funcionamento como toggle)
            const existingLegend = document.querySelector('.region-legend');
            if (existingLegend) {
                if (existingLegend.parentNode) {
                    existingLegend.parentNode.removeChild(existingLegend);
                } else {
                    // Se n√£o tiver parentNode, simplesmente remova do DOM
                    existingLegend.remove();
                }
            }
            
            // Atualizar apar√™ncia do bot√£o quando a legenda √© fechada
            if (legendToggleBtn) {
                legendToggleBtn.classList.remove('active');
                legendToggleBtn.title = 'Mostrar legenda de regi√µes';
            }
            
            return;
        }
        
        // Atualizar apar√™ncia do bot√£o quando a legenda √© aberta
        if (legendToggleBtn) {
            legendToggleBtn.classList.add('active');
            legendToggleBtn.title = 'Esconder legenda de regi√µes';
        }
        
        // Criar elemento de legenda
        const legendDiv = document.createElement('div');
        legendDiv.className = 'region-legend';
        
        // Aplicar estilo b√°sico para a legenda
        legendDiv.style.backgroundColor = 'white';
        legendDiv.style.padding = '10px';
        legendDiv.style.borderRadius = '4px';
        legendDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
        legendDiv.style.width = '200px';
        legendDiv.style.fontSize = '12px';
        legendDiv.style.margin = '10px'; 
        legendDiv.style.position = 'relative';
        legendDiv.style.zIndex = '1000';
        
    // Agora usamos a constante CORES_SP definida no escopo global
    // Lista das regi√µes espec√≠ficas de S√£o Paulo (ordenadas alfabeticamente)
    const regioesSaoPaulo = Object.entries(CORES_SP).map(([nome, cor]) => ({ nome, cor }));
        
        // Agora usamos a constante CORES_MG definida no escopo global
        // Lista de cores espec√≠ficas para cada regi√£o de Minas Gerais (ordenadas alfabeticamente)
        const regioesMG = Object.entries(CORES_MG).map(([nome, cor]) => ({ nome, cor }));
        
        // Bot√£o de fechar
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '&times;';
        closeButton.style.position = 'absolute';
        closeButton.style.top = '5px';
        closeButton.style.right = '5px';
        closeButton.style.background = 'none';
        closeButton.style.border = 'none';
        closeButton.style.fontSize = '16px';
        closeButton.style.cursor = 'pointer';
        closeButton.style.padding = '0';
        closeButton.style.margin = '0';
        closeButton.onclick = function() {
            if (legendDiv.parentNode) {
                legendDiv.parentNode.removeChild(legendDiv);
            }
        };
        legendDiv.appendChild(closeButton);
        
        // T√≠tulo principal
        const titleElement = document.createElement('div');
        titleElement.textContent = 'Regi√µes de SP e MG';
        titleElement.style.fontWeight = 'bold';
        titleElement.style.marginBottom = '8px';
        titleElement.style.borderBottom = '1px solid #ccc';
        titleElement.style.paddingBottom = '5px';
        titleElement.style.paddingRight = '15px'; // Espa√ßo para o bot√£o de fechar
        legendDiv.appendChild(titleElement);
        
        // Container com rolagem para as regi√µes
        const scrollContainer = document.createElement('div');
        scrollContainer.style.maxHeight = '300px';
        scrollContainer.style.overflowY = 'auto';
        scrollContainer.style.paddingRight = '5px';
        
        // Adicionar S√£o Paulo
        const spTitleElement = document.createElement('div');
        spTitleElement.textContent = 'S√£o Paulo';
        spTitleElement.style.fontWeight = 'bold';
        spTitleElement.style.marginTop = '8px';
        spTitleElement.style.marginBottom = '4px';
        spTitleElement.style.color = '#d35400';
        scrollContainer.appendChild(spTitleElement);
        
        // Lista de regi√µes de SP
        regioesSaoPaulo.forEach(regiao => {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.marginBottom = '4px';
            item.style.paddingLeft = '5px';
            
            const colorBox = document.createElement('div');
            colorBox.style.width = '12px';
            colorBox.style.height = '12px';
            colorBox.style.backgroundColor = regiao.cor;
            colorBox.style.marginRight = '5px';
            colorBox.style.flexShrink = '0';
            
            const label = document.createElement('span');
            label.textContent = regiao.nome;
            label.style.whiteSpace = 'normal';
            
            item.appendChild(colorBox);
            item.appendChild(label);
            scrollContainer.appendChild(item);
        });
        
        // Separador
        const separator = document.createElement('hr');
        separator.style.margin = '10px 0';
        separator.style.border = '0';
        separator.style.borderTop = '1px solid #eee';
        scrollContainer.appendChild(separator);
        
        // Adicionar Minas Gerais
        const mgTitleElement = document.createElement('div');
        mgTitleElement.textContent = 'Minas Gerais';
        mgTitleElement.style.fontWeight = 'bold';
        mgTitleElement.style.marginTop = '8px';
        mgTitleElement.style.marginBottom = '4px';
        mgTitleElement.style.color = '#d35400';
        scrollContainer.appendChild(mgTitleElement);
        
        // Lista de regi√µes de MG
        regioesMG.forEach(regiao => {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.marginBottom = '4px';
            item.style.paddingLeft = '5px';
            
            const colorBox = document.createElement('div');
            colorBox.style.width = '12px';
            colorBox.style.height = '12px';
            colorBox.style.backgroundColor = regiao.cor;
            colorBox.style.marginRight = '5px';
            colorBox.style.flexShrink = '0';
            
            const label = document.createElement('span');
            label.textContent = regiao.nome;
            label.style.whiteSpace = 'normal';
            
            item.appendChild(colorBox);
            item.appendChild(label);
            scrollContainer.appendChild(item);
        });
        
        legendDiv.appendChild(scrollContainer);
        
        // Posicionar a legenda do lado esquerdo do mapa (invertido)
        legendDiv.style.backgroundColor = 'white';
        legendDiv.style.padding = '10px';
        legendDiv.style.borderRadius = '4px';
        legendDiv.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0px 2px 6px';
        legendDiv.style.width = '200px';
        legendDiv.style.fontSize = '12px';
        legendDiv.style.margin = '10px';
        legendDiv.style.position = 'absolute';
        legendDiv.style.zIndex = '1000';
        legendDiv.style.left = '50px'; // Lado esquerdo
        legendDiv.style.top = '50%'; // Centralizado verticalmente
        legendDiv.style.transform = 'translateY(-50%)'; // Centraliza√ß√£o precisa
        legendDiv.style.maxHeight = '80%';
        
        // Adicionar a legenda ao DOM
        document.querySelector('#map').appendChild(legendDiv);
    }
    
    // Inicializa o autocomplete
    function initAutocomplete() {
        console.log("Inicializando autocomplete para busca de endere√ßos...");
        const input = document.getElementById('location-search');
        
        if (!input) {
            console.error("Elemento de busca 'location-search' n√£o encontrado!");
            return;
        }
        
        // Verificar se a API do Google j√° est√° carregada
        if (typeof google === 'undefined' || !google.maps || !google.maps.places) {
            console.error("API do Google Maps ou Places n√£o carregada corretamente");
            // Tentar novamente em alguns segundos
            setTimeout(initAutocomplete, 2000);
            return;
        }
        
        const options = {
            types: ['geocode'],
            componentRestrictions: { country: 'br' }
        };
        
        try {
            autocomplete = new google.maps.places.Autocomplete(input, options);
            console.log("Autocomplete inicializado com sucesso");
        } catch (error) {
            console.error("Erro ao inicializar autocomplete:", error);
        }
        
        // Quando um local √© selecionado no autocomplete
        if (autocomplete) {
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
            
            if (!place.geometry) {
                // Substituir alert por notifica√ß√£o inline mais suave
                const notifyWarning = document.createElement('div');
                notifyWarning.className = 'alert alert-warning mt-2';
                notifyWarning.innerHTML = `N√£o foi poss√≠vel encontrar o endere√ßo selecionado.`;
                const locationForm = document.querySelector('#location-form');
                if (locationForm) {
                    locationForm.appendChild(notifyWarning);
                } else {
                    console.warn('Elemento #location-form n√£o encontrado para anexar notifica√ß√£o');
                }
                
                // Remover a notifica√ß√£o ap√≥s alguns segundos
                setTimeout(() => {
                    if (notifyWarning && notifyWarning.parentNode) {
                        notifyWarning.parentNode.removeChild(notifyWarning);
                    }
                }, 5000);
                return;
            }
            
            // Adicionar o local √† lista
            const newLocation = {
                id: locationId++,
                name: formatLocationName(place.name),
                address: formatLocationName(place.formatted_address),
                zipCode: getZipCodeFromPlace(place),
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                isOrigin: false
            };
            
            locations.push(newLocation);
            
            // Adicionar marcador e atualizar a lista
            addMarkerForLocation(newLocation, locations.length - 1);
            
            // Atualizar os contadores de regi√£o
            refreshRegionCounters();
            updateLocationsList();
            
            // Limpar o campo de busca
            input.value = '';
        });
        }
    }

    // Inicializa a navega√ß√£o por abas (novas abas inferiores)
    function initTabNavigation() {
        // Inicializar abas inferiores (abaixo do mapa)
        const bottomTabButtons = document.querySelectorAll('.bottom-tab-btn');
        const bottomTabContents = document.querySelectorAll('.bottom-tab-content');
        
        // Verificar se estamos no GitHub Pages (para aplicar anima√ß√µes avan√ßadas)
        const isGitHubPages = window.location.href.includes('github.io');
        
        if (bottomTabButtons.length > 0) {
            console.log("Inicializando sistema de navega√ß√£o para tabs inferiores");
            
            bottomTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    console.log("Tab inferior clicada:", tabId);
                    
                    // Verificar se j√° √© o bot√£o ativo e se o painel est√° expandido
                    const isCurrentlyActive = button.classList.contains('active');
                    const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
                    const isExpanded = bottomTabsContainer && !bottomTabsContainer.classList.contains('minimized');
                    
                    // Se clicar no mesmo bot√£o que j√° est√° ativo e o painel estiver expandido, minimiza
                    if (isCurrentlyActive && isExpanded) {
                        toggleTabsExpansion(); // Minimizar o painel
                        return; // N√£o muda o conte√∫do, apenas minimiza
                    }
                    
                    // Se o painel estiver minimizado, expande ao clicar em qualquer bot√£o
                    if (bottomTabsContainer && bottomTabsContainer.classList.contains('minimized')) {
                        toggleTabsExpansion(); // Expandir o painel
                    }
                    
                    // Desativar todas as abas inferiores
                    bottomTabButtons.forEach(btn => btn.classList.remove('active'));
                    bottomTabContents.forEach(content => content.classList.remove('active'));
                    
                    // Ativar a aba inferior clicada
                    button.classList.add('active');
                    
                    // Mapear o data-tab para o ID do conte√∫do correto
                    const contentMap = {
                        'bottom-events': 'bottom-events-content',
                        'bottom-restrictions': 'bottom-restrictions-content',
                        'bottom-report': 'bottom-report-content'
                    };
                    
                    const contentId = contentMap[tabId];
                    if (contentId) {
                        const contentElement = document.getElementById(contentId);
                        if (contentElement) {
                            // Ocultar TODOS os conte√∫dos primeiro
                            bottomTabContents.forEach(content => {
                                content.style.display = 'none';
                                content.classList.remove('active');
                            });
                            
                            // Ativar apenas o conte√∫do da aba clicada
                            contentElement.classList.add('active');
                            contentElement.style.display = 'flex';
                            
                            // Efeitos visuais adicionais para GitHub Pages
                            if (isGitHubPages) {
                                // Reset da anima√ß√£o
                                contentElement.style.animation = 'none';
                                setTimeout(() => {
                                    contentElement.style.animation = 'fadeInUp 0.5s ease forwards';
                                }, 10);
                                
                                // N√£o fazer scroll autom√°tico - removido para evitar expans√£o autom√°tica
                            }
                        } else {
                            console.warn(`Elemento de conte√∫do #${contentId} n√£o encontrado`);
                        }
                    }
                });
            });
        } else {
            console.warn("Bot√µes de tab inferiores n√£o encontrados. Abas n√£o inicializadas.");
        }
    }

    // Fun√ß√£o para gerenciar a visibilidade das abas inferiores
    function toggleBottomTabsVisibility(show = true) {
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        if (bottomTabsContainer) {
            if (show) {
                // Garante que o container est√° vis√≠vel 
                bottomTabsContainer.style.removeProperty('display');
                bottomTabsContainer.style.display = 'flex';
                
                // Remover a classe minimizada para mostrar o conte√∫do completo
                bottomTabsContainer.classList.remove('minimized');
                
                // Atualizar o texto do bot√£o de toggle
                const toggleIcon = document.getElementById('toggle-icon');
                if (toggleIcon) {
                    toggleIcon.textContent = '‚ñº Minimizar';
                }
                
                console.log("Abas inferiores expandidas com sucesso");
                
                // Mostrar informa√ß√µes iniciais relevantes (origem)
                showInitialTabsContent();
            } else {
                // Apenas minimiza, sem ocultar completamente
                bottomTabsContainer.classList.add('minimized');
                
                // Atualizar o texto do bot√£o de toggle
                const toggleIcon = document.getElementById('toggle-icon');
                if (toggleIcon) {
                    toggleIcon.textContent = '‚ñ≤ Expandir';
                }
                
                console.log("Abas inferiores minimizadas com sucesso");
            }
        } else {
            console.warn("Container de abas inferiores n√£o encontrado!");
        }
    }
    
    // Fun√ß√£o para mostrar conte√∫do inicial relevante nas abas
    function showInitialTabsContent() {
        // Mostrar eventos da cidade de origem (Dois C√≥rregos)
        const routeIds = [mockData.origin.id];
        showEventsForCitiesOnRoute(routeIds);
        
        // Mostrar restri√ß√µes para a cidade de origem
        showTruckRestrictionsForCitiesOnRoute(routeIds, null);
        
        // Mostrar mensagem no relat√≥rio
        const reportContent = document.getElementById('bottom-report-content');
        if (reportContent) {
            const routeSummary = document.getElementById('route-summary');
            if (routeSummary) {
                routeSummary.innerHTML = `
                    <p>Adicione destinos e otimize uma rota para ver o relat√≥rio detalhado.</p>
                    <p>Origem atual: <strong>Dois C√≥rregos-SP</strong></p>
                `;
            }
        }
    }
    
    // Fun√ß√£o para expandir/colapsar as abas inferiores
    function toggleTabsExpansion() {
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        const toggleIcon = document.getElementById('toggle-icon');
        const mapContainer = document.querySelector('.map-container');
        
        if (bottomTabsContainer) {
            if (bottomTabsContainer.classList.contains('minimized')) {
                // Expandir
                bottomTabsContainer.classList.remove('minimized');
                if (toggleIcon) toggleIcon.textContent = '‚ñº Minimizar';
                
                // Ajustar altura do mapa quando as abas est√£o expandidas
                if (mapContainer) {
                    // Ajustar a altura do container do mapa para considerar o tamanho expandido das abas
                    const tabsHeight = bottomTabsContainer.offsetHeight;
                    mapContainer.style.bottom = tabsHeight + 'px';
                    
                    // For√ßar redesenho do mapa
                    if (typeof google !== 'undefined' && google.maps && map) {
                        setTimeout(() => {
                            google.maps.event.trigger(map, 'resize');
                            console.log("Mapa redimensionado ap√≥s expandir abas, altura das abas:", tabsHeight);
                        }, 100);
                    }
                }
            } else {
                // Minimizar
                bottomTabsContainer.classList.add('minimized');
                if (toggleIcon) toggleIcon.textContent = '‚ñ≤ Expandir';
                
                // Restaurar altura original do mapa quando as abas est√£o minimizadas
                if (mapContainer) {
                    mapContainer.style.bottom = '60px'; // Altura das abas minimizadas
                    
                    // For√ßar redesenho do mapa
                    if (typeof google !== 'undefined' && google.maps && map) {
                        setTimeout(() => {
                            google.maps.event.trigger(map, 'resize');
                            console.log("Mapa redimensionado ap√≥s minimizar abas");
                        }, 100);
                    }
                }
            }
        }
    }
    
    // Configura todos os event listeners
    function initEventListeners() {
        // Toggle para mostrar/esconder a sidebar removido
        
        // Adicionamos os event listeners para os bot√µes somente depois que o mapa estiver carregado
        // Defer a adi√ß√£o dos listeners para garantir que os elementos existam
        setTimeout(function() {
            // Bot√£o para alternar a visibilidade dos contadores de regi√£o
            // Tentamos encontrar por ID, seletor e atributo
            const counterToggleBtns = [
                document.getElementById('counter-toggle'),
                document.querySelector('button[id="counter-toggle"]'),
                ...Array.from(document.querySelectorAll('[title*="contadores regionais"]'))
            ].filter(Boolean); // Remove null/undefined
            
            console.log("Bot√µes de contador encontrados:", counterToggleBtns.length);
            
            // Adicionar evento a todos os bot√µes encontrados
            counterToggleBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    toggleCountMarkers();
                    console.log("Bot√£o de contador clicado, estado atual:", countMarkersVisible ? "Vis√≠vel" : "Oculto");
                });
                console.log("Evento de clique adicionado ao bot√£o de contador");
            });
            
            // Bot√£o para alternar a legenda de regi√µes (usando o novo ID show-legend)
            const showLegendBtn = document.getElementById('show-legend');
            if (showLegendBtn) {
                // Mantendo o evento - mesmo que j√° exista um onclick no HTML, para garantir
                showLegendBtn.addEventListener('click', function() {
                    createRegionLegend();
                });
            }
        }, 1000); // Esperamos 1 segundo para garantir que a p√°gina esteja carregada
        
        // Sidebar sempre vis√≠vel (bot√£o de fechar removido)
        
        // Upload de arquivo √© gerenciado pelo unified-file-upload.js
        // C√≥digo antigo desativado para evitar conflitos
        /* C√ìDIGO DESATIVADO 
        const fileUploadInput = document.getElementById('file-upload');
        const uploadArea = document.getElementById('upload-area');
        
        // Evento para quando o arquivo √© selecionado pelo input
        fileUploadInput.addEventListener('change', handleFileUpload);
        */
        
        // Eventos de drag and drop - DESATIVADO - Gerenciado pelo unified-file-upload.js
        /* C√ìDIGO DESATIVADO
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Adicionar classe visual quando o arquivo est√° sendo arrastado sobre a √°rea
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.add('dragover');
            }, false);
        });
        
        // Remover classe visual quando o arquivo sai da √°rea ou √© solto
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => {
                uploadArea.classList.remove('dragover');
            }, false);
        });
        
        // Processar o arquivo quando for solto na √°rea
        uploadArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length) {
                fileUploadInput.files = files;
                handleFileUpload({target: fileUploadInput});
            }
        }, false);
        */
        
        // Bot√£o para otimizar rota
        const optimizeButton = document.getElementById('optimize-route');
        if (optimizeButton) {
            optimizeButton.addEventListener('click', optimizeRoute);
        } else {
            console.error("Bot√£o de otimiza√ß√£o de rota n√£o encontrado!");
        }
        
        // Filtrar eventos automaticamente ao mudar as datas
        document.getElementById('start-date').addEventListener('change', filterEventsByDate);
        document.getElementById('end-date').addEventListener('change', filterEventsByDate);
        
        // Bot√µes de controle do mapa
        // Event listener para bot√£o de zoom removido
        document.getElementById('toggle-poi').addEventListener('click', togglePointsOfInterest);
        
        // Bot√£o para mostrar a legenda unificada
        document.getElementById('show-legend').addEventListener('click', function() {
            createRegionLegend();
        });
        
        // Bot√µes da aba de relat√≥rio
        document.getElementById('save-route').addEventListener('click', saveRoute);
        document.getElementById('print-route').addEventListener('click', printRoute);
        
        // Inicializar os cards de rotas alternativas
        function initRouteOptionCards() {
            // Evento para clique nos cards de rota alternativa
            const routeCards = document.querySelectorAll('.route-option-card');
            routeCards.forEach(card => {
                card.addEventListener('click', function() {
                    const routeIndex = parseInt(this.getAttribute('data-route'));
                    
                    // Atualizar sele√ß√£o visual
                    document.querySelectorAll('.route-option-card').forEach(c => {
                        c.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    
                    // Atualizar o select escondido (para compatibilidade)
                    const selectElement = document.getElementById('alternative-routes-sidebar');
                    selectElement.value = routeIndex;
                    
                    // Disparar evento de mudan√ßa para acionar o manipulador existente
                    const event = new Event('change');
                    selectElement.dispatchEvent(event);
                });
            });
        }
        
        // Chamar inicializa√ß√£o ap√≥s carregar o DOM
        initRouteOptionCards();
        
        // Esta fun√ß√£o foi movida para a se√ß√£o global para resolver o erro de refer√™ncia
        
        // Seletor de rotas alternativas na sidebar (mantido para compatibilidade)
        document.getElementById('alternative-routes-sidebar').addEventListener('change', function(e) {
            const selectedIndex = parseInt(e.target.value);
            if (alternativeRoutes && alternativeRoutes.length > selectedIndex) {
                const selectedRoute = alternativeRoutes[selectedIndex];
                
                console.log("Selecionando rota alternativa:", selectedIndex);
                console.log("Caminho da rota selecionada:", selectedRoute.path);
                
                // Informar sobre a troca de rota
                console.log("Alternando para rota: " + selectedIndex + ", reconstruindo elementos...");
                showNotification("Alternando para rota " + (selectedIndex + 1) + "...", "info");
                
                // Salvar o caminho selecionado para uso ap√≥s a limpeza
                const pathToUse = selectedRoute.path;
                
                // Parar qualquer anima√ß√£o em andamento
                if (routeAnimationTimeout) {
                    clearTimeout(routeAnimationTimeout);
                    routeAnimationTimeout = null;
                }
                
                // Limpar TUDO - todas as rotas, marcadores, eventos, e estado
                clearRoute();
                clearAllPolylines();
                clearPOIMarkers();
                clearEventMarkers();
                
                // Resetar o mapa para for√ßar atualiza√ß√£o
                if (map) {
                    try {
                        const mapCenter = map.getCenter();
                        map.setCenter(mapCenter);
                    } catch (e) {
                        console.error("Erro ao recentrar mapa:", e);
                    }
                }
                
                // Delay maior para garantir limpeza completa antes de reconstruir
                setTimeout(() => {
                    console.log("Reconstruindo a rota...");
                    
                    // Resetar DirectionsRenderer para garantir um estado limpo
                    if (directionsRenderer) {
                        try {
                            directionsRenderer.setMap(null);
                            directionsRenderer = new google.maps.DirectionsRenderer({
                                suppressMarkers: true,
                                preserveViewport: true,
                                polylineOptions: {
                                    strokeColor: '#1976D2',
                                    strokeOpacity: 0.7,
                                    strokeWeight: 4
                                }
                            });
                            directionsRenderer.setMap(map);
                            directionsRenderer.setDirections({routes: []});
                        } catch (e) {
                            console.error("Erro ao resetar directionsRenderer:", e);
                        }
                    }
                    
                    // Reordenar marcadores
                    reorderMarkers(pathToUse);
                    
                    // Desenhar nova rota com delay adicional para garantir que o mapa est√° pronto
                    setTimeout(() => {
                        console.log("Desenhando nova rota: ", selectedIndex);
                        
                        // Atualizar √≠ndice atual de rota
                        currentRouteIndex = selectedIndex;
                        currentDisplayedRoute = pathToUse;
                        
                        // Desenhar nova rota
                        drawRouteOnMap(pathToUse, "truck1");
                        
                        // Mostrar pontos de interesse e eventos somente ap√≥s desenhar a rota
                        setTimeout(() => {
                            showPointsOfInterestOnRoute(pathToUse);
                            showEventsForCitiesOnRoute(pathToUse);
                            
                            // Atualizar o relat√≥rio da rota para a alternativa selecionada
                            updateRouteSummary(selectedRoute, "truck1", selectedIndex);
                        }, 200);
                    }, 200);
                }, 400);
                
                // Atualizar restri√ß√µes
                showTruckRestrictionsForCitiesOnRoute(selectedRoute.path, null); // null para mostrar todos os tipos
                
                // Atualizar rota atual
                currentRouteIndex = selectedIndex;
            }
        });
    }

    // Fun√ß√£o para tratar o upload de arquivo - DESATIVADO - Gerenciado pelo unified-file-upload.js
    /* C√ìDIGO DESATIVADO
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Limpar qualquer status anterior de upload
        const fileUploadArea = document.getElementById('upload-area');
        if (fileUploadArea) {
            // Verificar se j√° existe um elemento de status e remov√™-lo
            const existingStatus = document.querySelector('.file-upload-status');
            if (existingStatus && existingStatus.parentNode) {
                existingStatus.parentNode.removeChild(existingStatus);
            }
            
            // Criar um novo elemento de status
            const statusElement = document.createElement('div');
            statusElement.className = 'file-upload-status';
            statusElement.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> Processando arquivo...';
            fileUploadArea.parentNode.appendChild(statusElement);
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            try {
                parseCEPFile(content);
                
                // Atualizar status para sucesso
                if (statusElement) {
                    statusElement.className = 'file-upload-status success';
                    statusElement.innerHTML = '<i class="fas fa-check-circle"></i> Arquivo processado com sucesso!';
                    
                    // Remover o status ap√≥s alguns segundos
                    setTimeout(() => {
                        if (statusElement && statusElement.parentNode) {
                            statusElement.parentNode.removeChild(statusElement);
                        }
                    }, 3000);
                }
            } catch (error) {
                console.error("Erro ao processar arquivo:", error);
                
                // Atualizar status para erro
                if (statusElement) {
                    statusElement.className = 'file-upload-status error';
                    statusElement.innerHTML = '<i class="fas fa-exclamation-circle"></i> Erro ao processar arquivo!';
                    
                    // Remover o status ap√≥s alguns segundos
                    setTimeout(() => {
                        if (statusElement && statusElement.parentNode) {
                            statusElement.parentNode.removeChild(statusElement);
                        }
                    }, 3000);
                }
            }
        };
        reader.readAsText(file);
    }
    */

    // Formatar texto para iniciar com mai√∫scula e resto min√∫scula
    function formatLocationName(name) {
        // Se o nome for vazio, retornar
        if (!name) return name;
        
        // Dividir o nome em palavras
        return name.split(' ').map(word => {
            if (!word) return '';
            // Primeira letra mai√∫scula, resto min√∫scula
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }).join(' ');
    }
    
    // Fun√ß√£o para processar o arquivo de CEPs
    function parseCEPFile(content) {
        // Verificar se content √© v√°lido
        if (!content || typeof content !== 'string') {
            console.error('Conte√∫do do arquivo inv√°lido:', content);
            throw new Error('Conte√∫do do arquivo inv√°lido');
        }
        
        const lines = content.split('\n');
        let newLocations = [];
        let invalidLines = 0;
        
        // CEPs com coordenadas conhecidas para as principais cidades paulistas
        const knownCEPs = {
            '14020-260': {name: 'Ribeir√£o Preto', lat: -21.1767, lng: -47.8208},
            '17560-000': {name: 'Vera Cruz', lat: -22.2205, lng: -49.8233},
            '17580-000': {name: 'Pomp√©ia', lat: -22.1075, lng: -50.1764},
            '17280-000': {name: 'Pederneiras', lat: -22.3518, lng: -48.7780},
            '17220-000': {name: 'Itapu√≠', lat: -22.2323, lng: -48.7186},
            '17340-000': {name: 'Barra Bonita', lat: -22.4910, lng: -48.5582},
            '17380-000': {name: 'Brotas', lat: -22.2794, lng: -48.1251},
            '17200-000': {name: 'Ja√∫', lat: -22.2936, lng: -48.5592},
            '18600-000': {name: 'Botucatu', lat: -22.8837, lng: -48.4437},
            '17120-000': {name: 'Agudos', lat: -22.4696, lng: -48.9870},
            '17210-000': {name: 'Igara√ßu do Tiet√™', lat: -22.5092, lng: -48.5597},
            '17040-001': {name: 'Bauru', lat: -22.3246, lng: -49.0871},
            '17400-000': {name: 'Gar√ßa', lat: -22.2132, lng: -49.6546},
            '17480-000': {name: 'Mar√≠lia', lat: -22.2171, lng: -49.9501},
            '17300-000': {name: 'Dois C√≥rregos', lat: -22.3673, lng: -48.3822},
            '18430-035': {name: 'Ribeir√£o Branco', lat: -24.2231, lng: -48.7635}, // Coordenadas corretas para Ribeir√£o Branco-SP
            '18435-000': {name: 'Ribeir√£o Branco', lat: -24.2231, lng: -48.7635}, // Mais um formato para Ribeir√£o Branco
            '18795-000': {name: 'Taquariva√≠', lat: -23.9215, lng: -48.6948} // Taquariva√≠
        };
        
        // Geocodificador para CEPs desconhecidos
        const geocoder = new google.maps.Geocoder();
        let geocodeQueue = [];
        
        for (const line of lines) {
            if (!line.trim()) {
                invalidLines++;
                continue;
            }
            
            const parts = line.split(',');
            if (parts.length < 2) {
                invalidLines++;
                continue;
            }
            
            const cep = parts[0].trim();
            let name = parts[1].trim();
            
            // Verificar se CEP e nome s√£o v√°lidos
            if (!cep || !name) {
                invalidLines++;
                continue;
            }
            
            // Formatar nome (primeira letra mai√∫scula, resto min√∫scula)
            name = formatLocationName(name);
            
            // Verificar casos especiais como Taquariva√≠-Eliana
            let modifiedName = name.toLowerCase();
            
            // Checar casos especiais para Ribeir√£o Branco e Taquariva√≠
            if (modifiedName.includes('ribeirao branco') || 
                modifiedName.includes('ribeir√£o branco')) {
                console.log("Detectado Ribeir√£o Branco no nome:", name);
                name = "Ribeir√£o Branco";
            } else if (modifiedName.includes('taquarivai') || 
                      modifiedName.includes('taquariva√≠')) {
                console.log("Detectado Taquariva√≠ no nome:", name);
                name = "Taquariva√≠";
            } else if (modifiedName.includes('taquarivai-eliana') || 
                      modifiedName.includes('oliveira ferreira')) {
                console.log("Detectado Taquariva√≠-Eliana no nome:", name);
                name = "Taquariva√≠";
            } else if (modifiedName === 'tiete' || modifiedName === 'tiet√™') {
                console.log("Detectado Tiet√™ no nome:", name);
                name = "Tiet√™";
            }
            
            // Formatar CEP para garantir consist√™ncia no formato xxxxx-xxx
            const formattedCEP = formatCEP(cep);
            
            // Verificar se √© um CEP conhecido (tentando com o formato fornecido ou com formato padronizado)
            if (knownCEPs[cep] || knownCEPs[formattedCEP]) {
                // Usar o CEP que for encontrado no banco de dados
                const knownLocation = knownCEPs[cep] || knownCEPs[formattedCEP];
                const formattedCityName = formatLocationName(knownLocation.name);
                
                // Log para depura√ß√£o
                console.log(`CEP ${cep} encontrado na base de dados: ${knownLocation.name}, coordenadas: ${knownLocation.lat}, ${knownLocation.lng}`);
                
                newLocations.push({
                    id: locationId++,
                    name: name,
                    address: `${name}, ${formattedCityName}, SP, Brasil`,
                    zipCode: cep,
                    latitude: knownLocation.lat,
                    longitude: knownLocation.lng,
                    isOrigin: false
                });
            } else {
                // Adicionar √† fila para geocodifica√ß√£o
                geocodeQueue.push({
                    cep: cep,
                    name: name // Nome j√° formatado
                });
            }
        }
        
        // Processar os CEPs conhecidos imediatamente
        if (newLocations.length > 0) {
            // Para cada novo local, adicionar √† lista e ao mapa
            newLocations.forEach((location) => {
                locations.push(location);
                addMarkerForLocation(location, locations.length - 1);
            });
            
            // Atualizar os contadores de regi√£o
            refreshRegionCounters();
            
            // Atualizar a lista de locais
            updateLocationsList();
            
            // Ajustar o zoom para mostrar todos os pontos com padding para melhor visualiza√ß√£o
            zoomToFitAllMarkers();
            
            console.log(`Processados ${newLocations.length} locais com sucesso.`);
        }
        
        // Processar a fila de geocodifica√ß√£o para CEPs desconhecidos
        if (geocodeQueue.length > 0) {
            // Adicionar uma notifica√ß√£o inline sobre o processo de geocodifica√ß√£o
            const fileUploadElement = document.querySelector('.file-upload');
            if (fileUploadElement) {
                const statusElement = document.createElement('div');
                statusElement.className = 'alert alert-info mt-3';
                statusElement.id = 'geocode-status';
                statusElement.innerHTML = `Processando ${geocodeQueue.length} endere√ßos adicionais...`;
                fileUploadElement.appendChild(statusElement);
            }
            
            let processedCount = 0;
            
            // Fun√ß√£o para processar a fila de geocodifica√ß√£o
            function processGeocodingQueue() {
                if (geocodeQueue.length === 0) {
                    // Todos os geocodes foram processados
                    const statusElement = document.getElementById('geocode-status');
                    if (statusElement && statusElement.parentNode) {
                        statusElement.parentNode.removeChild(statusElement);
                    }
                    return;
                }
                
                const item = geocodeQueue.shift();
                const address = `${item.cep}, Brasil`;
                
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const location = results[0].geometry.location;
                        
                        const newLocation = {
                            id: locationId++,
                            name: item.name, // J√° vem formatado de antes
                            address: `${item.name}, ${formatLocationName(address)}`,
                            zipCode: item.cep,
                            latitude: location.lat(),
                            longitude: location.lng(),
                            isOrigin: false
                        };
                        
                        locations.push(newLocation);
                        addMarkerForLocation(newLocation, locations.length - 1);
                        
                        // Atualizar os contadores de regi√£o
                        refreshRegionCounters();
                        
                        // Atualizar a lista de locais
                        updateLocationsList();
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Ajustar o zoom
                        zoomToFitAllMarkers();
                        
                        // Continuar com o pr√≥ximo ap√≥s um curto delay (para evitar limites de API)
                        setTimeout(processGeocodingQueue, 200);
                    } else {
                        // CORRE√á√ÉO: N√£o adicionar CEPs que n√£o puderam ser geocodificados
                        console.warn(`CEP n√£o encontrado: ${item.cep} - ${item.name}. Este local n√£o ser√° adicionado.`);
                        
                        // Mostrar notifica√ß√£o para o usu√°rio sobre o CEP n√£o encontrado
                        const notifyError = document.createElement('div');
                        notifyError.className = 'alert alert-warning mt-2';
                        notifyError.innerHTML = `CEP n√£o encontrado: ${item.cep} - ${item.name}`;
                        document.querySelector('.file-upload').appendChild(notifyError);
                        
                        // Remover a notifica√ß√£o ap√≥s alguns segundos
                        setTimeout(() => {
                            if (notifyError && notifyError.parentNode) {
                                notifyError.parentNode.removeChild(notifyError);
                            }
                        }, 5000);
                        
                        // Atualizar o status sem adicionar o local
                        
                        // Atualizar o status
                        processedCount++;
                        const statusElement = document.getElementById('geocode-status');
                        if (statusElement) {
                            statusElement.innerHTML = `Processando... ${processedCount}/${processedCount + geocodeQueue.length}`;
                        }
                        
                        // Continuar com o pr√≥ximo ap√≥s um curto delay
                        setTimeout(processGeocodingQueue, 200);
                    }
                });
            }
            
            // Iniciar o processamento da fila
            processGeocodingQueue();
        }
        
        // Limpar o campo de upload
        document.getElementById('file-upload').value = '';
        
        // Contar as linhas v√°lidas do arquivo original
        const validLines = lines.filter(line => {
            if (!line.trim()) return false;
            const parts = line.split(',');
            return parts.length >= 2 && parts[0].trim() && parts[1].trim();
        }).length;
        
        // Feedback para o usu√°rio com notifica√ß√£o mais moderna e sem alterar layout
        const uploadArea = document.getElementById('upload-area');
        
        // Salvar o conte√∫do original do componente de upload
        const originalContent = uploadArea.innerHTML;
        
        // Preservar dimens√µes originais
        const originalHeight = uploadArea.offsetHeight;
        const originalWidth = uploadArea.offsetWidth;
        
        // Guardar o estilo original para depois restaurar
        const originalStyle = {
            height: uploadArea.style.height,
            width: uploadArea.style.width,
            minHeight: uploadArea.style.minHeight
        };
        
        // Fixar as dimens√µes para evitar mudan√ßas no layout
        uploadArea.style.height = originalHeight + 'px';
        uploadArea.style.width = originalWidth + 'px';
        uploadArea.style.minHeight = originalHeight + 'px';
        
        // Substituir com a mensagem de sucesso
        uploadArea.innerHTML = `
            <div class="upload-success">
                <i class="fas fa-check-circle upload-success-icon"></i>
                <h5 class="mt-2">Arquivo processado com sucesso!</h5>
                <p class="upload-success-text">${validLines} ${validLines === 1 ? 'local adicionado' : 'locais adicionados'}</p>
            </div>
        `;
        
        // Adicionar classes para anima√ß√£o
        uploadArea.classList.add('success');
        
        // Restaurar o componente original ap√≥s alguns segundos
        setTimeout(() => {
            // Fade out
            uploadArea.classList.add('fading');
            
            setTimeout(() => {
                // Restaurar conte√∫do original e dimens√µes flex√≠veis
                uploadArea.innerHTML = originalContent;
                uploadArea.style.height = originalStyle.height;
                uploadArea.style.width = originalStyle.width;
                uploadArea.style.minHeight = originalStyle.minHeight;
                uploadArea.classList.remove('success', 'fading');
            }, 300);
        }, 2500);
    }

    // Fun√ß√£o para extrair CEP de um objeto Place
    function getZipCodeFromPlace(place) {
        if (!place.address_components) return "";
        
        for (let component of place.address_components) {
            if (component.types.includes('postal_code')) {
                return component.long_name;
            }
        }
        return "";
    }
    
    /**
     * Extrai o nome da cidade a partir de um endere√ßo completo
     * @param address Endere√ßo completo (ex: "R. Exemplo, 123 - Bairro, Cidade - UF, 12345-678, Brasil")
     * @returns Nome da cidade ou endere√ßo abreviado se n√£o for poss√≠vel extrair
     */
    function extractCityFromAddress(address) {
        if (!address) return "";
        
        // Tenta encontrar o padr√£o "Cidade - UF" no endere√ßo
        const cityStateMatch = address.match(/([^,]+) - ([A-Z]{2})/);
        if (cityStateMatch && cityStateMatch.length > 1) {
            const cityWithNeighborhood = cityStateMatch[1].trim();
            // Se tiver um tra√ßo antes do UF, pode conter bairro - pega s√≥ a cidade
            const parts = cityWithNeighborhood.split('-');
            return parts[parts.length - 1].trim();
        }
        
        // Tenta encontrar o padr√£o mais simples: nome antes de SP, RJ, MG, etc.
        const stateMatch = address.match(/([^,]+), ([A-Z]{2})/);
        if (stateMatch && stateMatch.length > 1) {
            return stateMatch[1].trim();
        }
        
        // Se o endere√ßo tem cidades conhecidas do estado de SP, retorna o nome da cidade
        const todasCidadesSP = Object.values(regioesSP).flatMap(r => r.cidades);
        for (const city of todasCidadesSP) {
            if (address.includes(city)) {
                return city;
            }
        }
        
        // Se n√£o conseguiu extrair um nome claro, retorna a primeira parte do endere√ßo
        return address.split(',')[0].trim();
    }
    
    // Fun√ß√£o para determinar a regi√£o de uma cidade e obter sua cor correspondente
    function getRegionColorForCity(cityName) {
        if (!cityName) return null;
        
        // Normalizar o nome da cidade (remover acentos, converter para min√∫sculas)
        const normalizedCityName = cityName.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        
        // Tratamento espec√≠fico para as cidades com classifica√ß√£o incorreta
        // Verificar de forma mais abrangente usando includes e v√°rias varia√ß√µes
        
        // Verificar diretamente se a cidade cont√©m "ribeirao branco" ou "ribeir√£o branco"
        if (normalizedCityName.includes('ribeirao branco') || 
            (normalizedCityName.includes('ribeirao') && normalizedCityName.includes('branco'))) {
            console.log('Classifica√ß√£o manual for√ßada: Ribeir√£o Branco pertence √† regi√£o de Sorocaba');
            updateRegionCounter("SP", "Sorocaba");
            return {
                regiao: "Sorocaba",
                cor: '#33A8FF', // Cor da regi√£o de Sorocaba (azul claro)
                estado: "SP"
            };
        } 
        
        // Verificar se √© Taquariva√≠ com v√°rias grafias poss√≠veis
        if (normalizedCityName.includes('taquarivai') || 
            normalizedCityName.includes('taquaritai') || 
            (normalizedCityName.includes('taquari') && normalizedCityName.includes('vai'))) {
            console.log('Classifica√ß√£o manual for√ßada: Taquariva√≠ pertence √† regi√£o de Sorocaba');
            updateRegionCounter("SP", "Sorocaba");
            return {
                regiao: "Sorocaba",
                cor: '#33A8FF', // Cor da regi√£o de Sorocaba (azul claro)
                estado: "SP"
            };
        } 
        
        // Verificar se √© Buri
        if (normalizedCityName.includes('buri')) {
            console.log('Classifica√ß√£o manual for√ßada: Buri pertence √† regi√£o de Sorocaba');
            updateRegionCounter("SP", "Sorocaba");
            return {
                regiao: "Sorocaba",
                cor: '#33A8FF', // Cor da regi√£o de Sorocaba (azul claro)
                estado: "SP"
            };
        }
        
        // Cores fixas para cada regi√£o de S√£o Paulo (conforme legendas)
        // Usar as mesmas cores da FONTE OFICIAL (CORES_SP definido na fun√ß√£o createRegionLegend)
        const coresPorRegiao = CORES_SP;
        
        // Usar as cores oficiais de Minas Gerais
        const coresMG = CORES_MG;
        
        // Verificar cada regi√£o
        for (const [regiao, dados] of Object.entries(regioesSP)) {
            // Verificar se a cidade est√° nesta regi√£o
            const cidadeEncontrada = dados.cidades.find(cidade => 
                cidade.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().includes(normalizedCityName) || 
                normalizedCityName.includes(cidade.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase())
            );
            
            if (cidadeEncontrada) {
                // Usar a cor da legenda para esta regi√£o
                const cor = coresPorRegiao[regiao] || dados.cor;
                console.log(`Cidade ${cityName} pertence √† regi√£o ${regiao} (cor: ${cor})`);
                
                // Incrementar contador desta regi√£o
                updateRegionCounter("SP", regiao);
                
                return {
                    regiao: regiao,
                    cor: cor,
                    estado: "SP"
                };
            }
        }
        
        // Verificar cada regi√£o de Minas Gerais
        for (const [regiao, dados] of Object.entries(regioesMG)) {
            // Verificar se a cidade est√° nesta regi√£o
            const cidadeEncontrada = dados.cidades.find(cidade => 
                cidade.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().includes(normalizedCityName) || 
                normalizedCityName.includes(cidade.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase())
            );
            
            if (cidadeEncontrada) {
                // Usar a cor da legenda para esta regi√£o
                const cor = coresMG[regiao] || dados.cor;
                console.log(`Cidade ${cityName} pertence √† regi√£o ${regiao} (cor: ${cor}) em MG`);
                
                // Incrementar contador desta regi√£o
                updateRegionCounter("MG", regiao);
                
                return {
                    regiao: regiao,
                    cor: cor,
                    estado: "MG"
                };
            }
        }
        
        // Se n√£o encontrar em nenhuma regi√£o, retornar valores padr√£o
        console.log(`Cidade ${cityName} n√£o encontrada em nenhuma regi√£o.`);
        return {
            regiao: "Desconhecida",
            cor: "#808080", // Cinza
            estado: "Desconhecido"
        };
    }
    
    // Fun√ß√µes para gerenciar os marcadores contadores de regi√£o
    
    // Atualiza a contagem para uma regi√£o espec√≠fica
    function updateRegionCounter(estado, regiao) {
        const regionKey = `${estado}-${regiao}`;
        
        // Inicializar contador se n√£o existir
        if (!regionCounts[regionKey]) {
            regionCounts[regionKey] = 0;
        }
        
        // Incrementar contador
        regionCounts[regionKey]++;
        
        // Atualizar ou criar o marcador de contagem
        updateRegionCounterMarker(estado, regiao);
    }
    
    // Fun√ß√£o para criar ou atualizar o marcador contador de uma regi√£o
    function updateRegionCounterMarker(estado, regiao) {
        const regionKey = `${estado}-${regiao}`;
        const count = regionCounts[regionKey] || 0;
        
        // Se n√£o houver locais nesta regi√£o, remover o marcador se existir
        if (count === 0) {
            if (regionCounterMarkers[regionKey]) {
                regionCounterMarkers[regionKey].setMap(null);
                delete regionCounterMarkers[regionKey];
            }
            return;
        }
        
        // Determinar o centro da regi√£o para posicionar o marcador
        const regionCenter = getRegionCenter(estado, regiao);
        if (!regionCenter) return;
        
        // Cor correspondente √† regi√£o - usando a FONTE OFICIAL DE CORES
        const regionColorMap = {
            'SP': CORES_SP,
            'MG': CORES_MG
        };
        
        // Tratamento especial para a regi√£o de Sorocaba
        let regionColor;
        if (estado === 'SP' && regiao === 'Sorocaba') {
            regionColor = '#33A8FF'; // Azul claro para Sorocaba, garantindo consist√™ncia
            console.log("Aplicando cor azul claro (#33A8FF) para contador de Sorocaba");
        } else {
            regionColor = regionColorMap[estado]?.[regiao] || "#808080";
        }
        
        // Se j√° existe um marcador, remov√™-lo e criar um novo
        if (regionCounterMarkers[regionKey]) {
            // Remover o marcador existente
            regionCounterMarkers[regionKey].setMap(null);
            
            // Se a contagem for zero, n√£o exibir o marcador
            if (count === 0) {
                delete regionCounterMarkers[regionKey];
                return;
            }
        } else if (count === 0) {
            // Se n√£o existe um marcador e a contagem √© zero, n√£o criar
            return;
        }
        
        // Criar novo elemento HTML para o marcador
        const markerContent = document.createElement('div');
        markerContent.className = 'region-counter-marker';
        markerContent.innerHTML = `<div>${count}</div>`;
        markerContent.style.backgroundColor = regionColor;
        
        // Usar marcador padr√£o em vez de AdvancedMarkerElement
        const counterMarker = new google.maps.Marker({
            position: regionCenter,
            map: map,
            title: `${regiao} (${estado}): ${count} locais`,
            label: {
                text: String(count),
                color: 'white',
                fontWeight: 'bold',
                fontSize: '12px',
                className: 'counter-marker-label'
            },
            icon: {
                path: 'M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z',
                fillColor: regionColor, // Usar a cor da regi√£o para o marcador de contagem
                fillOpacity: 0.9,
                strokeWeight: 1.5,
                strokeColor: '#ffffff',
                scale: 1.8,
                anchor: new google.maps.Point(0, 0),
                labelOrigin: new google.maps.Point(0, -15) // Posi√ß√£o do texto no centro da agulha
            },
            zIndex: 1000 // Para ficar acima dos outros marcadores
        });
        
        // Armazenar o marcador para futuras atualiza√ß√µes
        regionCounterMarkers[regionKey] = counterMarker;
    }
    
    // Fun√ß√£o para determinar o centro aproximado de uma regi√£o
    function getRegionCenter(estado, regiao) {
        // Centros predefinidos para cada regi√£o
        const regionCenters = {
            'SP': {
                'Ara√ßatuba': { lat: -21.2076, lng: -50.4401 },
                'Araraquara': { lat: -21.7845, lng: -48.1780 },
                'Bauru': { lat: -22.3147, lng: -49.0706 },
                'Campinas': { lat: -22.9099, lng: -47.0626 },
                'Mar√≠lia': { lat: -22.2171, lng: -49.9501 },
                'Presidente Prudente': { lat: -22.1208, lng: -51.3898 },
                'Ribeir√£o Preto': { lat: -21.1775, lng: -47.8103 },
                'S√£o Jos√© do Rio Preto': { lat: -20.8113, lng: -49.3758 },
                'S√£o Jos√© dos Campos': { lat: -23.1791, lng: -45.8872 },
                'S√£o Paulo': { lat: -23.5505, lng: -46.6333 },
                'Sorocaba': { lat: -23.5015, lng: -47.4590 }
            },
            'MG': {
                'Barbacena': { lat: -21.2255, lng: -43.7736 },
                'Belo Horizonte': { lat: -19.9227, lng: -43.9452 },
                'Divin√≥polis': { lat: -20.1446, lng: -44.8912 },
                'Governador Valadares': { lat: -18.8513, lng: -41.9550 },
                'Ipatinga': { lat: -19.4703, lng: -42.5322 },
                'Juiz de Fora': { lat: -21.7642, lng: -43.3496 },
                'Montes Claros': { lat: -16.7286, lng: -43.8578 },
                'Patos de Minas': { lat: -18.5872, lng: -46.5218 },
                'Pouso Alegre': { lat: -22.2266, lng: -45.9389 },
                'Te√≥filo Otoni': { lat: -17.8572, lng: -41.5064 },
                'Uberaba': { lat: -19.7472, lng: -47.9381 },
                'Uberl√¢ndia': { lat: -18.9128, lng: -48.2755 },
                'Varginha': { lat: -21.5514, lng: -45.4389 }
            }
        };
        
        return regionCenters[estado]?.[regiao];
    }
    
    // Fun√ß√£o para limpar todos os contadores de regi√£o
    function clearRegionCounters() {
        for (const key in regionCounterMarkers) {
            if (regionCounterMarkers[key]) {
                regionCounterMarkers[key].setMap(null);
            }
        }
        regionCounterMarkers = {};
        regionCounts = {};
    }
    
    // Fun√ß√£o para atualizar todos os contadores de regi√£o com base nos locais atuais
    function refreshRegionCounters() {
        // Limpar contadores existentes
        clearRegionCounters();
        
        // Percorrer todas as localiza√ß√µes atuais e contar por regi√£o
        // EXCLUINDO o ponto de origem (location.isOrigin)
        locations.forEach(location => {
            // Ignorar o ponto de origem no contador
            if (location.isOrigin === true) {
                return;
            }
            
            if (location.name && location.address) {
                // Extrair nome da cidade do endere√ßo
                const cityName = extractCityName(location.address);
                if (cityName) {
                    // Verificar a regi√£o da cidade
                    const regionInfo = getRegionColorForCity(cityName);
                    // A fun√ß√£o getRegionColorForCity j√° incrementa o contador
                }
            }
        });
        
        // Atualizar os marcadores de contagem para todas as regi√µes
        for (const regionKey in regionCounts) {
            const [estado, regiao] = regionKey.split('-');
            updateRegionCounterMarker(estado, regiao);
        }
    }

    // Adiciona um marcador no mapa para um local
    // targetArray permite especificar onde o marcador ser√° armazenado (para reordena√ß√£o segura)
    function addMarkerForLocation(location, index, targetArray = null) {
        // Verificar se o local j√° tem um marcador existente antes de criar um novo
        const existingMarker = markers.find(m => String(m.location.id) === String(location.id));
        
        if (existingMarker) {
            console.log(`Reutilizando marcador existente para ${location.name} (ID: ${location.id})`);
            // Atualizar apenas o n√∫mero de sequ√™ncia no marcador existente
            existingMarker.marker.setLabel({
                text: index === 0 ? 'O' : (index).toString(),
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            });
            existingMarker.marker.setMap(map); // Garantir que est√° vis√≠vel no mapa
            
            // Se for para adicionar a outro array, fazer isso
            if (targetArray) {
                targetArray.push(existingMarker);
            }
            
            return existingMarker;
        }
        
        // Caso n√£o exista marcador, criar um novo
        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id})`);
        
        // Verificar se est√° na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        const isSameCityAsOrigin = origin && isSameCity(location, origin);
        
        // √çcone personalizado com n√∫mero de sequ√™ncia
        const markerLabel = index === 0 ? 'O' : (index).toString();
        
        // Cor espec√≠fica com base na regi√£o da cidade
        let markerColor = '#1976D2'; // Cor padr√£o (azul)
        let infoRegiao = null;
        
        if (index === 0) {
            markerColor = '#FF0000'; // Origem sempre vermelho
        } else {
            // Determinar regi√£o e cor com base no nome da cidade
            // Para locais importados via arquivo, o nome pode conter a cidade no in√≠cio (ex: "Ribeirao Branco-nome do local")
            let cidadeDaLocalizacao;
            
            // Verificar se o nome do local come√ßa com uma cidade conhecida (formato de importa√ß√£o de arquivo)
            if (location.name) {
                // Verificar especificamente para Ribeir√£o Branco e Taquariva√≠
                if (location.name.toLowerCase().startsWith("ribeirao branco") || 
                    location.name.toLowerCase().includes("ribeirao branco-")) {
                    cidadeDaLocalizacao = "Ribeir√£o Branco";
                    console.log("Cidade detectada no nome do local:", cidadeDaLocalizacao);
                    
                    // For√ßar regi√£o de Sorocaba para Ribeir√£o Branco
                    infoRegiao = {
                        nome: "Sorocaba",
                        cor: "#33A8FF", // Azul claro para Sorocaba
                        estado: "SP"
                    };
                    console.log("Regi√£o for√ßada para Sorocaba para Ribeir√£o Branco");
                    markerColor = infoRegiao.cor;
                } 
                else if (location.name.toLowerCase().startsWith("taquarivai") || 
                         location.name.toLowerCase().includes("taquarivai-")) {
                    cidadeDaLocalizacao = "Taquariva√≠";
                    console.log("Cidade detectada no nome do local:", cidadeDaLocalizacao);
                    
                    // For√ßar regi√£o de Sorocaba para Taquariva√≠
                    infoRegiao = {
                        nome: "Sorocaba",
                        cor: "#33A8FF", // Azul claro para Sorocaba
                        estado: "SP"
                    };
                    console.log("Regi√£o for√ßada para Sorocaba para Taquariva√≠");
                    markerColor = infoRegiao.cor;
                }
                else if (location.name.toLowerCase().startsWith("buri") ||
                         location.name.toLowerCase().includes("buri-")) {
                    cidadeDaLocalizacao = "Buri";
                    console.log("Cidade detectada no nome do local:", cidadeDaLocalizacao);
                    
                    // For√ßar regi√£o de Sorocaba para Buri
                    infoRegiao = {
                        nome: "Sorocaba",
                        cor: "#33A8FF", // Azul claro para Sorocaba
                        estado: "SP"
                    };
                    console.log("Regi√£o for√ßada para Sorocaba para Buri");
                    markerColor = infoRegiao.cor;
                }
                else {
                    // M√©todo padr√£o para outros locais
                    cidadeDaLocalizacao = extractCityFromAddress(location.address) || location.name;
                }
            } else {
                cidadeDaLocalizacao = extractCityFromAddress(location.address) || "";
            }
            
            console.log(`Obtendo regi√£o para cidade: "${cidadeDaLocalizacao}"`);
            infoRegiao = getRegionColorForCity(cidadeDaLocalizacao);
            
            if (infoRegiao) {
                markerColor = infoRegiao.cor; // Usar a cor da regi√£o
            } else if (isSameCityAsOrigin) {
                markerColor = '#FF9800'; // Fallback para ponto na mesma cidade (laranja)
            }
        }
        
        // Verificar se deve animar o marcador (apenas pontos na mesma cidade)
        const animation = isSameCityAsOrigin && !location.isOrigin ? 
                         google.maps.Animation.BOUNCE : null;
        
        console.log(`Configurando marcador para ${location.name} - Mesma cidade da origem: ${isSameCityAsOrigin}`);
        
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: location.name,
            label: {
                text: markerLabel,
                color: 'white',
                fontSize: '14px',
                fontWeight: 'bold'
            },
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                fillColor: markerColor,
                fillOpacity: 1,
                strokeWeight: 0,
                scale: 12
            },
            animation: animation,
            zIndex: index === 0 ? 1000 : (isSameCityAsOrigin ? 500 : 100) // Ordem: Origem > Mesma cidade > Outros
        });
        
        // Obter informa√ß√µes regionais para mostrar no infowindow
        let regiaoInfo = '';
        const cidadeDaLocalizacao = extractCityFromAddress(location.address) || location.name;
        if (!location.isOrigin && cidadeDaLocalizacao) {
            const infoRegiao = getRegionColorForCity(cidadeDaLocalizacao);
            if (infoRegiao && infoRegiao.regiao !== "Desconhecida") {
                regiaoInfo = `
                    <p style="margin-bottom: 8px;">
                        <strong>Regi√£o:</strong> 
                        <span style="
                            color: white; 
                            background-color: ${infoRegiao.cor}; 
                            padding: 2px 6px; 
                            border-radius: 4px; 
                            font-weight: bold;
                            display: inline-block;
                            margin-left: 5px;
                        ">${infoRegiao.regiao}</span>
                    </p>`;
            }
        }
        
        // Infowindow com detalhes do local
        const infowindow = new google.maps.InfoWindow({
            content: `
                <div>
                    <h5>${location.name}</h5>
                    <p>${location.address}</p>
                    ${location.zipCode ? `<p>CEP: ${location.zipCode}</p>` : ''}
                    ${regiaoInfo}
                    ${!location.isOrigin ? `<button onclick="removeLocation('${location.id}')" class="btn btn-sm btn-danger">Remover</button>` : ''}
                </div>
            `
        });
        
        // Event listener para abrir o infowindow
        marker.addListener('click', function() {
            if (activeInfoWindow) {
                activeInfoWindow.close();
            }
            infowindow.open(map, marker);
            activeInfoWindow = infowindow;
            
            // Se o local estiver na mesma cidade da origem, destacar visualmente
            if (isSameCity(location, locations.find(loc => loc.isOrigin))) {
                marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(() => marker.setAnimation(null), 1500);
            }
        });
        
        // Criar objeto do marcador
        const markerObj = { marker, location, infowindow };
        
        // Armazenar o marcador na array principal ou na array alvo, se fornecida
        if (targetArray) {
            targetArray.push(markerObj);
        } else {
            markers.push(markerObj);
        }
        
        return markerObj;
    }

    // Atualiza a lista de locais no sidebar com base na ordem dos marcadores
    function updateLocationsList() {
        const container = document.getElementById('locations-list');
        if (!container) {
            console.error("Elemento 'locations-list' n√£o encontrado!");
            return;
        }
        container.innerHTML = '';
        
        // Extrair os locais n√£o-origem dos marcadores para preservar a ordem
        const orderedLocations = markers
            .map(m => m.location)
            .filter(loc => !loc.isOrigin);
        
        // Adicionar cada local √† lista na ordem dos marcadores
        orderedLocations.forEach((location, index) => {
            const locationItem = document.createElement('div');
            locationItem.className = 'location-item';
            locationItem.innerHTML = `
                <div>
                    <div><span class="badge bg-primary">${index + 1}</span> ${location.name}</div>
                    <div class="location-address">${location.address}</div>
                </div>
                <button class="btn btn-sm btn-danger" onclick="removeLocation('${location.id}')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                </button>
            `;
            container.appendChild(locationItem);
        });
    }

    // Remove um local da lista e do mapa
    function removeLocation(id) {
        console.log("Removendo localiza√ß√£o com ID:", id, "Tipo:", typeof id);
        
        // Converter para string para garantir consist√™ncia na compara√ß√£o
        const idStr = String(id);
        
        // Obter o local antes de remov√™-lo para saber a regi√£o
        const locationToRemove = locations.find(loc => String(loc.id) === idStr);
        if (locationToRemove) {
            console.log("Removendo local:", locationToRemove.name, locationToRemove.address);
        }
        
        // Remover o local da lista
        locations = locations.filter(loc => String(loc.id) !== idStr);
        
        // Remover o marcador do mapa - usar String para garantir compara√ß√£o consistente
        const markerIndex = markers.findIndex(m => String(m.location.id) === idStr);
        if (markerIndex !== -1) {
            console.log(`Marcador encontrado no √≠ndice ${markerIndex} e ser√° removido`);
            markers[markerIndex].marker.setMap(null);
            markers.splice(markerIndex, 1);
        } else {
            console.log(`Nenhum marcador encontrado para o ID ${idStr}`);
        }
        
        // Limpar e recalcular os contadores de regi√£o
        clearRegionCounters();
        
        // Atualizar a lista e reindexar os marcadores
        updateLocationsList();
        refreshRegionCounters();
        reindexMarkers();
        
        // Se houver uma rota atual, limp√°-la
        clearRoute();
    }

    // Reindexar os marcadores ap√≥s remo√ß√£o
    function reindexMarkers() {
        markers.forEach((markerObj, index) => {
            if (!markerObj.location.isOrigin) {
                markerObj.marker.setLabel({
                    text: index.toString(),
                    color: 'white',
                    fontSize: '14px',
                    fontWeight: 'bold'
                });
            }
        });
    }

    // Limpar rota atual e marcadores relacionados
    // Fun√ß√£o para limpar todas as polylines do mapa
    function clearAllPolylines() {
        console.log("Limpando todas as polylines do mapa...");
        
        // Limpar todas as polylines registradas
        if (allRoutePolylines.length > 0) {
            console.log(`Limpando ${allRoutePolylines.length} polylines registradas`);
            allRoutePolylines.forEach(polyline => {
                try {
                    if (polyline) polyline.setMap(null);
                } catch (e) {
                    console.error("Erro ao limpar polyline:", e);
                }
            });
            allRoutePolylines = [];
        }
        
        // Outras limpezas espec√≠ficas de polylines
        if (routePath) {
            try {
                routePath.setMap(null);
                routePath = null;
                console.log("Polyline principal removida");
            } catch (e) {
                console.error("Erro ao remover polyline principal:", e);
            }
        }
        
        // Reset do mapa como medida adicional
        try {
            if (map) {
                const mapCenter = map.getCenter();
                map.setCenter(mapCenter);
                console.log("Mapa recentrado para for√ßar atualiza√ß√£o");
            }
        } catch (e) {
            console.error("Erro ao recentrar mapa:", e);
        }
    }

    function clearRoute() {
        console.log("Limpando rota atual...");
        
        // Limpar o renderizador de dire√ß√µes
        if (directionsRendererInitialized && directionsRenderer) {
            try {
                // Limpar rotas existentes
                directionsRenderer.setDirections({ routes: [] });
                
                // Em alguns casos, pode ser necess√°rio recriar o renderer
                directionsRenderer.setMap(null);
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: true,
                    preserveViewport: true,
                    polylineOptions: {
                        strokeColor: '#1976D2',
                        strokeOpacity: 0.7,
                        strokeWeight: 4
                    }
                });
                directionsRenderer.setMap(map);
                console.log("DirectionsRenderer recriado com sucesso");
            } catch (err) {
                console.error("Erro ao limpar dire√ß√µes:", err);
            }
        } else {
            console.warn("directionsRenderer n√£o est√° dispon√≠vel ou n√£o inicializado");
        }
        
        // Limpar timeout de anima√ß√£o se existir
        if (routeAnimationTimeout) {
            clearTimeout(routeAnimationTimeout);
            routeAnimationTimeout = null;
            console.log("Anima√ß√£o de rota interrompida");
        }
        
        // Limpar todas as polylines
        clearAllPolylines();
        
        // Reset das vari√°veis de controle
        currentDisplayedRoute = null;
        
        // Limpar marcadores de POI
        clearPOIMarkers();
        
        // Limpar marcadores de eventos
        clearEventMarkers();
        
        // Resetar o resumo da rota - com verifica√ß√£o de seguran√ßa
        const routeSummary = document.getElementById('route-summary');
        if (routeSummary) {
            routeSummary.style.display = 'none';
        }
        document.getElementById('save-route').disabled = true;
        document.getElementById('print-route').disabled = true;
    }

    // Limpar marcadores de pontos de interesse
    function clearPOIMarkers() {
        poiMarkers.forEach(marker => marker.setMap(null));
        poiMarkers = [];
    }

    // Limpar marcadores de eventos
    function clearEventMarkers() {
        eventMarkers.forEach(marker => marker.setMap(null));
        eventMarkers = [];
    }

    // Otimizar a rota
    function optimizeRoute() {
        // Verificar se h√° pelo menos um destino al√©m da origem
        if (locations.length <= 1) {
            // Usar fun√ß√£o auxiliar para mostrar notifica√ß√£o
            showNotification('Adicione pelo menos um destino para calcular a rota.', 'warning', '.route-controls');
            // Esconder as abas inferiores se n√£o houver destinos
            toggleBottomTabsVisibility(false);
            return;
        }
        
        // Mostrar as abas inferiores quando houver destinos, mas mant√™-las minimizadas
        // Deixamos vis√≠vel mas n√£o expandimos automaticamente
        const bottomTabsContainer = document.querySelector('.bottom-tabs-container');
        if (bottomTabsContainer) {
            bottomTabsContainer.style.removeProperty('display');
            bottomTabsContainer.style.display = 'flex';
            // Mant√©m minimizado deliberadamente, o usu√°rio deve clicar para expandir
            bottomTabsContainer.classList.add('minimized');
        }
        
        // Mostrar spinner de carregamento centralizado no mapa
        showLoadingSpinner();
        
        // Mostrar loading no bot√£o tamb√©m
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = '<span class="spinner-border" role="status" aria-hidden="true"></span> Calculando...';
            optimizeBtn.disabled = true;
        }
        
        // IMPORTANTE: Assegurar que os marcadores originais sejam preservados antes de limpar
        const currentMarkers = [...markers]; // Criar uma c√≥pia dos marcadores atuais
        
        // Limpar rota anterior
        clearRoute();
        
        // Usar caminh√£o padr√£o como ve√≠culo
        const vehicleType = "truck1"; // Caminh√£o 1 eixo como padr√£o
        
        // Calcular a rota otimizada (vers√£o simplificada do TSP)
        calculateOptimizedRoute(vehicleType, false, currentMarkers);
    }

    // Calcular rota otimizada pelo algoritmo TSP
    function calculateOptimizedRoute(vehicleType, includeOriginReturn, savedMarkers = null) {
        try {
            console.log("==========================================");
            console.log("  INICIANDO C√ÅLCULO DE ROTA OTIMIZADA");
            console.log("==========================================");
            
            // Limpar rotas alternativas existentes
            alternativeRoutes = [];
            currentRouteIndex = 0;
            
            // Garantir que temos localiza√ß√µes v√°lidas
            if (!locations || !Array.isArray(locations) || locations.length === 0) {
                console.error("Nenhuma localiza√ß√£o dispon√≠vel");
                showNotification("Erro: Nenhuma localiza√ß√£o dispon√≠vel", "error");
                return;
            }
            
            // Encontrar origem e destinos
            const origin = locations.find(loc => loc.isOrigin);
            const destinations = locations.filter(loc => !loc.isOrigin);
            
            if (!origin) {
                console.error("Origem n√£o encontrada", locations);
                showNotification("Erro: N√£o foi poss√≠vel identificar uma origem", "error");
                return;
            }
            
            if (!destinations.length) {
                console.error("Nenhum destino encontrado", locations);
                showNotification("Adicione pelo menos um destino para calcular a rota", "warning");
                return;
            }
            
            // Validar coordenadas da origem
            if (!origin.latitude || !origin.longitude || isNaN(origin.latitude) || isNaN(origin.longitude)) {
                console.error("Origem com coordenadas inv√°lidas:", origin);
                origin.latitude = -22.3673; // Dois C√≥rregos
                origin.longitude = -48.3822;
                console.log("Corrigidas coordenadas da origem");
            }
            
            // Validar coordenadas dos destinos
            let allValid = true;
            for (let dest of destinations) {
                if (!dest.latitude || !dest.longitude || isNaN(dest.latitude) || isNaN(dest.longitude)) {
                    console.error("Destino com coordenadas inv√°lidas:", dest);
                    dest.latitude = -22.3673 + (Math.random() - 0.5) * 0.1; // Pr√≥ximo a Dois C√≥rregos
                    dest.longitude = -48.3822 + (Math.random() - 0.5) * 0.1;
                    console.log("Corrigidas coordenadas de destino", dest.name);
                    allValid = false;
                }
            }
            
            if (!allValid) {
                console.warn("Algumas coordenadas de destino foram corrigidas automaticamente");
            }
            
            // Calcular dist√¢ncia em linha reta (para verifica√ß√£o e garantia)
            let straightLineDistance = 0;
            try {
                for (let i = 0; i < destinations.length; i++) {
                    const dist = calculateDistance(
                        origin.latitude, origin.longitude,
                        destinations[i].latitude, destinations[i].longitude
                    );
                    straightLineDistance += dist;
                    console.log(`Dist√¢ncia de ${origin.name} para ${destinations[i].name}: ${dist.toFixed(1)} km`);
                }
                console.log("Dist√¢ncia total aproximada em linha reta:", straightLineDistance.toFixed(1), "km");
            } catch (distError) {
                console.error("Erro ao calcular dist√¢ncia em linha reta:", distError);
                straightLineDistance = destinations.length * 50; // Valor m√©dio seguro
                console.log("Usando dist√¢ncia segura:", straightLineDistance);
            }
            
            // Gerar rotas alternativas usando diferentes algoritmos
            generateAlternativeRoutes(origin, destinations, includeOriginReturn);
            
            // CRIAR UMA ROTA DE BACKUP CASO ALGO FALHE
            const backupRoute = {
                path: [origin, ...destinations],
                pathIds: [origin.id, ...destinations.map(d => d.id)],
                distance: Math.max(100, straightLineDistance * 1.3),
                time: calculateTravelTime(Math.max(100, straightLineDistance * 1.3)) // tempo usando fun√ß√£o centralizada
            };
            
            // Verificar se temos alternativas geradas
            if (!alternativeRoutes || !Array.isArray(alternativeRoutes) || alternativeRoutes.length === 0) {
                console.warn("Nenhuma rota alternativa dispon√≠vel. Usando rota de backup.");
                alternativeRoutes = [backupRoute];
            }
            
            // Processar todas as rotas alternativas para garantir consist√™ncia
            alternativeRoutes = postProcessTspResults(alternativeRoutes);
            console.log("Rotas alternativas ap√≥s processamento:", alternativeRoutes);
            
            // Usar a primeira rota como padr√£o
            let tspResult = alternativeRoutes[0];
            
            // Verificar se o resultado √© v√°lido
            if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path) || tspResult.path.length === 0) {
                console.warn("Resultado TSP inv√°lido. Usando rota de backup.", tspResult);
                tspResult = backupRoute;
                alternativeRoutes[0] = backupRoute;
            }
            
            // Garantir que temos pathIds para uso posterior
            if (!tspResult.pathIds || !Array.isArray(tspResult.pathIds)) {
                console.warn("Gerando pathIds para a rota");
                
                // Tentar extrair IDs dos objetos de localiza√ß√£o
                tspResult.pathIds = tspResult.path.map(item => {
                    // Se o item for um objeto com ID
                    if (typeof item === 'object' && item !== null && item.id !== undefined) {
                        return item.id;
                    }
                    // Se o item j√° for um ID
                    return item;
                });
                
                console.log("IDs de caminho gerados:", tspResult.pathIds);
            }
            
            // VERIFICAR E CORRIGIR DIST√ÇNCIA INV√ÅLIDA (PROBLEMA COMUM NO GITHUB PAGES)
            if (typeof tspResult.distance !== 'number' || isNaN(tspResult.distance) || tspResult.distance <= 0) {
                console.warn("CORRE√á√ÉO CR√çTICA: Dist√¢ncia TSP inv√°lida detectada:", tspResult.distance);
                
                // Estrat√©gia 1: Recalcular a dist√¢ncia baseada nas coordenadas dos pontos
                let recalculatedDistance = 0;
                try {
                    const pathPoints = tspResult.path || [];
                    
                    if (pathPoints.length > 1) {
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            const current = pathPoints[i];
                            const next = pathPoints[i + 1];
                            
                            if (current && next && 
                                current.latitude && current.longitude && 
                                next.latitude && next.longitude) {
                                const segmentDist = calculateDistance(
                                    current.latitude, current.longitude,
                                    next.latitude, next.longitude
                                );
                                recalculatedDistance += segmentDist;
                            }
                        }
                    }
                    
                    console.log("Dist√¢ncia recalculada:", recalculatedDistance);
                } catch (distError) {
                    console.error("Erro ao recalcular dist√¢ncia:", distError);
                }
                
                // Estrat√©gia 2: Se rec√°lculo falhar, usar a dist√¢ncia em linha reta com fator de corre√ß√£o
                if (recalculatedDistance <= 0) {
                    recalculatedDistance = destinations.length * 50; // Valor m√©dio seguro
                    
                    if (straightLineDistance > 0) {
                        // Fator de corre√ß√£o para compensar curvas das estradas
                        recalculatedDistance = straightLineDistance * 1.4;
                    }
                    
                    console.log("Usando dist√¢ncia aproximada:", recalculatedDistance);
                }
                
                // Definir nova dist√¢ncia com valor m√≠nimo garantido
                tspResult.distance = Math.max(recalculatedDistance, destinations.length * 20, 30);
                console.log("Dist√¢ncia final corrigida:", tspResult.distance.toFixed(1), "km");
                
                // Atualizar o tempo usando nossa fun√ß√£o centralizada
                tspResult.time = calculateTravelTime(tspResult.distance);
                console.log("Tempo atualizado:", tspResult.time.toFixed(1), "minutos");
            }
            
            // IMPORTANTE: M√©todo direto para processar a rota padr√£o 
            // em vez de usar o seletor que est√° causando problemas
            
            console.log("Tratando a rota padr√£o DIRETAMENTE (sem usar o event handler)...");
            
            // Salvar uma c√≥pia de quais locais temos antes de iniciar
            const locationsBeforeRoute = [...locations];
            console.log("Locais antes de processar rota:", locationsBeforeRoute.map(l => `${l.name} (ID: ${l.id})`));
            
            // Limpar as rotas no mapa, mas n√£o os marcadores
            if (directionsRenderer) {
                directionsRenderer.setMap(null);
            }
            
            // Criar um novo array para os marcadores reordenados
            const reorderedMarkers = [];
            
            // Verificar e corrigir poss√≠veis problemas com os IDs da rota
            const fixedPath = tspResult.path.map(locationId => {
                if (typeof locationId === 'object' && locationId !== null) {
                    // Se for um objeto, extrair o ID
                    return locationId.id || locationId;
                }
                return locationId;
            });
            
            // Substituir o caminho original pelo caminho com IDs corrigidos
            tspResult.path = fixedPath;
            
            console.log("Caminho da rota ap√≥s corre√ß√£o:", tspResult.path);
            
            // Processar a rota em ordem correta
            tspResult.path.forEach((locationId, index) => {
                // Garantir que o ID √© uma string para compara√ß√£o
                const locationIdStr = String(locationId);
                console.log(`Processando ID: ${locationIdStr}, tipo original: ${typeof locationId}, valor:`, locationId);
                
                const location = locations.find(loc => String(loc.id) === locationIdStr);
                
                if (!location) {
                    console.error(`Marcador n√£o encontrado para localiza√ß√£o ID: ${locationIdStr}`);
                    return;
                }
                
                console.log(`Processando ponto ${index} da rota: ${location.name} (ID: ${location.id})`);
                
                // Verificar se √© a origem para garantir que o n√∫mero de sequ√™ncia seja 0
                const markerIndex = location.isOrigin ? 0 : index;
                
                // Verificar se j√° existe um marcador para este local
                const existingMarkerObj = markers.find(m => String(m.location.id) === locationIdStr);
                
                if (existingMarkerObj) {
                    // Atualizar r√≥tulo do marcador com a nova sequ√™ncia
                    existingMarkerObj.marker.setLabel({
                        text: markerIndex === 0 ? 'O' : markerIndex.toString(),
                        color: 'white',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    });
                    
                    // Garantir que o marcador esteja vis√≠vel no mapa
                    existingMarkerObj.marker.setMap(map);
                    
                    // Adicionar √† lista de marcadores reordenados
                    reorderedMarkers.push(existingMarkerObj);
                } else {
                    // Se o marcador n√£o existir, criar um novo
                    const newMarkerObj = addMarkerForLocation(location, markerIndex, reorderedMarkers);
                    console.log(`Criado novo marcador para ${location.name} (ID: ${location.id})`);
                }
            });
            
            // Atualizar o array principal de marcadores com os reordenados
            if (reorderedMarkers.length > 0) {
                console.log(`Substituindo array de marcadores (${markers.length}) pelos reordenados (${reorderedMarkers.length})`);
                markers = [...reorderedMarkers];
            }
            
            // Verificar se temos localiza√ß√µes suficientes para desenhar a rota
            if (tspResult.path.length >= 2) {
                // Coletar localiza√ß√µes na ordem da rota para desenhar no mapa
                // Usamos os IDs j√° normalizados
                const pathLocations = [];
                
                // Adicionar cada localiza√ß√£o verificando antes
                tspResult.path.forEach(id => {
                    const idStr = String(id);
                    
                    // Verificar que n√£o √© um objeto antes de pesquisar
                    if (typeof id === 'object') {
                        console.log(`ID de tipo objeto encontrado: ${JSON.stringify(id)}`);
                        return; // pular este ID
                    }
                    
                    const location = locations.find(loc => String(loc.id) === idStr);
                    if (!location) {
                        console.error(`Localiza√ß√£o n√£o encontrada para ID: ${idStr} durante o desenho da rota`);
                    } else {
                        // S√≥ adicionar se encontrou a localiza√ß√£o
                        pathLocations.push(location);
                    }
                });
                
                // Desenhar a rota no mapa usando as dire√ß√µes do Google
                // Usamos drawRouteOnMap que √© a fun√ß√£o correta definida no c√≥digo
                const pathToUse = tspResult.pathIds || tspResult.path;
                drawRouteOnMap(pathToUse, vehicleType);
                
                // Mostrar pontos de interesse e eventos ao longo da rota
                showPointsOfInterestOnRoute(pathToUse);
                showEventsForCitiesOnRoute(pathToUse);
                showTruckRestrictionsForCitiesOnRoute(pathToUse, null); // null para mostrar todos os tipos
                
                // Atualizar a sequ√™ncia de rota no relat√≥rio
                // A fun√ß√£o n√£o existe, ent√£o implementamos diretamente aqui
                const routeSequenceElement = document.getElementById('route-sequence');
                if (routeSequenceElement) {
                    // Limpar qualquer conte√∫do anterior
                    routeSequenceElement.innerHTML = '';
                    
                    // Obter localiza√ß√µes na ordem da rota
                    // Garantir que todos os IDs j√° foram normalizados na etapa anterior
                    const routeLocations = tspResult.path.map(id => {
                        const idStr = String(id);
                        const location = locations.find(loc => String(loc.id) === idStr);
                        if (!location) {
                            console.error(`Localiza√ß√£o n√£o encontrada para ID: ${idStr} ao montar sequ√™ncia`);
                        }
                        return location;
                    }).filter(loc => loc !== undefined);
                    
                    // Criar lista com a sequ√™ncia de locais
                    const sequenceList = document.createElement('ol');
                    sequenceList.className = 'route-sequence-list';
                    
                    routeLocations.forEach((location, index) => {
                        const item = document.createElement('li');
                        // Destacar a origem
                        if (location.isOrigin) {
                            item.className = 'origin-point';
                            item.innerHTML = `<strong>${location.name}</strong> (Origem)`;
                        } else {
                            item.innerHTML = location.name;
                        }
                        sequenceList.appendChild(item);
                    });
                    
                    routeSequenceElement.appendChild(sequenceList);
                }
                
                // Adicionar tamb√©m informa√ß√µes de dist√¢ncia e tempo estimado ao relat√≥rio
                const routeInfoElement = document.getElementById('route-summary');
                if (routeInfoElement) {
                    const distance = tspResult.distance ? tspResult.distance.toFixed(1) : "N/A";
                    const hours = Math.floor(tspResult.time / 60);
                    const minutes = Math.round(tspResult.time % 60);
                    const timeStr = hours > 0 ? `${hours}h ${minutes}min` : `${minutes}min`;
                    
                    routeInfoElement.innerHTML = `
                        <h3>Resumo da Rota</h3>
                        <p><strong>Dist√¢ncia total:</strong> ${distance} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeStr}</p>
                    `;
                }
                
                // Imprimir diagn√≥stico de marcadores ap√≥s o processamento
                console.log(`Ap√≥s processar rota: ${markers.length} marcadores principais, ${reorderedMarkers.length} marcadores reordenados`);
            } else {
                console.error("N√∫mero insuficiente de pontos para desenhar uma rota");
            }
            
            // Mostrar restri√ß√µes para caminh√µes nas cidades da rota
            showTruckRestrictionsForCitiesOnRoute(tspResult.path, null); // null para mostrar todos os tipos
            
            // Atualizar o resumo da rota
            updateRouteSummary(tspResult, vehicleType);
        } catch (error) {
            console.error("Erro ao calcular rota otimizada:", error);
            // Usar a fun√ß√£o centralizada de notifica√ß√£o
            showNotification("Ocorreu um erro ao calcular a rota. Tente novamente.", "error");
        }
        
        // Habilitar bot√µes de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
        
        // Esconder o spinner de carregamento
        hideLoadingSpinner();
        
        // Restaurar o bot√£o de otimizar
        const optimizeBtn = document.getElementById('optimize-route');
        if (optimizeBtn) {
            optimizeBtn.innerHTML = 'Otimizar Rota';
            optimizeBtn.disabled = false;
        }
        
        // N√£o navegar automaticamente para nenhuma aba ap√≥s a otimiza√ß√£o
        console.log("Rota otimizada com sucesso, mantendo a aba atual");
        
        // Garantir que os containers se ajustem ao conte√∫do ap√≥s o carregamento
        const restrictionsContainer = document.querySelector('.restrictions-container');
        const eventsContainer = document.querySelector('.events-container');
        
        if (restrictionsContainer) {
            restrictionsContainer.style.height = 'auto';
            restrictionsContainer.style.minHeight = '200px';
        }
        
        if (eventsContainer) {
            eventsContainer.style.height = 'auto';
            eventsContainer.style.minHeight = '200px';
        }
    }
    
    // Reordenar os marcadores para corresponder √† sequ√™ncia otimizada
    function reorderMarkers(optimizedPathIds) {
        console.log("Reordenando marcadores para caminho:", optimizedPathIds);
        
        // Atualizar a vari√°vel global com o caminho otimizado
        currentOptimizedPath = [...optimizedPathIds];
        
        // Atualizar eventos e restri√ß√µes para o novo caminho otimizado
        // Preparar dados para atualiza√ß√£o sem mudar para a aba de eventos
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        if (startDateInput && endDateInput) {
            // Atualizar dados dos eventos sem mudar de aba
            console.log("Atualizando dados de eventos em segundo plano sem mudar de aba");
            const routeIds = currentOptimizedPath;
            showEventsForCitiesOnRoute(routeIds, startDateInput.value, endDateInput.value);
            showTruckRestrictionsForCitiesOnRoute(routeIds, null);
        } else {
            // Fallback ao m√©todo antigo apenas se necess√°rio
            console.log("Usando m√©todo alternativo de atualiza√ß√£o");
        }
        console.log("Quantidade de marcadores antes:", markers.length);
        
        // Preservar os marcadores originais
        const originalMarkers = [...markers];
        
        // Remover os marcadores existentes do mapa (sem destru√≠-los)
        markers.forEach(markerObj => {
            markerObj.marker.setMap(null);
        });
        
        // Criar uma c√≥pia vazia para novos marcadores
        const newMarkers = [];
        
        // Converter IDs para objetos de localiza√ß√£o com compara√ß√£o segura
        const pathLocations = optimizedPathIds.map(id => {
            // Garantir que a compara√ß√£o de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados e corrigir IDs que s√£o objetos
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localiza√ß√µes n√£o foram encontradas.",
                "IDs da rota:", optimizedPathIds);
            
            // Tentar corrigir IDs que s√£o objetos em vez de valores primitivos
            optimizedPathIds = optimizedPathIds.map(id => {
                if (typeof id === 'object' && id !== null && id.id) {
                    return id.id; // Extrair o ID do objeto
                }
                return id;
            });
            
            // Tentar encontrar as localiza√ß√µes novamente
            console.log("Tentando novamente com IDs corrigidos:", optimizedPathIds);
            pathLocations = optimizedPathIds.map(id => {
                const idStr = String(id);
                return locations.find(loc => String(loc.id) === idStr);
            });
            
            // Se ainda houver localiza√ß√µes n√£o encontradas, registrar mas continuar
            if (pathLocations.some(loc => !loc)) {
                console.error("Ainda h√° localiza√ß√µes n√£o encontradas ap√≥s corre√ß√£o.");
            }
        }
        
        // Verificar se √© poss√≠vel reutilizar marcadores existentes
        if (originalMarkers.length > 0) {
            console.log("Tentando reutilizar marcadores existentes");
            
            // Tentar reutilizar marcadores originais na nova ordem
            pathLocations
                .filter(loc => loc) // Remover localiza√ß√µes nulas
                .forEach((location, index) => {
                    // Encontrar o marcador original correspondente a esta localiza√ß√£o
                    const originalMarker = originalMarkers.find(m => 
                        String(m.location.id) === String(location.id));
                    
                    if (originalMarker) {
                        // Reutilizar o marcador, atualizando apenas seu n√∫mero de sequ√™ncia
                        const marker = originalMarker.marker;
                        
                        // Garantir que a origem tenha sempre √≠ndice 0
                        const markerIndex = location.isOrigin ? 0 : (index);
                        const markerLabel = markerIndex === 0 ? 'O' : markerIndex.toString();
                        
                        console.log(`Atualizando marcador para ${location.name} (ID: ${location.id}) - √â origem: ${location.isOrigin}, Label: ${markerLabel}`);
                        
                        marker.setLabel({
                            text: markerLabel,
                            color: "#FFFFFF",
                            fontSize: '14px',
                            fontWeight: 'bold'
                        });
                        marker.setMap(map);
                        
                        // Adicionar √† nova lista de marcadores
                        newMarkers.push({
                            marker: marker,
                            location: location
                        });
                    } else {
                        // Se n√£o encontrou o marcador original, criar um novo
                        // Garantir que a origem tenha sempre √≠ndice 0
                        const markerIndex = location.isOrigin ? 0 : index;
                        console.log(`Criando novo marcador para ${location.name} (ID: ${location.id}) - √â origem: ${location.isOrigin}, √çndice: ${markerIndex}`);
                        addMarkerForLocation(location, markerIndex, newMarkers);
                    }
                });
                
            // Substituir o array de marcadores pelo novo
            markers = newMarkers;
        } else {
            // Fallback para o comportamento original
            console.log("N√£o h√° marcadores originais para reutilizar, criando novos");
            
            // Adicionar marcadores novamente na ordem otimizada
            pathLocations
                .filter(loc => loc) // Remover localiza√ß√µes nulas
                .forEach((location, index) => {
                    addMarkerForLocation(location, index);
                });
        }
        
        console.log("Quantidade de marcadores ap√≥s reordena√ß√£o:", markers.length);
        
        // Atualizar a lista de locais
        updateLocationsList();
    }

    // Fun√ß√£o auxiliar para verificar se dois locais est√£o na mesma cidade
    function isSameCity(loc1, loc2) {
        if (!loc1 || !loc2) return false;
        
        console.log(`Verificando se ${loc1.name} e ${loc2.name} est√£o na mesma cidade`);
        
        // Se o nome da cidade est√° expl√≠cito no objeto
        if (loc1.cityName && loc2.cityName) {
            const result = loc1.cityName === loc2.cityName;
            console.log(`Compara√ß√£o por cityName: ${loc1.cityName} vs ${loc2.cityName} = ${result}`);
            return result;
        }
        

        
        // Extrair cidade dos endere√ßos (normalmente o primeiro componente ap√≥s o nome)
        const address1Parts = loc1.address ? loc1.address.split(',') : [];
        const address2Parts = loc2.address ? loc2.address.split(',') : [];
        
        // Verificar se os endere√ßos t√™m pelo menos duas partes (nome, cidade)
        if (address1Parts.length > 0 && address2Parts.length > 0) {
            const city1 = address1Parts[0].trim().toLowerCase();
            const city2 = address2Parts[0].trim().toLowerCase();
            
            if (city1 === city2) {
                console.log(`Mesma cidade encontrada nos endere√ßos: ${city1}`);
                return true;
            }
        }
        
        // Verificar se ambos os nomes cont√™m a mesma cidade
        if (loc1.name && loc2.name) {
            // Removemos acentos e convertemos para min√∫sculas para compara√ß√£o
            const name1 = loc1.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            const name2 = loc2.name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            
            // Lista de cidades comuns do interior de S√£o Paulo
            const cities = [
                "dois corregos", "dois c√≥rregos", "jau", "ja√∫", "botucatu", "bauru", 
                "pederneiras", "brotas", "barra bonita", "igaracu", "igara√ßu", 
                "agudos", "lencois", "len√ß√≥is", "itapui", "itapu√≠"
            ];
            
            // Verificar se ambos os nomes cont√™m a mesma cidade
            for (const city of cities) {
                if (name1.includes(city) && name2.includes(city)) {
                    console.log(`Mesma cidade encontrada nos nomes: "${city}"`);
                    return true;
                }
            }
        }
        
        console.log("N√£o est√£o na mesma cidade");
        return false;
    }
    
    // Fun√ß√µes para controlar o spinner de carregamento
    function showLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'block';
        }
    }
    
    function hideLoadingSpinner() {
        const spinner = document.getElementById('loading-spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    }
    
    // Tra√ßar a rota no mapa
    function drawRouteOnMap(pathIds, vehicleType) {
        console.log("Desenhando rota para IDs:", pathIds);
        
        // Mostrar spinner durante o carregamento
        showLoadingSpinner();
        
        // Verifica√ß√µes de seguran√ßa
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de caminho inv√°lidos ou vazios:", pathIds);
            hideLoadingSpinner();
            return; // Interromper execu√ß√£o para evitar erros
        }
        
        // Verificar se h√° uma rota j√° desenhada e remov√™-la para evitar sobreposi√ß√µes
        if (routePath) {
            console.log("Removendo rota anterior antes de desenhar nova rota");
            try {
                routePath.setMap(null);
                routePath = null;
            } catch (e) {
                console.error("Erro ao remover rota anterior:", e);
            }
        }
        
        console.log("Localiza√ß√µes dispon√≠veis:", locations);
        
        // Converter ids para objetos de localiza√ß√£o
        const pathLocations = [];
        for (let i = 0; i < pathIds.length; i++) {
            const id = pathIds[i];
            // Garantir que a compara√ß√£o de IDs seja feita como string
            const lookupId = String(typeof id === 'object' ? (id.id || id) : id);
            console.log("Procurando localiza√ß√£o com ID:", lookupId, "Tipo:", typeof lookupId);
            
            const location = locations.find(loc => String(loc.id) === lookupId);
            if (!location) {
                console.error(`Localiza√ß√£o ID ${lookupId} n√£o encontrada!`);
            } else {
                console.log(`Localiza√ß√£o ID ${lookupId} encontrada:`, location);
                pathLocations.push(location);
            }
        }
        
        // Verificar se todos os ids foram encontrados
        if (pathLocations.length !== pathIds.length) {
            // Usar String para garantir compara√ß√£o consistente
            const missingIds = pathIds.filter(id => {
                const idStr = String(id);
                return !pathLocations.find(loc => String(loc.id) === idStr);
            });
            
            console.error("Algumas localiza√ß√µes n√£o foram encontradas:", missingIds);
            // Usar fun√ß√£o auxiliar para mostrar notifica√ß√£o
            showNotification('Erro ao tra√ßar rota: algumas localiza√ß√µes n√£o foram encontradas', 'danger', '.route-controls');
            return;
        }
        
        // Verificar e destacar pontos na mesma cidade da origem
        const origin = locations.find(loc => loc.isOrigin);
        
        if (origin) {
            pathLocations.forEach(location => {
                if (!location.isOrigin && isSameCity(location, origin)) {
                    console.log(`Ponto ${location.name} est√° na mesma cidade da origem (${origin.name})`);
                    
                    // Encontrar o marcador correspondente e destac√°-lo
                    const locationId = location.id;
                    console.log("Buscando marcador para ID:", locationId, "Tipo:", typeof locationId);
                    
                    // Depura√ß√£o de todos os markers para diagn√≥stico
                    console.log("Todos os marcadores dispon√≠veis:", markers.map(m => ({
                        name: m.location.name,
                        id: m.location.id,
                        idType: typeof m.location.id
                    })));
                    
                    // Busca do marcador com convers√£o de string consistente
                    const markerIdString = String(locationId);
                    console.log(`Procurando marcador com ID string "${markerIdString}"`);
                    
                    const marker = markers.find(m => {
                        if (!m || !m.location) {
                            console.log("Marcador inv√°lido encontrado na lista");
                            return false;
                        }
                        
                        try {
                            const mLocationIdString = String(m.location.id);
                            const isMatch = mLocationIdString === markerIdString;
                            console.log(`Comparando IDs: "${mLocationIdString}" === "${markerIdString}" = ${isMatch}`);
                            return isMatch;
                        } catch (err) {
                            console.error("Erro ao comparar IDs:", err);
                            return false;
                        }
                    });
                    
                    if (marker) {
                        marker.marker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#FF4500', // Cor mais destacada
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#000',
                            scale: 12
                        });
                    } else {
                        console.log(`Marcador n√£o encontrado para localiza√ß√£o ${location.name} (ID: ${locationId})`);
                    }
                }
            });
        }
        
        // Criar waypoints para o servi√ßo de dire√ß√µes
        console.log("Criando waypoints para o servi√ßo de dire√ß√µes com " + pathLocations.length + " pontos");
        
        // Debug para verificar que temos todos os pontos necess√°rios
        pathLocations.forEach((location, idx) => {
            console.log(`Ponto ${idx}: ${location.name} (${location.latitude}, ${location.longitude}) - isOrigin: ${location.isOrigin}`);
        });
        
        const waypoints = pathLocations.slice(1, -1).map(location => ({
            location: new google.maps.LatLng(location.latitude, location.longitude),
            stopover: true
        }));
        
        const originPoint = new google.maps.LatLng(
            pathLocations[0].latitude,
            pathLocations[0].longitude
        );
        
        const destinationPoint = new google.maps.LatLng(
            pathLocations[pathLocations.length - 1].latitude,
            pathLocations[pathLocations.length - 1].longitude
        );
        
        const request = {
            origin: originPoint,
            destination: destinationPoint,
            waypoints: waypoints,
            optimizeWaypoints: false, // N√£o otimizar, j√° temos a ordem do TSP
            travelMode: google.maps.TravelMode.DRIVING,
            avoidTolls: false
        };
        
        directionsService.route(request, (result, status) => {
            // Esconder indicador de progresso
            hideLoadingSpinner();
            
            if (status === google.maps.DirectionsStatus.OK) {
                // Verificar se o DirectionsRenderer foi inicializado corretamente
                if (!directionsRendererInitialized || !directionsRenderer) {
                    console.error("DirectionsRenderer n√£o est√° dispon√≠vel ou inicializado");
                    showNotification("Erro no servi√ßo de rotas. Tente recarregar a p√°gina.", "danger");
                    return;
                }
                
                // Limpar todas as polylines antigas para evitar sobreposi√ß√µes
                clearAllPolylines();
                
                try {
                    // Limpar renderizador antes de aplicar novas dire√ß√µes
                    directionsRenderer.setMap(null);
                    
                    // Recriar o renderizador para garantir que n√£o haja sobreposi√ß√µes
                    directionsRenderer = new google.maps.DirectionsRenderer({
                        suppressMarkers: true, // Usamos nossos pr√≥prios marcadores
                        preserveViewport: true, // N√£o muda o zoom/centro do mapa
                        polylineOptions: {
                            strokeColor: '#1976D2',
                            strokeOpacity: 0.7,
                            strokeWeight: 4
                        }
                    });
                    directionsRenderer.setMap(map);
                    
                    // Aplicar as dire√ß√µes ao renderizador
                    directionsRenderer.setDirections(result);
                    console.log("Dire√ß√µes aplicadas com sucesso");
                    
                    // Registrar esta rota como a atual
                    currentDisplayedRoute = pathIds;
                    
                    // Capturar refer√™ncias √†s polylines para limpeza futura
                    setTimeout(() => {
                        try {
                            const mapDiv = document.getElementById('map');
                            if (mapDiv) {
                                const polylines = mapDiv.querySelectorAll('path');
                                console.log(`Encontradas ${polylines.length} polylines no mapa`);
                            }
                        } catch (e) {
                            console.error("Erro ao contar polylines:", e);
                        }
                    }, 500);
                    
                } catch (err) {
                    console.error("Erro ao aplicar dire√ß√µes:", err);
                    showNotification("Erro ao exibir rota no mapa: " + err.message, "warning");
                    return;
                }
                
                // Animar a rota (opcional)
                console.log("Resultado da rota:", result);
                
                // Verificar se os dados da rota est√£o dispon√≠veis
                if (result && result.routes && result.routes.length > 0 && result.routes[0].overview_path) {
                    console.log("Iniciando anima√ß√£o da rota com", result.routes[0].overview_path.length, "pontos");
                    
                    // Pequeno atraso para garantir que o DirectionsRenderer esteja pronto
                    setTimeout(() => {
                        try {
                            // Verifica se os pontos s√£o objetos de LatLng ou precisam ser convertidos
                            const routePoints = result.routes[0].overview_path.map(point => {
                                // Se j√° for um objeto LatLng, retorne-o diretamente
                                if (point instanceof google.maps.LatLng) {
                                    return point;
                                } 
                                // Se for um objeto com lat/lng como m√©todos
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    return new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    return new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Formato desconhecido
                                else {
                                    console.error("Formato de ponto desconhecido:", point);
                                    return null;
                                }
                            }).filter(p => p !== null);
                            
                            console.log("Pontos da rota preparados para anima√ß√£o:", routePoints.length);
                            animateRoute(routePoints);
                        } catch (err) {
                            console.error("Erro ao preparar pontos para anima√ß√£o da rota:", err);
                            showNotification("N√£o foi poss√≠vel animar a rota: " + err.message, "warning");
                        }
                    }, 1000);
                    
                } else {
                    console.error("Dados da rota incompletos, n√£o √© poss√≠vel animar:", result);
                    showNotification("N√£o foi poss√≠vel visualizar a rota animada. Tente novamente.", "warning");
                }
                
                // Ajustar o mapa para mostrar toda a rota
                const bounds = new google.maps.LatLngBounds();
                pathLocations.forEach(location => {
                    bounds.extend(new google.maps.LatLng(location.latitude, location.longitude));
                });
                map.fitBounds(bounds);
                
                // Adicionar um pequeno padding ao mapa para melhor visualiza√ß√£o
                const padding = {
                    top: 50,
                    right: 50,
                    bottom: 50,
                    left: 50
                };
                map.fitBounds(bounds, padding);
            } else {
                // Substituir alert por notifica√ß√£o inline mais suave
                console.error(`Erro ao calcular rota: ${status}`);
                
                // Preparar mensagem de erro mais amig√°vel baseada no tipo de erro
                let errorMsg = '';
                
                if (status === 'ZERO_RESULTS') {
                    errorMsg = 'N√£o foi poss√≠vel encontrar uma rota entre os pontos selecionados. ' +
                              'Isto pode ocorrer se um dos pontos estiver em uma √°rea inacess√≠vel ' +
                              'ou se houver uma grande barreira natural (como um rio ou oceano) entre eles.';
                } else if (status === 'MAX_WAYPOINTS_EXCEEDED') {
                    errorMsg = 'N√∫mero m√°ximo de destinos excedido. Tente dividir sua rota em partes menores.';
                } else if (status === 'MAX_ROUTE_LENGTH_EXCEEDED') {
                    errorMsg = 'A rota √© muito longa. Tente dividir sua rota em partes menores.';
                } else if (status === 'OVER_QUERY_LIMIT') {
                    errorMsg = 'Limite de consultas excedido. Aguarde alguns minutos e tente novamente.';
                } else {
                    errorMsg = `N√£o foi poss√≠vel calcular a rota: ${status}`;
                }
                
                // Usar fun√ß√£o auxiliar para exibir notifica√ß√£o
                showNotification(errorMsg, 'danger');
                console.error("Directions request failed due to " + status);
            }
        });
    }

    // Animar a rota desenhando progressivamente
    function animateRoute(path) {
        console.log("Iniciando anima√ß√£o da rota...");
        
        // Logging para diagn√≥stico
        try {
            if (path && path.length > 0) {
                const firstPoint = path[0];
                console.log("Primeiro ponto da rota:", firstPoint);
                console.log("Tipo do primeiro ponto:", 
                    firstPoint instanceof google.maps.LatLng ? "LatLng" :
                    typeof firstPoint.lat === 'function' ? "Com m√©todos lat/lng" :
                    firstPoint.lat !== undefined ? "Com propriedades lat/lng" :
                    firstPoint.latitude !== undefined ? "Com propriedades latitude/longitude" :
                    "Desconhecido"
                );
            }
        } catch (e) {
            console.error("Erro ao analisar formato dos pontos:", e);
        }
        
        try {
            // Limpar qualquer anima√ß√£o existente
            if (routeAnimationTimeout) {
                clearTimeout(routeAnimationTimeout);
                routeAnimationTimeout = null;
            }
            
            // Se j√° existir uma rota, remov√™-la
            if (routePath) {
                try {
                    routePath.setMap(null);
                } catch (err) {
                    console.error("Erro ao limpar rota anterior:", err);
                }
                routePath = null;
            }
            
            // For√ßar limpeza de qualquer polyline restante no mapa
            try {
                if (directionsRendererInitialized && directionsRenderer) {
                    directionsRenderer.setDirections({ routes: [] });
                }
                
                // Este √© um "truque" para for√ßar a limpeza de todas as polylines
                if (map) {
                    const mapCenter = map.getCenter();
                    map.setCenter(mapCenter);
                }
            } catch (err) {
                console.error("Erro ao fazer limpeza extra do mapa:", err);
            }
            
            // Verificar se o caminho √© v√°lido
            if (!path) {
                console.error("Caminho nulo para anima√ß√£o");
                showNotification("N√£o foi poss√≠vel animar a rota: dados ausentes", "warning");
                return;
            }
            
            if (!Array.isArray(path)) {
                console.error("Tipo de caminho inv√°lido para anima√ß√£o:", typeof path);
                showNotification("N√£o foi poss√≠vel animar a rota: formato de dados incorreto", "warning");
                return;
            }
            
            if (path.length === 0) {
                console.error("Caminho vazio para anima√ß√£o");
                showNotification("N√£o foi poss√≠vel animar a rota: caminho vazio", "warning");
                return;
            }
        } catch (err) {
            console.error("Erro na inicializa√ß√£o da anima√ß√£o:", err);
            return;
        }
        
        // Limpar todas as polylines anteriores antes de criar nova
        clearAllPolylines();
        
        // Criar uma nova polyline para a rota
        routePath = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: '#1976D2',
            strokeOpacity: 1.0,
            strokeWeight: 5,
            map: map
        });
        
        // Registrar esta polyline para limpeza futura
        allRoutePolylines.push(routePath);
        
        console.log(`Animando rota com ${path.length} pontos...`);
        
        // Anima√ß√£o step-by-step
        let index = 0;
        const interval = 20; // ms entre cada ponto
        const batchSize = 3; // n√∫mero de pontos a adicionar por vez (para anima√ß√£o mais suave)
        
        function animate() {
            // Verificar se o caminho da rota ainda est√° dispon√≠vel
            if (!routePath) {
                console.error("routePath foi removido antes do in√≠cio da anima√ß√£o");
                return;
            }
            
            if (index < path.length) {
                try {
                    // Adicionar um lote de pontos por vez para anima√ß√£o mais suave
                    for (let i = 0; i < batchSize && index < path.length; i++) {
                        if (routePath && routePath.getPath) {
                            try {
                                const point = path[index];
                                
                                // Criar um objeto LatLng v√°lido, independente do formato do ponto
                                let latLng;
                                
                                // Se j√° for um objeto LatLng v√°lido
                                if (point instanceof google.maps.LatLng) {
                                    latLng = point;
                                }
                                // Se for um objeto com m√©todos lat/lng
                                else if (typeof point.lat === 'function' && typeof point.lng === 'function') {
                                    latLng = new google.maps.LatLng(point.lat(), point.lng());
                                }
                                // Se for um objeto com propriedades lat/lng
                                else if (point.lat !== undefined && point.lng !== undefined) {
                                    latLng = new google.maps.LatLng(point.lat, point.lng);
                                }
                                // Se for um objeto com propriedades latitude/longitude
                                else if (point.latitude !== undefined && point.longitude !== undefined) {
                                    latLng = new google.maps.LatLng(point.latitude, point.longitude);
                                }
                                // Formato desconhecido - usar um ponto padr√£o para evitar erros
                                else {
                                    console.error("Formato de ponto desconhecido na anima√ß√£o:", point);
                                    // Pular este ponto e continuar
                                    index++;
                                    continue;
                                }
                                
                                // Adicionar o ponto ao caminho
                                routePath.getPath().push(latLng);
                            } catch (pointErr) {
                                console.error("Erro ao processar ponto espec√≠fico:", pointErr, "√çndice:", index);
                                // Continuar para o pr√≥ximo ponto mesmo em caso de erro
                            }
                        } else {
                            console.error("routePath foi removido durante a anima√ß√£o");
                            return; // Sair para evitar erros
                        }
                        index++;
                    }
                    
                    // Mostrar progresso da anima√ß√£o para depura√ß√£o
                    if (index % 20 === 0 || index === path.length) {
                        console.log(`Anima√ß√£o da rota: ${Math.round((index / path.length) * 100)}% conclu√≠da (${index}/${path.length} pontos)`);
                    }
                    
                    // Agendar pr√≥ximo batch da anima√ß√£o
                    routeAnimationTimeout = setTimeout(animate, interval);
                } catch (err) {
                    console.error("Erro durante a anima√ß√£o da rota:", err);
                    showNotification("Erro na anima√ß√£o da rota: " + err.message, "warning");
                }
            } else {
                console.log("Anima√ß√£o da rota conclu√≠da com sucesso.");
                showNotification("Rota calculada e animada com sucesso!", "success");
            }
        }
        
        // Iniciar anima√ß√£o com breve atraso
        console.log("Agendando in√≠cio da anima√ß√£o da rota...");
        setTimeout(animate, 100);
    }

    // Mostrar pontos de interesse ao longo da rota
    function showPointsOfInterestOnRoute(pathIds) {
        console.log("Mostrando pontos de interesse para rota com IDs:", pathIds);
        
        // Verifica√ß√µes de seguran√ßa
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inv√°lidos ou vazios para pontos de interesse:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar pontos de interesse:", pathIds);
            } else {
                console.error("Imposs√≠vel encontrar at√© mesmo a origem. Abortando exibi√ß√£o de pontos de interesse.");
                return;
            }
        }
        
        // Limpar marcadores anteriores
        clearPOIMarkers();
        
        // Se a op√ß√£o de mostrar POIs estiver desativada, retornar
        if (!showPOIs) return;
        
        console.log("showPointsOfInterestOnRoute recebeu IDs:", pathIds);
        
        // Converter IDs para objetos de localiza√ß√£o com compara√ß√£o segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a compara√ß√£o de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localiza√ß√µes n√£o foram encontradas.", 
                "IDs da rota:", pathIds.map(id => String(id)),
                "Localiza√ß√µes:", locations);
            // Continuar mesmo com algumas localiza√ß√µes faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (vers√£o melhorada)
        const citiesOnRoute = []; // Array para armazenar as cidades detectadas
        
        // Lista de cidades importantes para melhor detec√ß√£o
        const knownCities = [
            "Campinas", "Ribeir√£o Preto", "S√£o Carlos", "Piracicaba", "S√£o Paulo", 
            "Sorocaba", "Americana", "Limeira", "Rio Claro", "Araraquara", "Bauru", 
            "Botucatu", "Ja√∫", "Dois C√≥rregos", "Santos", "Guarulhos", "Osasco",
            "Jundia√≠", "Franca", "Mar√≠lia", "Presidente Prudente", "Ara√ßatuba"
        ];
        
        // Para cada localiza√ß√£o na rota
        pathLocations.filter(loc => loc).forEach(loc => {
            if (!loc.address) {
                // Se n√£o tiver endere√ßo, usar o nome da localiza√ß√£o
                if (loc.name && !citiesOnRoute.includes(loc.name)) {
                    citiesOnRoute.push(loc.name);
                }
                return;
            }
            
            // 1. Verificar se o endere√ßo cont√©m alguma cidade conhecida
            const addressLower = loc.address.toLowerCase();
            let cityFound = false;
            
            knownCities.forEach(city => {
                if (addressLower.includes(city.toLowerCase())) {
                    if (!citiesOnRoute.includes(city)) {
                        console.log(`Cidade conhecida encontrada: ${city} em "${loc.address}"`);
                        citiesOnRoute.push(city);
                        cityFound = true;
                    }
                }
            });
            
            // 2. Se n√£o encontrou nenhuma cidade conhecida, extrair a primeira parte do endere√ßo
            if (!cityFound) {
                const parts = loc.address.split(',');
                const extractedCity = parts[0].trim();
                
                if (extractedCity && !citiesOnRoute.includes(extractedCity)) {
                    console.log(`Cidade extra√≠da do endere√ßo: ${extractedCity}`);
                    citiesOnRoute.push(extractedCity);
                }
            }
        });
        
        console.log("Cidades detectadas no percurso:", citiesOnRoute);
        
        // Filtrar POIs que est√£o nas cidades da rota
        const poisOnRoute = mockData.pointsOfInterest.filter(poi => 
            citiesOnRoute.some(city => poi.cityName.includes(city))
        );
        
        // Adicionar marcadores para os POIs
        poisOnRoute.forEach(poi => {
            let icon;
            
            // √çcone baseado no tipo de POI
            switch (poi.type) {
                case 'toll':
                    icon = {
                        path: 'M-2,-2 L2,-2 L2,2 L-2,2 Z', // Quadrado
                        fillColor: '#4caf50',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#007700',
                        scale: 6,
                        labelOrigin: new google.maps.Point(0, 0)
                    };
                    break;
                case 'weighStation':
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#ff9800',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#b26a00',
                        scale: 6
                    };
                    break;
                case 'gasStation':
                    icon = {
                        path: 'M-2,-2 L2,-2 L0,2 Z', // Tri√¢ngulo
                        fillColor: '#2196f3',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#0069c0',
                        scale: 6
                    };
                    break;
                default:
                    icon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#9c27b0',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: '#6a0080',
                        scale: 6
                    };
            }
            
            // Criar o marcador
            const marker = new google.maps.Marker({
                position: { lat: poi.latitude, lng: poi.longitude },
                map: map,
                title: poi.name,
                icon: icon,
                zIndex: 50
            });
            
            // Adicionar listener para mostrar tooltip ao passar o mouse
            marker.addListener('mouseover', function() {
                showTooltip(marker, poi);
            });
            
            marker.addListener('mouseout', function() {
                hideTooltip();
            });
            
            // Armazenar o marcador
            poiMarkers.push(marker);
        });
    }

    // Mostrar eventos para as cidades na rota
    function showEventsForCitiesOnRoute(pathIds, startDateStr, endDateStr) {
        console.log("=================== NOVA EXECU√á√ÉO ===================");
        console.log("Mostrando eventos para rota com IDs:", pathIds);
        console.log("Datas de filtro (string):", startDateStr, endDateStr);
        
        // Valores para filtragem por data - garantir que s√£o strings v√°lidas
        let startDateValue = startDateStr || "";
        let endDateValue = endDateStr || "";
        
        // Verifica√ß√µes de seguran√ßa
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.error("IDs de rota inv√°lidos ou vazios:", pathIds);
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando apenas a origem para mostrar eventos:", pathIds);
            } else {
                console.error("Imposs√≠vel encontrar at√© mesmo a origem. Abortando exibi√ß√£o de eventos.");
                return;
            }
        }
        
        // Limpar a lista de eventos
        const eventsListContainer = document.getElementById('events-list');
        eventsListContainer.innerHTML = '';
        
        // Log para diagn√≥stico
        console.log("Eventos dispon√≠veis:", mockData.cityEvents);
        
        if (!pathIds || pathIds.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos.</p>';
            return;
        }
        
        // CORRE√á√ÉO: Converter IDs para objetos de localiza√ß√£o de forma mais robusta
        const pathLocations = [];
        for (const id of pathIds) {
            const idStr = String(id);
            const location = locations.find(loc => String(loc.id) === idStr);
            if (location) {
                pathLocations.push(location);
                console.log(`Localiza√ß√£o encontrada para ID ${idStr}:`, location);
            }
        }
        
        if (pathLocations.length === 0) {
            console.error("Nenhuma localiza√ß√£o v√°lida encontrada na rota");
            eventsListContainer.innerHTML = '<p class="text-muted">Erro ao encontrar localiza√ß√µes na rota.</p>';
            return;
        }
        
        // EXTRA√á√ÉO MELHORADA DE CIDADES DO PERCURSO
        // Array para armazenar os nomes das cidades que est√£o REALMENTE na rota
        const citiesOnRoute = [];
        
        // Cidade de origem (sempre incluir Dois C√≥rregos)
        citiesOnRoute.push("Dois C√≥rregos");
        console.log(`[ROTA] Adicionada cidade de origem: Dois C√≥rregos`);
        
        // Processar CADA destino na rota para extrair nomes de cidades
        for (const location of pathLocations) {
            // Apenas adicionar se tivermos um nome v√°lido
            if (location && location.name) {
                // Verificar se o nome √© uma cidade conhecida (estrat√©gia 1)
                const knownCities = [
                    "Dois C√≥rregos", "Ja√∫", "Botucatu", "Bauru", "Ribeir√£o Preto", 
                    "S√£o Paulo", "Campinas", "S√£o Carlos", "Piracicaba", "Araraquara",
                    "Americana", "Sorocaba", "Limeira", "Rio Claro", "Mineiros do Tiet√™",
                    "Barra Bonita", "Igara√ßu do Tiet√™", "Macatuba", "Pederneiras", "Bocaina",
                    "Brotas", "Torrinha", "Itirapina", "S√£o Manuel", "Len√ß√≥is Paulista",
                    "Agudos", "Mar√≠lia", "Ourinhos", "Assis", "Presidente Prudente"
                ];
                
                // Se o nome exato da localiza√ß√£o √© uma cidade conhecida
                if (knownCities.includes(location.name) && !citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionada cidade conhecida: ${location.name}`);
                    continue; // Ir para o pr√≥ximo local
                }
                
                // Estrat√©gia 2: Usar o nome da localiza√ß√£o diretamente
                if (!citiesOnRoute.includes(location.name)) {
                    citiesOnRoute.push(location.name);
                    console.log(`[ROTA] Adicionado local como poss√≠vel cidade: ${location.name}`);
                }
            }
        }
        
        console.log(`[ROTA] Cidades encontradas no percurso (${citiesOnRoute.length}): ${citiesOnRoute.join(', ')}`);
        
        console.log("APENAS ESTAS CIDADES EST√ÉO NA ROTA REAL:", citiesOnRoute);
        
        // NOVA IMPLEMENTA√á√ÉO DE FILTRAGEM DE EVENTOS
        console.log("NOVA IMPLEMENTA√á√ÉO: Filtragem estrita de eventos por cidade e data");
        console.log(`Filtrando eventos para cidades: ${citiesOnRoute.join(', ')}`);
        console.log(`Filtro de data: ${startDateValue || 'sem data inicial'} a ${endDateValue || 'sem data final'}`);
        
        // ESTE √â O PONTO CR√çTICO PARA A CORRE√á√ÉO DO FILTRO DE DATAS
        // Usar EXATAMENTE as datas informadas pelo usu√°rio nos campos do formul√°rio
        console.log("[CORRE√á√ÉO DE FILTRO] Usando datas exatamente como informadas pelo usu√°rio:", startDateStr, endDateStr);
        
        // Apenas ajustar se as datas estiverem totalmente vazias
        if (!startDateValue && !endDateValue) {
            // Obter os valores REAIS dos campos no formul√°rio
            const startDateField = document.getElementById('start-date');
            const endDateField = document.getElementById('end-date');
            
            if (startDateField && startDateField.value) {
                startDateValue = startDateField.value;
                console.log("[FILTRO] Obtida data de in√≠cio do campo do formul√°rio:", startDateValue);
            }
            
            if (endDateField && endDateField.value) {
                endDateValue = endDateField.value;
                console.log("[FILTRO] Obtida data de fim do campo do formul√°rio:", endDateValue);
            }
            
            // Se ainda estiver vazio, apenas ent√£o usar valores padr√£o
            const currentYear = new Date().getFullYear();
            if (!startDateValue) {
                startDateValue = `${currentYear}-01-01`;
                console.log("[FILTRO] Usando data de in√≠cio padr√£o:", startDateValue);
            }
            
            if (!endDateValue) {
                endDateValue = `${currentYear}-12-31`;
                console.log("[FILTRO] Usando data de fim padr√£o:", endDateValue);
            }
        }
        
        console.log(`[DATA] Filtro FINAL: ${startDateValue} at√© ${endDateValue}`);
        
        // Array para armazenar eventos filtrados
        let eventsOnRoute = [];
        
        // Para cada evento nos dados...
        mockData.cityEvents.forEach(event => {
            let includeEvent = false;
            
            try {
                // PARTE 1: VERIFICA√á√ÉO DE CIDADE - Evento deve estar em uma cidade do percurso
                const cityMatch = citiesOnRoute.includes(event.cityName);
                if (!cityMatch) {
                    console.log(`[CIDADE] Evento '${event.name}' em '${event.cityName}' REJEITADO - cidade n√£o est√° no percurso`);
                    return; // Pular para o pr√≥ximo evento
                }
                
                // PARTE 2: AJUSTAR DATAS DO EVENTO PARA O ANO ATUAL
                // Evento especial: Festival de Ver√£o
                const isFestivalVerao = event.id === 99 && event.name === "Festival de Ver√£o";
                
                // Obter o ano atual
                const currentYear = new Date().getFullYear();
                
                // Criar novas datas para o evento ajustadas para o ano atual
                const eventStart = new Date(event.startDate);
                const eventEnd = new Date(event.endDate);
                
                // Garantir que estamos usando o ano atual para eventos anuais (anivers√°rios)
                if (event.name.includes("Anivers√°rio") || event.isHoliday) {
                    eventStart.setFullYear(currentYear);
                    eventEnd.setFullYear(currentYear);
                }
                
                // Ajustar horas para garantir dias completos
                eventStart.setHours(0,0,0,0);
                eventEnd.setHours(23,59,59,999);
                
                // Log detalhado
                console.log(`[EVENTO] ${event.name} (${event.cityName}): ${eventStart.toLocaleDateString('pt-BR')}-${eventEnd.toLocaleDateString('pt-BR')}`);
                
                // PARTE 3: APLICAR FILTRO DE DATA
                if (startDateValue && endDateValue) {
                    // Tratamento especial para o Festival de Ver√£o
                    if (isFestivalVerao) {
                        console.log(`[FESTIVAL] Festival de Ver√£o exclu√≠do quando h√° filtro de data`);
                        includeEvent = false;
                        return;
                    }
                    
                    try {
                        // Criar objetos Date para as datas do filtro
                        let filterStart = new Date(startDateValue);
                        let filterEnd = new Date(endDateValue);
                        
                        // Verificar se as datas s√£o objetos Date v√°lidos
                        if (isNaN(filterStart.getTime()) || isNaN(filterEnd.getTime())) {
                            console.error(`[ERRO] Datas de filtro inv√°lidas: ${startDateValue}, ${endDateValue}`);
                            
                            // Tentar corrigir formatos de data (pode ser ISO ou MM/DD/YYYY)
                            if (startDateValue.includes('/')) {
                                const parts = startDateValue.split('/');
                                filterStart = new Date(parts[2], parts[0]-1, parts[1]);
                            }
                            
                            if (endDateValue.includes('/')) {
                                const parts = endDateValue.split('/');
                                filterEnd = new Date(parts[2], parts[0]-1, parts[1]);
                            }
                            
                            // Verificar novamente
                            if (isNaN(filterStart.getTime()) || isNaN(filterEnd.getTime())) {
                                console.error(`[ERRO] Imposs√≠vel corrigir datas inv√°lidas`);
                                includeEvent = true; // Em caso de erro, mostrar evento
                                return;
                            }
                        }
                        
                        // Garantir dia completo
                        filterStart.setHours(0,0,0,0);
                        filterEnd.setHours(23,59,59,999);
                        
                        // L√ìGICA CORRETA DE FILTRAGEM CONFORME ESPECIFICA√á√ÉO:
                        // Para exibir um evento, as seguintes condi√ß√µes devem ser atendidas:
                        // 1. A data de in√≠cio do filtro (start-date) deve ser <= data de in√≠cio do evento
                        // 2. A data de fim do filtro (end-date) deve ser >= data de in√≠cio do evento
                        
                        // Por exemplo:
                        // Evento de anivers√°rio em 04/02/2025:
                        // - Ser√° exibido se start-date <= 04/02/2025 E end-date >= 04/02/2025
                        
                        // Evento que ocorre de 04/08/2025 a 14/08/2025:
                        // - Ser√° exibido se start-date <= 04/08/2025 E end-date >= 04/08/2025
                        
                        const isEventInFilterRange = filterStart <= eventStart && filterEnd >= eventStart;
                        
                        console.log(`[VERIFICA√á√ÉO DE DATA]`, {
                            evento: event.name,
                            eventStart: eventStart.toLocaleDateString('pt-BR'),
                            eventEnd: eventEnd.toLocaleDateString('pt-BR'),
                            filterStart: filterStart.toLocaleDateString('pt-BR'),
                            filterEnd: filterEnd.toLocaleDateString('pt-BR'),
                            // Verificar se a data in√≠cio do filtro √© <= data in√≠cio do evento
                            condicao1: filterStart <= eventStart ? "SIM" : "N√ÉO",
                            // Verificar se a data fim do filtro √© >= data in√≠cio do evento
                            condicao2: filterEnd >= eventStart ? "SIM" : "N√ÉO",
                            resultado: isEventInFilterRange ? "ACEITO" : "REJEITADO"
                        });
                        
                        if (isEventInFilterRange) {
                            console.log(`[ACEITO] Evento '${event.name}' (${eventStart.toLocaleDateString('pt-BR')}) est√° dentro do per√≠odo de filtro: ${filterStart.toLocaleDateString('pt-BR')} a ${filterEnd.toLocaleDateString('pt-BR')}`);
                            includeEvent = true;
                        } else {
                            console.log(`[REJEITADO] Evento '${event.name}' (${eventStart.toLocaleDateString('pt-BR')}) est√° fora do per√≠odo de filtro: ${filterStart.toLocaleDateString('pt-BR')} a ${filterEnd.toLocaleDateString('pt-BR')}`);
                            includeEvent = false;
                        }
                    } catch (dateError) {
                        console.error(`[ERRO] Falha ao processar datas do filtro:`, dateError);
                        includeEvent = true; // Em caso de erro mostrar o evento
                    }
                } else {
                    // Sem filtro de data, mostrar todos os eventos
                    console.log(`[ACEITO] Evento '${event.name}' aceito (sem filtro de data)`);
                    includeEvent = true;
                }
                
            } catch (error) {
                console.error(`[ERRO GERAL] Falha ao processar evento ${event.name}:`, error);
                includeEvent = true; // Em caso de erro geral, mostrar o evento
            }
            
            // Se passou por todos os filtros, incluir o evento
            if (includeEvent) {
                console.log(`[FINAL] Evento '${event.name}' em '${event.cityName}' - INCLU√çDO NA LISTA FINAL`);
                eventsOnRoute.push(event);
            }
        });
        
        // Se n√£o houver eventos, mostrar mensagem
        if (eventsOnRoute.length === 0) {
            eventsListContainer.innerHTML = '<p class="text-muted">Nenhum evento encontrado para o per√≠odo e cidades selecionados.</p>';
            return;
        }
        
        // Limpar marcadores anteriores
        clearEventMarkers();
        
        // Ordenar eventos por data
        eventsOnRoute.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        
        // Adicionar cada evento √† lista
        eventsOnRoute.forEach(event => {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Formatar datas
            const startDate = new Date(event.startDate);
            const endDate = new Date(event.endDate);
            const formattedStartDate = startDate.toLocaleDateString('pt-BR');
            const formattedEndDate = endDate.toLocaleDateString('pt-BR');
            const dateText = formattedStartDate === formattedEndDate ? 
                            formattedStartDate : 
                            `${formattedStartDate} - ${formattedEndDate}`;
            
            // Definir classe baseada no tipo de evento
            const eventTypeClass = event.isHoliday ? 'holiday' : 'event';
            
            eventItem.innerHTML = `
                <div class="event-name">${event.name} 
                    <span class="event-type ${eventTypeClass}">${event.isHoliday ? 'Feriado' : 'Evento'}</span>
                    <span class="restriction-level ${event.restrictionLevel}">${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'M√©dio' : 'Baixo')}</span>
                </div>
                <div class="event-date">${event.cityName} | ${event.name.includes("Anivers√°rio") ? extrairDataFundacao(event.description) : dateText}</div>
                <div class="event-description">${event.description}</div>
            `;
            
            eventsListContainer.appendChild(eventItem);
            
            // Adicionar marcador no mapa para o evento
            // Para simplificar, vamos usar a posi√ß√£o da cidade (primeiro local que corresponde ao nome da cidade)
            const cityLocation = pathLocations.find(loc => loc.address.includes(event.cityName));
            if (cityLocation) {
                addEventMarker(event, cityLocation);
            }
        });
    }

    // Adicionar marcador para um evento
    function addEventMarker(event, location) {
        // Seletor de √≠cone com base no tipo de evento
        const markerColor = event.isHoliday ? '#f44336' : '#ff9800';
        const markerIcon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: markerColor,
            fillOpacity: 1,
            strokeWeight: 1,
            strokeColor: '#000',
            scale: 8
        };
        
        // Criar o marcador
        const marker = new google.maps.Marker({
            position: { lat: location.latitude, lng: location.longitude },
            map: map,
            title: event.name,
            icon: markerIcon,
            zIndex: 30
        });
        
        // Conte√∫do do tooltip
        const tooltipContent = `
            <div class="tooltip-title">${event.name}</div>
            <div>${event.cityName}</div>
            <div>${new Date(event.startDate).toLocaleDateString('pt-BR')} - ${new Date(event.endDate).toLocaleDateString('pt-BR')}</div>
            <div>${event.description}</div>
            <div>N√≠vel de restri√ß√£o: ${event.restrictionLevel === 'high' ? 'Alto' : (event.restrictionLevel === 'medium' ? 'M√©dio' : 'Baixo')}</div>
        `;
        
        // Adicionar listener para mostrar tooltip ao passar o mouse
        marker.addListener('mouseover', function() {
            showTooltip(marker, { tooltipContent });
        });
        
        marker.addListener('mouseout', function() {
            hideTooltip();
        });
        
        // Armazenar o marcador
        eventMarkers.push(marker);
    }

    // Mostrar restri√ß√µes para caminh√µes nas cidades da rota
    function showTruckRestrictionsForCitiesOnRoute(pathIds, vehicleType) {
        console.log("DEBUG: Acionando fun√ß√£o para mostrar restri√ß√µes de caminh√µes das cidades do percurso");
        console.log("Mostrando restri√ß√µes de caminh√µes para rota com IDs:", pathIds);
        
        // Adicionar timestamp ao log para debug
        console.log("Timestamp:", new Date().toISOString());
        
        // Verificar se estamos no GitHub Pages
        const isGitHubPages = window.location.href.includes('github.io');
        
        if (isGitHubPages) {
            console.warn("GITHUB PAGES DETECTADO - Usando m√©todo adaptado para mostrar cidades na rota");
            
            // No GitHub Pages, vamos obter todas as cidades da rota
            // Esta √© a parte crucial: capturar as cidades da rota atual
            const citiesInRoute = [];
            
            // Se tivermos um caminho otimizado v√°lido, us√°-lo
            if (window.currentOptimizedPath && window.currentOptimizedPath.length > 0) {
                console.log("Usando rota otimizada para identificar cidades", window.currentOptimizedPath);
                
                // Adicionar origem primeiro
                const origin = locations.find(loc => loc.isOrigin);
                if (origin) {
                    citiesInRoute.push({
                        cityName: extractCityName(origin.address || origin.name),
                        position: 1,
                        originalLocation: origin,
                        displayName: origin.name // Nome para mostrar na interface
                    });
                }
                
                // Adicionar as demais cidades da rota otimizada
                for (let i = 0; i < window.currentOptimizedPath.length; i++) {
                    const locationId = window.currentOptimizedPath[i];
                    const location = locations.find(loc => String(loc.id) === String(locationId));
                    
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: i + 2, // +2 porque origem √© 1 e arrays come√ßam em 0
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                }
            } else {
                // Fallback para pathIds passados para a fun√ß√£o
                console.log("Usando pathIds como fallback para identificar cidades");
                
                // Usar os IDs de caminho fornecidos para obter as cidades
                pathIds.forEach((id, index) => {
                    const location = locations.find(loc => String(loc.id) === String(id));
                    if (location) {
                        citiesInRoute.push({
                            cityName: extractCityName(location.address || location.name),
                            position: index + 1,
                            originalLocation: location,
                            displayName: location.name // Nome para mostrar na interface
                        });
                    }
                });
            }
            
            // Garantir que temos cidades para mostrar
            if (citiesInRoute.length === 0) {
                console.warn("Nenhuma cidade encontrada na rota atual, usando cidades padr√£o");
                // Usar lista de cidades padr√£o como √∫ltimo recurso
                citiesInRoute.push(
                    { cityName: "Dois C√≥rregos", position: 1, displayName: "Dois C√≥rregos (origem)" },
                    { cityName: "Ja√∫", position: 2, displayName: "Ja√∫" },
                    { cityName: "Bauru", position: 3, displayName: "Bauru" }
                );
            }
            
            console.log("Cidades detectadas na rota:", citiesInRoute);
            
            // Limpar a lista
            const restrictionsListContainer = document.getElementById('restrictions-list');
            restrictionsListContainer.innerHTML = '';
            
            // Adicionar t√≠tulo explicativo
            const titleElement = document.createElement('div');
            titleElement.style.padding = '10px';
            titleElement.style.margin = '0 0 15px 0';
            titleElement.style.backgroundColor = '#ffc107';
            titleElement.style.color = 'black';
            titleElement.style.borderRadius = '4px';
            titleElement.style.fontWeight = 'bold';
            titleElement.style.textAlign = 'center';
            titleElement.style.width = '100%'; // Ocupar toda a largura dispon√≠vel
            
            // Construir nome das cidades para o t√≠tulo usando displayName em vez de cityName
            const citiesSequence = citiesInRoute.map(c => c.displayName || c.cityName).join(' ‚Üí ');
            titleElement.innerHTML = 'Restri√ß√µes para caminh√µes na rota<br>' + 
                                    '<span style="font-size: 0.9em; font-weight: normal; word-wrap: break-word; display: inline-block; width: 100%;">' +
                                    citiesSequence +
                                    '</span>';
            
            restrictionsListContainer.appendChild(titleElement);
            
            // Para cada cidade na rota, gerar uma restri√ß√£o representativa
            citiesInRoute.forEach(city => {
                // Gerar uma restri√ß√£o para esta cidade
                // Vamos variar o tipo de restri√ß√£o com base na posi√ß√£o para diversidade visual
                const restrictionType = city.position % 3 === 0 ? "rodizio" : (city.position % 2 === 0 ? "total" : "partial");
                const dayType = city.position % 2 === 0 ? "weekday" : "all";
                
                // Criar tipos diferentes de descri√ß√µes conforme o tipo de restri√ß√£o
                let description = "";
                if (restrictionType === "partial") {
                    description = "Restri√ß√£o parcial para caminh√µes de grande porte no centro";
                } else if (restrictionType === "total") {
                    description = "Restri√ß√£o total para caminh√µes acima de 2 eixos no centro";
                } else {
                    description = "Sistema de rod√≠zio para todos os tipos de caminh√µes";
                }
                
                // Definir hor√°rios diferentes com base na posi√ß√£o para variedade
                const startHour = (city.position % 12) + 7; // Entre 7h e 18h
                const endHour = Math.min(startHour + 3, 22); // No m√°ximo at√© 22h
                const startTime = `${startHour.toString().padStart(2, '0')}:00`;
                const endTime = `${endHour.toString().padStart(2, '0')}:00`;
                
                // Criar o elemento de restri√ß√£o
                const restrictionItem = document.createElement('div');
                restrictionItem.className = 'restriction-item';
                
                // Determinar texto de dias
                let dayTypeText = 'Todos os dias';
                if (dayType === 'weekday') dayTypeText = 'Dias √∫teis';
                else if (dayType === 'weekend') dayTypeText = 'Finais de semana';
                
                // Estilo para a cidade com barra lateral colorida
                const cidadeStyle = 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px; display: flex; align-items: center; flex-wrap: wrap;';
                
                // Texto com a posi√ß√£o na rota e nome do local
                let posicaoNaRotaTexto = '';
                if (city.position === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">Origem</span>';
                    
                    // Adicionar nome do local se dispon√≠vel
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                } else {
                    // Estilo para a posi√ß√£o com nome do local
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 8px; margin-right: 6px; font-size: 0.85em;">#${city.position}</span>`;
                    
                    // Adicionar nome do local se dispon√≠vel
                    if (city.displayName) {
                        posicaoNaRotaTexto += `<span style="font-size: 0.85em; margin-left: 3px; color: #555;">${city.displayName}</span>`;
                    }
                }
                
                // Criar HTML da restri√ß√£o
                restrictionItem.innerHTML = `
                    <div class="restriction-city" style="${cidadeStyle}">
                        ${posicaoNaRotaTexto}
                        ${city.cityName}
                        <span class="restriction-type ${restrictionType}">${restrictionType === 'partial' ? 'Parcial' : (restrictionType === 'total' ? 'Total' : 'Rod√≠zio')}</span>
                    </div>
                    <div class="restriction-time">${dayTypeText} | ${startTime} - ${endTime}</div>
                    <div class="restriction-description">${description}</div>
                    <div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">‚úì Esta cidade est√° no seu percurso</div>
                `;
                
                // Adicionar √† lista
                restrictionsListContainer.appendChild(restrictionItem);
            });
            
            console.log(`GitHub Pages: Exibindo ${citiesInRoute.length} restri√ß√µes para cidades na rota atual`);
            
            // Retornar para n√£o continuar a execu√ß√£o da fun√ß√£o original
            return;
        }
        
        // Verifica√ß√µes de seguran√ßa
        if (!pathIds || !Array.isArray(pathIds) || pathIds.length === 0) {
            console.warn("IDs de rota inv√°lidos ou vazios. Usando modo demonstra√ß√£o para exibir restri√ß√µes relevantes");
            
            // No modo demonstra√ß√£o, mostrar restri√ß√µes para cidades importantes
            const originLocations = locations.filter(loc => loc.isOrigin);
            if (originLocations.length > 0) {
                pathIds = originLocations.map(loc => loc.id);
                console.log("Usando a origem e cidades importantes para mostrar restri√ß√µes:", pathIds);
            } else {
                console.warn("Imposs√≠vel encontrar a origem, usando um ID padr√£o");
                pathIds = [1]; // ID padr√£o para quando n√£o h√° localiza√ß√£o de origem
            }
        }
        console.log("Par√¢metro vehicleType:", vehicleType, "- Isso ser√° ignorado completamente");
        // Limpar a lista de restri√ß√µes
        const restrictionsListContainer = document.getElementById('restrictions-list');
        restrictionsListContainer.innerHTML = '';
        
        // Log detalhado para diagn√≥stico
        console.log("Restri√ß√µes dispon√≠veis:", mockData.truckRestrictions);
        
        // DEBUG: For√ßar a exibi√ß√£o de restri√ß√µes para todas as cidades importantes
        console.warn("DIAGN√ìSTICO DE RESTRI√á√ïES: For√ßando exibi√ß√£o para todas as cidades");
        
        // Verificar se estamos na vers√£o GitHub Pages (j√° feito na fun√ß√£o)
        // A vari√°vel isGitHubPages j√° foi declarada no in√≠cio da fun√ß√£o
        // Apenas registrar para diagn√≥stico
        console.log("Executando em GitHub Pages (verifica√ß√£o secund√°ria):", isGitHubPages);
        
        // Converter IDs para objetos de localiza√ß√£o com compara√ß√£o segura
        const pathLocations = pathIds.map(id => {
            // Garantir que a compara√ß√£o de IDs seja feita como string
            const idStr = String(id);
            return locations.find(loc => String(loc.id) === idStr);
        });
        
        // Verificar se todos os IDs foram encontrados
        if (pathLocations.some(loc => !loc)) {
            console.error("Algumas localiza√ß√µes n√£o foram encontradas.",
                "IDs da rota:", pathIds.map(id => String(id)));
            // Continuar mesmo com algumas localiza√ß√µes faltando
            // return;
        }
        
        // Extrair nomes das cidades na rota (ignorar localiza√ß√µes n√£o encontradas)
        console.log("Detectando cidades na rota para restri√ß√µes de caminh√µes...");
        
        // IMPORTANTE: Para debug e diagn√≥stico - Visualizar as restri√ß√µes dispon√≠veis
        console.table(mockData.truckRestrictions.map(r => ({
            cidade: r.cityName,
            tipo: r.restrictionType,
            afeta: r.affectedVehicles ? r.affectedVehicles.join(', ') : 'todos',
            desc: r.description
        })));
        
        // Obter todos os waypoints da rota, se dispon√≠veis
        let citiesFromWaypoints = [];
        
        // Verificar se temos uma rota ativa com dire√ß√µes
        if (directionsRenderer && directionsRenderer.getDirections()) {
            const route = directionsRenderer.getDirections().routes[0];
            if (route && route.legs) {
                // Extrair cidades de todos os waypoints na rota
                route.legs.forEach(leg => {
                    if (leg.start_address) {
                        const startCity = extractCityFromAddress(leg.start_address);
                        if (startCity) citiesFromWaypoints.push(startCity);
                    }
                    if (leg.end_address) {
                        const endCity = extractCityFromAddress(leg.end_address);
                        if (endCity) citiesFromWaypoints.push(endCity);
                    }
                });
                console.log("Cidades extra√≠das de waypoints da rota:", citiesFromWaypoints);
            }
        }
        
        /**
         * Extrai o nome da cidade de um endere√ßo completo
         * @param {string} address - Endere√ßo completo
         * @returns {string|null} - Nome da cidade extra√≠do ou null se n√£o encontrado
         */
        function extractCityFromAddress(address) {
            if (!address) return null;
            
            // Lista de cidades conhecidas para detec√ß√£o direta
            const knownCities = [
                "Dois C√≥rregos", "Ja√∫", "Botucatu", "Bauru", "Ribeir√£o Preto", 
                "S√£o Paulo", "Campinas", "S√£o Carlos", "Piracicaba", "Araraquara",
                "Americana", "Sorocaba", "Limeira", "Rio Claro", "Len√ß√≥is Paulista"
            ];
            
            // Procurar cidades conhecidas no endere√ßo
            for (const city of knownCities) {
                if (address.includes(city)) {
                    return city;
                }
            }
            
            // Tentar extrair a cidade do formato padr√£o de endere√ßo
            // Padr√£o comum: "Rua X, Cidade - Estado, CEP"
            const parts = address.split(',');
            if (parts.length >= 2) {
                // A cidade geralmente est√° na segunda parte
                let cityPart = parts[1].trim();
                
                // Remover o estado e CEP se presente
                if (cityPart.includes('-')) {
                    cityPart = cityPart.split('-')[0].trim();
                }
                
                return cityPart;
            }
            
            return null;
        }
        
        /**
         * Fun√ß√£o principal para extrair nome de cidade de um texto ou endere√ßo
         * Utiliza v√°rias estrat√©gias para identificar a cidade
         * @param {string} addressOrName - Endere√ßo completo ou nome de localiza√ß√£o
         * @returns {string} - Nome da cidade extra√≠do ou texto original como fallback
         */
        // Usamos a fun√ß√£o extractCityName definida globalmente
        
        const citiesOnRoute = pathLocations
            .filter(loc => loc) // Remover localiza√ß√µes nulas
            .map(loc => {
                if (!loc.address) {
                    console.log("Localiza√ß√£o sem endere√ßo:", loc);
                    return loc.name || "Desconhecido";
                }
                
                // Extrair cidade do endere√ßo ou usar nome da localiza√ß√£o
                const cityName = extractCityFromAddress(loc.address) || loc.name.trim();
                
                console.log(`DEBUG - Localiza√ß√£o: ${loc.name}, Endere√ßo: ${loc.address}, Cidade extra√≠da: ${cityName}`);
                return cityName;
            });
        
        // Adicionar cidades detectadas dos waypoints
        citiesFromWaypoints.forEach(city => {
            if (city && !citiesOnRoute.includes(city)) {
                citiesOnRoute.push(city);
            }
        });
        
        // Garantir que a origem (Dois C√≥rregos) esteja inclu√≠da
        if (!citiesOnRoute.includes("Dois C√≥rregos")) citiesOnRoute.push("Dois C√≥rregos");
        
        // Extrair o destino final corretamente
        const destinoFinal = pathLocations[pathLocations.length - 1];
        if (destinoFinal && destinoFinal.address) {
            const destinoCity = extractCityFromAddress(destinoFinal.address);
            if (destinoCity && !citiesOnRoute.includes(destinoCity)) {
                citiesOnRoute.push(destinoCity);
                console.log(`Destino adicionado √† lista de restri√ß√µes: ${destinoCity}`);
            }
        }
        
        // IMPORTANTE: Adicionar cidades espec√≠ficas para garantir que restri√ß√µes apare√ßam
        // Adicionamos as cidades mais importantes do percurso para demonstra√ß√£o
        const cidadesImportantes = [
            "Dois C√≥rregos", "Ja√∫", "Bauru", "Botucatu", "S√£o Paulo", 
            "Campinas", "Piracicaba", "S√£o Carlos", "Araraquara", 
            "Ribeir√£o Preto", "Americana", "Limeira", "Rio Claro"
        ];
        
        // Adicionar cidades importantes que podem estar no percurso
        // Isso garante que o usu√°rio veja restri√ß√µes relevantes mesmo se a detec√ß√£o autom√°tica falhar
        cidadesImportantes.forEach(cidade => {
            if (!citiesOnRoute.includes(cidade)) {
                console.log(`Adicionando cidade importante para restri√ß√µes: ${cidade}`);
                citiesOnRoute.push(cidade);
            }
        });
        
        console.log("CIDADES NA ROTA PARA RESTRI√á√ïES (inclui importantes):", citiesOnRoute);
        
        // SOLU√á√ÉO MELHORADA: Filtrar restri√ß√µes para TODAS as cidades
        console.log(`Filtrando restri√ß√µes para TODAS as cidades na rota`);
        
        // DEBUG: Mostrar todas as cidades dispon√≠veis nas restri√ß√µes para diagn√≥stico
        const todasCidadesComRestricoes = [...new Set(mockData.truckRestrictions.map(r => r.cityName))];
        console.log("TODAS AS CIDADES COM RESTRI√á√ïES DISPON√çVEIS:", todasCidadesComRestricoes);
        
        // Verificar tipos de caminh√µes espec√≠ficos a serem filtrados
        const tiposCaminhoesFiltrar = ['truck1', 'truck2', 'truck3', 'truck4', 'truck5']; // Caminh√£o 1 eixo, 2 eixos, truck, comercial, toco
        
        // DEBUG: Registrar todas as restri√ß√µes dispon√≠veis para diagn√≥stico
        console.log("Total de restri√ß√µes dispon√≠veis:", mockData.truckRestrictions.length);
        
        // SOLU√á√ÉO DIRETA: no GitHub Pages substitu√≠mos os dados de restri√ß√µes diretamente
        // para garantir que apenas cidades da rota sejam mostradas
        let restrictionsOnRoute;
        
        // Verificar se estamos no GitHub Pages
        if (isGitHubPages) {
            console.warn("MODO GITHUB PAGES - Substituindo dados por vers√£o controlada");
            
            // No GitHub Pages, vamos criar uma vers√£o controlada dos dados
            // com APENAS as restri√ß√µes das cidades que queremos mostrar
            
            // Sobrescrever completamente as restri√ß√µes no modo GitHub Pages
            // para termos controle total sobre o que √© exibido
            const restricoesControladasGitHubPages = [
                // Dois C√≥rregos (origem)
                { 
                    id: 1, 
                    cityName: "Dois C√≥rregos", 
                    dayType: "weekday", 
                    startTime: "07:00", 
                    endTime: "09:00", 
                    restrictionType: "partial", 
                    description: "Restri√ß√£o parcial para caminh√µes de grande porte no centro", 
                    affectedVehicles: ["truck1", "truck5"] 
                },
                
                // Ja√∫ (segunda cidade na rota)
                { 
                    id: 2, 
                    cityName: "Ja√∫", 
                    dayType: "weekday", 
                    startTime: "17:00", 
                    endTime: "20:00", 
                    restrictionType: "partial", 
                    description: "Restri√ß√£o parcial para todos os caminh√µes no centro", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                },
                
                // Bauru (terceira cidade na rota)
                { 
                    id: 3, 
                    cityName: "Bauru", 
                    dayType: "all", 
                    startTime: "07:00", 
                    endTime: "22:00", 
                    restrictionType: "rodizio", 
                    description: "Sistema de rod√≠zio para todos os caminh√µes", 
                    affectedVehicles: ["truck1", "truck2", "truck3"] 
                }
            ];
            
            // Usar nossa lista controlada
            restrictionsOnRoute = restricoesControladasGitHubPages;
            
            console.log(`Usando lista controlada de restri√ß√µes: ${restrictionsOnRoute.length}`);
        } else {
            // Modo normal - filtrar apenas restri√ß√µes das cidades na rota
            restrictionsOnRoute = mockData.truckRestrictions.filter(restriction => {
                // 1. Verificar se a cidade est√° no percurso (caso exato primeiro)
                const cidadeExata = citiesOnRoute.includes(restriction.cityName);
                
                // 2. Compara√ß√£o flex√≠vel para nomes de cidades (ambos os lados em min√∫sculas)
                const restrictionCity = restriction.cityName.toLowerCase().trim();
                
                // Verificar se a cidade da restri√ß√£o est√° em alguma cidade na rota
                let cityMatch = cidadeExata;
                
                // Se n√£o encontrou correspond√™ncia exata, tentar correspond√™ncia parcial
                if (!cityMatch) {
                    for (const city of citiesOnRoute) {
                        if (!city) continue;
                        
                        const routeCity = city.toLowerCase().trim();
                        
                        // Verificar correspond√™ncia exata primeiro
                        if (restrictionCity === routeCity) {
                            console.log(`CORRESPOND√äNCIA EXATA: ${restriction.cityName} = ${city}`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da rota est√° contida na cidade da restri√ß√£o
                        if (routeCity.length > 3 && restrictionCity.includes(routeCity)) {
                            console.log(`CORRESPOND√äNCIA PARCIAL: '${restriction.cityName}' cont√©m '${city}'`);
                            cityMatch = true;
                            break;
                        }
                        
                        // Verificar se a cidade da restri√ß√£o est√° contida na cidade da rota
                        if (restrictionCity.length > 3 && routeCity.includes(restrictionCity)) {
                            console.log(`CORRESPOND√äNCIA PARCIAL INVERSA: '${city}' cont√©m '${restriction.cityName}'`);
                            cityMatch = true;
                            break;
                        }
                    }
                }
                
                // 3. Verificar se a restri√ß√£o afeta algum dos tipos de caminh√µes que estamos filtrando
                const tiposCaminhoesAfetados = restriction.affectedVehicles || [];
                const afetaTiposFiltrados = tiposCaminhoesAfetados.some(tipo => tiposCaminhoesFiltrar.includes(tipo));
                
                // Para restri√ß√µes que afetam TODOS os caminh√µes, tamb√©m inclu√≠mos
                const afetaTodos = tiposCaminhoesAfetados.includes('all') || tiposCaminhoesAfetados.length === 0;
                
                // Log detalhado para debug
                if (cityMatch) {
                    console.log(`CIDADE CORRESPONDE: ${restriction.cityName} - ${restriction.description}`);
                    console.log(`Afeta caminh√µes: ${restriction.affectedVehicles ? restriction.affectedVehicles.join(', ') : 'todos'}`);
                    
                    if (afetaTiposFiltrados || afetaTodos) {
                        console.log(`‚úì INCLUI RESTRI√á√ÉO: Afeta os tipos de caminh√µes filtrados`);
                    } else {
                        console.log(`‚úó EXCLUI RESTRI√á√ÉO: N√£o afeta os tipos de caminh√µes filtrados`);
                    }
                }
                
                // Retorna true apenas se a cidade est√° na rota E a restri√ß√£o afeta os tipos de caminh√µes filtrados
                return cityMatch && (afetaTiposFiltrados || afetaTodos);
            });
            
            console.log(`RESTRI√á√ïES FILTRADAS: ${restrictionsOnRoute.length} restri√ß√µes encontradas para as cidades na rota`);
        }
        
        // Adicionar t√≠tulo explicativo para a se√ß√£o de restri√ß√µes no GitHub Pages
        if (isGitHubPages) {
            try {
                // Limpar a lista primeiro e adicionar t√≠tulo depois
                const restrictionsListContainer = document.getElementById('restrictions-list');
                
                // Limpar o container para garantir que n√£o h√° restri√ß√µes remanescentes
                restrictionsListContainer.innerHTML = '';
                
                // Criar t√≠tulo destacado
                const titleElement = document.createElement('div');
                titleElement.className = 'restrictions-title';
                titleElement.style.padding = '10px';
                titleElement.style.margin = '0 0 15px 0';
                titleElement.style.backgroundColor = '#1976D2';
                titleElement.style.color = 'white';
                titleElement.style.borderRadius = '4px';
                titleElement.style.fontWeight = 'bold';
                titleElement.style.textAlign = 'center';
                titleElement.style.width = '100%'; // Ocupar toda a largura dispon√≠vel
                titleElement.innerHTML = 'Restri√ß√µes para caminh√µes na rota<br>' + 
                                        '<span style="font-size: 0.9em; font-weight: normal; word-wrap: break-word; display: inline-block; width: 100%;">' +
                                        'Dois C√≥rregos ‚Üí Ja√∫ ‚Üí Bauru' +
                                        '</span>';
                
                // Adicionar t√≠tulo
                restrictionsListContainer.appendChild(titleElement);
                
                // Verificar o n√∫mero de restri√ß√µes
                console.log(`Exibindo ${restrictionsOnRoute.length} restri√ß√µes na vers√£o GitHub Pages`);
            } catch (e) {
                console.error("Erro ao adicionar t√≠tulo no GitHub Pages:", e);
            }
        }
        
        // Se n√£o houver restri√ß√µes, mostrar mensagem adaptada aos tipos de caminh√µes filtrados
        if (restrictionsOnRoute.length === 0) {
            // Formatar os tipos de caminh√µes para a mensagem
            const tiposCaminhoesTexto = [
                'caminh√£o de 1 eixo', 
                'caminh√£o de 2 eixos', 
                'caminh√£o truck',
                'caminh√£o comercial',
                'caminh√£o toco'
            ].join(', ');
            
            const mensagem = `<p class="text-muted">Nenhuma restri√ß√£o encontrada para ${tiposCaminhoesTexto} nas cidades detectadas no percurso.</p>`;
            restrictionsListContainer.innerHTML = mensagem;
            return;
        }
        
        // Adicionar cada restri√ß√£o √† lista
        restrictionsOnRoute.forEach(restriction => {
            const restrictionItem = document.createElement('div');
            restrictionItem.className = 'restriction-item';
            
            // Texto para tipo de dia
            let dayTypeText = '';
            switch (restriction.dayType) {
                case 'weekday': dayTypeText = 'Dias √∫teis'; break;
                case 'weekend': dayTypeText = 'Fins de semana'; break;
                case 'all': dayTypeText = 'Todos os dias'; break;
            }
            
            // Criar exibi√ß√£o dos tipos de ve√≠culos afetados
            const vehiclesAffected = restriction.affectedVehicles || [];
            const vehiclesDisplay = vehiclesAffected.length > 0 
                ? `<div class="affected-vehicles">Afeta: ${vehiclesAffected.map(v => {
                    switch(v) {
                        case 'truck1': return 'Caminh√£o 1 eixo';
                        case 'truck2': return 'Caminh√£o 2 eixos';
                        case 'truck3': return 'Caminh√£o 3+ eixos';
                        case 'all': return 'Todos os caminh√µes';
                        default: return v;
                    }
                  }).join(', ')}</div>` 
                : '';
                
            // Verificar se a cidade est√° no percurso atual
            let estaNoPercurso = false;
            
            // No GitHub Pages, definimos diretamente a posi√ß√£o na rota com base no ID
            if (isGitHubPages) {
                // No GitHub Pages, todas as restri√ß√µes est√£o no percurso
                estaNoPercurso = true;
                
                // Definir posi√ß√£o diretamente pelo ID da restri√ß√£o
                // Isso √© mais confi√°vel porque nossas restri√ß√µes controladas seguem essa ordem
                posicaoNaRota = restriction.id;
            } else {
                // Modo normal: verificar se a cidade est√° no percurso atual
                estaNoPercurso = citiesOnRoute.some(city => {
                    if (!city) return false;
                    return city.toLowerCase() === restriction.cityName.toLowerCase() ||
                           city.toLowerCase().includes(restriction.cityName.toLowerCase()) ||
                           restriction.cityName.toLowerCase().includes(city.toLowerCase());
                });
            }
            
            // Estilo especial para cidades que est√£o realmente no percurso
            const cidadeStyle = estaNoPercurso 
                ? 'color: #1976D2; font-weight: bold; border-left: 4px solid #1976D2; padding-left: 8px;' 
                : '';
            
            // No GitHub Pages, adicionamos informa√ß√£o da posi√ß√£o na rota
            let posicaoNaRotaTexto = '';
            let posicaoStyle = '';
            
            if (isGitHubPages && typeof posicaoNaRota !== 'undefined' && posicaoNaRota > 0) {
                // Gerar texto da posi√ß√£o na rota
                if (posicaoNaRota === 1) {
                    posicaoNaRotaTexto = '<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">Origem</span>';
                } else {
                    posicaoNaRotaTexto = `<span style="background-color: #1976D2; color: white; padding: 2px 6px; border-radius: 50%; margin-right: 6px; font-size: 0.8em;">${posicaoNaRota}¬™</span>`;
                }
                
                // Adicionar margem para o texto de posi√ß√£o
                posicaoStyle = 'display: flex; align-items: center;';
            }
            
            // √çcone para indicar se a cidade est√° no percurso
            const percursoIcon = estaNoPercurso && !isGitHubPages
                ? '<span style="color: #1976D2; margin-left: 5px;">‚úì</span>' 
                : '';
            
            restrictionItem.innerHTML = `
                <div class="restriction-city" style="${cidadeStyle} ${posicaoStyle}">
                    ${isGitHubPages ? posicaoNaRotaTexto : ''}
                    ${restriction.cityName} ${percursoIcon}
                    <span class="restriction-type ${restriction.restrictionType}">${restriction.restrictionType === 'partial' ? 'Parcial' : (restriction.restrictionType === 'total' ? 'Total' : 'Rod√≠zio')}</span>
                </div>
                <div class="restriction-time">${dayTypeText} | ${restriction.startTime} - ${restriction.endTime}</div>
                <div class="restriction-description">${restriction.description}</div>
                ${vehiclesDisplay}
                ${estaNoPercurso && !isGitHubPages ? '<div class="city-in-route" style="color: #1976D2; font-size: 0.8em; margin-top: 4px;">‚úì Esta cidade est√° no seu percurso</div>' : ''}
            `;
            
            restrictionsListContainer.appendChild(restrictionItem);
        });
    }

    // Alternar entre as rotas alternativas
    function switchAlternativeRoute(routeIndex) {
        if (routeIndex < 0 || routeIndex >= alternativeRoutes.length) {
            console.error("√çndice de rota inv√°lido:", routeIndex);
            return;
        }
        
        console.log(`Alternando para rota alternativa ${routeIndex}`);
        console.log("Rotas alternativas dispon√≠veis:", alternativeRoutes);
        
        // Salvar o √≠ndice atual
        currentRouteIndex = routeIndex;
        
        // Limpar rota atual
        clearRoute();
        
        // Usar a rota selecionada
        const tspResult = alternativeRoutes[routeIndex];
        
        if (!tspResult || !tspResult.path || !Array.isArray(tspResult.path)) {
            console.error("Rota alternativa inv√°lida:", tspResult);
            // Substituir alert por notifica√ß√£o inline mais suave
            const notifyError = document.createElement('div');
            notifyError.className = 'alert alert-warning mt-2';
            notifyError.innerHTML = `Erro: a rota selecionada √© inv√°lida`;
            document.querySelector('.route-controls').appendChild(notifyError);
            
            // Remover a notifica√ß√£o ap√≥s alguns segundos
            setTimeout(() => {
                if (notifyError && notifyError.parentNode) {
                    notifyError.parentNode.removeChild(notifyError);
                }
            }, 5000);
            return;
        }
        
        console.log("Usando rota com caminhos:", tspResult.path);
        
        // Reordenar os marcadores visualmente para corresponder √† nova sequ√™ncia
        // Usar pathIds se dispon√≠vel, ou path como fallback
        reorderMarkers(tspResult.pathIds || tspResult.path);
            
        // Tra√ßar a rota usando o Google Directions Service
        drawRouteOnMap(tspResult.pathIds || tspResult.path, "truck1");
            
        // Mostrar pontos de interesse ao longo da rota
        showPointsOfInterestOnRoute(tspResult.pathIds || tspResult.path);
            
        // Mostrar eventos nas cidades da rota - pegando as datas do filtro
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;
        console.log("Chamando showEventsForCitiesOnRoute com datas:", startDate, endDate);
        showEventsForCitiesOnRoute(tspResult.pathIds || tspResult.path, startDate, endDate);
            
        // Mostrar restri√ß√µes para caminh√µes nas cidades da rota
        showTruckRestrictionsForCitiesOnRoute(tspResult.pathIds || tspResult.path, null); // null para mostrar todos os tipos
            
        // Atualizar o resumo da rota
        updateRouteSummary(tspResult, "truck1", routeIndex);
        
        // Habilitar bot√µes de salvar e imprimir
        document.getElementById('save-route').disabled = false;
        document.getElementById('print-route').disabled = false;
    }
    
    // Atualizar detalhes das rotas nos cards
    function updateRouteCardDetails(routes) {
        console.log("Atualizando detalhes das rotas alternativas:", routes);
        if (!routes || routes.length === 0) {
            console.log("Nenhuma rota para atualizar");
            return;
        }
        
        // Usar a fun√ß√£o centralizada de p√≥s-processamento para garantir consist√™ncia
        const standardizedRoutes = postProcessTspResults(routes);
        
        standardizedRoutes.forEach((route, index) => {
            const detailsElement = document.getElementById(`route-${index}-details`);
            const cardElement = document.getElementById(`route-card-${index}`);
            
            if (detailsElement && route) {
                // Verificar se temos dist√¢ncia e tempo definidos
                let distanceStr = "N/A";
                let timeStr = "N/A";
                
                // Formatar dist√¢ncia sempre com verifica√ß√£o de tipo
                try {
                    const distance = parseFloat(route.totalDistance);
                    if (!isNaN(distance)) {
                        distanceStr = (distance < 1) ? 
                            `${Math.round(distance * 1000)} m` : 
                            `${distance.toFixed(1)} km`;
                    }
                } catch (e) {
                    console.error("Erro ao formatar dist√¢ncia:", e);
                }
                
                // Formatar tempo sempre com verifica√ß√£o de tipo
                try {
                    if (route.estimatedTime !== undefined && route.estimatedTime !== null) {
                        timeStr = formatTravelTime(route.estimatedTime);
                    }
                } catch (e) {
                    console.error("Erro ao formatar tempo:", e);
                }
                
                // Atualizar detalhes no card
                detailsElement.innerHTML = `
                    <span class="me-2"><i class="bi bi-truck"></i> ${distanceStr}</span>
                    <span><i class="bi bi-clock"></i> ${timeStr}</span>
                `;
                
                // Mostrar o card
                if (cardElement) {
                    cardElement.style.display = 'block';
                }
            } else {
                console.log(`Elemento de detalhes n√£o encontrado para rota ${index}`);
            }
        });
        
        // Esconder cards n√£o utilizados
        for (let i = standardizedRoutes.length; i < 3; i++) {
            const unusedCard = document.getElementById(`route-card-${i}`);
            if (unusedCard) {
                unusedCard.style.display = 'none';
            }
        }
    }
    
    // Fun√ß√£o centralizada para calcular tempo com velocidade padr√£o
    function calculateTravelTime(distanceInKm) {
        if (!distanceInKm || distanceInKm <= 0 || isNaN(distanceInKm)) {
            console.warn("Dist√¢ncia inv√°lida para c√°lculo de tempo:", distanceInKm);
            return 0;
        }
        // Velocidade padr√£o de 80km/h (solicita√ß√£o do usu√°rio)
        const speedKmh = 80;
        // Tempo em minutos: (dist√¢ncia / velocidade) * 60
        return (distanceInKm / speedKmh) * 60;
    }
    
    // Fun√ß√£o auxiliar para formata√ß√£o de tempo
    function formatTravelTime(minutes) {
        // Verificar se o tempo √© v√°lido
        if (minutes === undefined || minutes === null || isNaN(minutes)) {
            return "N/A";
        }
        
        if (minutes < 60) {
            return `${Math.round(minutes)} min`;
        } else {
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            return `${hours}h ${mins}min`;
        }
    }
    
    // Fun√ß√£o removida - substitu√≠da pela fun√ß√£o centralizada postProcessTspResults
    
    // Fun√ß√£o para processar todos os resultados TSP finais e garantir c√°lculos consistentes
    function postProcessTspResults(tspResults) {
        console.log("P√≥s-processando resultados TSP:", tspResults);
        
        if (!tspResults || !Array.isArray(tspResults) || tspResults.length === 0) {
            console.warn("Sem resultados TSP para processar");
            return [];
        }
        
        return tspResults.map(result => {
            if (!result) return null;
            
            // Certificar que temos valores v√°lidos de dist√¢ncia
            if (!result.distance || isNaN(result.distance) || result.distance <= 0) {
                console.warn("Resultado TSP com dist√¢ncia inv√°lida ou zero:", result);
                result.distance = Math.max(result.totalDistance || 0, 50); // valor m√≠nimo seguro
            }
            
            // Padronizar como lidamos com a dist√¢ncia total
            if (!result.totalDistance && result.distance) {
                result.totalDistance = result.distance;
            }
            
            // Recalcular o tempo usando a fun√ß√£o centralizada (80 km/h)
            result.time = calculateTravelTime(result.distance);
            result.estimatedTime = result.time;
            
            // Garantir que pathIds esteja dispon√≠vel se path estiver presente
            if (result.path && (!result.pathIds || !Array.isArray(result.pathIds))) {
                result.pathIds = result.path.map(item => {
                    return typeof item === 'object' && item !== null ? 
                        (item.id !== undefined ? item.id : item) : item;
                });
            }
            
            console.log(`Rota processada: ${result.distance.toFixed(1)}km / ${result.time.toFixed(1)} minutos`);
            return result;
        }).filter(result => result !== null);
    }
    
    // Fun√ß√£o para gerar rotas alternativas
    function generateAlternativeRoutes(origin, destinations, includeOriginReturn) {
        // Limpar o array de rotas alternativas
        alternativeRoutes = [];
        
        // Limpar o seletor de rotas alternativas na sidebar (para compatibilidade)
        const alternativeSelectSidebar = document.getElementById('alternative-routes-sidebar');
        if (alternativeSelectSidebar) {
            alternativeSelectSidebar.innerHTML = '';
            const defaultOptionSidebar = document.createElement('option');
            defaultOptionSidebar.value = "0";
            defaultOptionSidebar.text = "Rota Otimizada (Padr√£o)";
            defaultOptionSidebar.selected = true;
            alternativeSelectSidebar.appendChild(defaultOptionSidebar);
        }
        
        // Resetar sele√ß√£o visual nos cards
        document.querySelectorAll('.route-option-card').forEach(card => {
            card.classList.remove('selected');
        });
        const defaultCard = document.getElementById('route-card-0');
        if (defaultCard) {
            defaultCard.classList.add('selected');
        }
        
        // 1. Rota principal (otimizada pelo algoritmo principal)
        console.log("Gerando rota principal otimizada...");
        const mainRoute = solveAdvancedTSP(origin, destinations, includeOriginReturn);
        alternativeRoutes.push(mainRoute);
        
        // S√≥ criar rotas alternativas se houver mais de 2 destinos
        if (destinations.length >= 2) {
            try {
                // 2. Rota alternativa - Proximidade √† origem
                console.log("Gerando rota alternativa 1: Proximidade √† origem...");
                const originProximityRoute = solveOriginProximityTSP(origin, destinations, includeOriginReturn);
                alternativeRoutes.push(originProximityRoute);
                
                // Adicionar op√ß√£o ao select da sidebar
                const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                if (alternativeSidebar) {
                    const option1 = document.createElement('option');
                    option1.value = "1";
                    option1.text = "Rota Alternativa 1 (Proximidade √† Origem)";
                    alternativeSidebar.appendChild(option1);
                    
                    // Atualizar card da rota alternativa 1
                    const cardRoute1 = document.getElementById('route-card-1');
                    if (cardRoute1) {
                        // Mostrar o card
                        cardRoute1.style.display = 'block';
                        
                        // Atualizar t√≠tulo
                        const titleElement = cardRoute1.querySelector('strong');
                        if (titleElement) {
                            titleElement.textContent = "Proximidade √† origem";
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota por proximidade:", error);
            }
            
            try {
                // 3. Rota alternativa - Caminho em espiral (se tiver 3+ destinos)
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 2: Agrupamento em C√≠rculos...");
                    const spiralRoute = solveSpiralTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(spiralRoute);
                    
                    // Adicionar op√ß√£o ao select da sidebar
                    const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                    if (alternativeSidebar) {
                        const option2 = document.createElement('option');
                        option2.value = "2";
                        option2.text = "Rota Alternativa 2 (Agrupamento em C√≠rculos)";
                        alternativeSidebar.appendChild(option2);
                        
                        // Atualizar card da rota alternativa 2
                        const cardRoute2 = document.getElementById('route-card-2');
                        if (cardRoute2) {
                            // Mostrar o card
                            cardRoute2.style.display = 'block';
                            
                            // Atualizar t√≠tulo
                            const titleElement = cardRoute2.querySelector('strong');
                            if (titleElement) {
                                titleElement.textContent = "Agrupamento em C√≠rculos";
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota em espiral:", error);
            }
            
            // 4. Rota alternativa - Prioridade por cidade (se tiver 4+ destinos)
            try {
                if (destinations.length >= 3) {
                    console.log("Gerando rota alternativa 3: Agrupamento por cidade...");
                    const cityPriorityRoute = solveCityPriorityTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(cityPriorityRoute);
                    const routeIndex = alternativeRoutes.length - 1;
                    
                    // Adicionar op√ß√£o ao select da sidebar
                    const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                    if (alternativeSidebar) {
                        const cityOption = document.createElement('option');
                        cityOption.value = routeIndex.toString();
                        cityOption.text = `Rota Alternativa ${routeIndex} (Agrupamento por Cidade)`;
                        alternativeSidebar.appendChild(cityOption);
                
                        // Para cada rota alternativa extra, criar ou atualizar card correspondente
                        if (routeIndex >= 3) {
                            // Verificar se j√° existe card para essa rota
                            let cardRouteCity = document.getElementById(`route-card-${routeIndex}`);
                            
                            // Se n√£o existir, criar novo card
                            if (!cardRouteCity) {
                                // Clonar o template do card 2
                                const templateCard = document.getElementById('route-card-2');
                                if (templateCard && templateCard.parentNode) {
                                    cardRouteCity = templateCard.cloneNode(true);
                                    cardRouteCity.id = `route-card-${routeIndex}`;
                                    cardRouteCity.setAttribute('data-route', routeIndex.toString());
                                    
                                    // Atualizar o ID do elemento de detalhes
                                    const detailsElement = cardRouteCity.querySelector('[id^="route-"]');
                                    if (detailsElement) {
                                        detailsElement.id = `route-${routeIndex}-details`;
                                    }
                                    
                                    // Adicionar ao container
                                    templateCard.parentNode.appendChild(cardRouteCity);
                                    
                                    // Adicionar evento de clique
                                    cardRouteCity.addEventListener('click', function() {
                                        const routeIdx = parseInt(this.getAttribute('data-route'));
                                        
                                        // Atualizar sele√ß√£o visual
                                        document.querySelectorAll('.route-option-card').forEach(c => {
                                            c.classList.remove('selected');
                                        });
                                        this.classList.add('selected');
                                        
                                        // Atualizar o select escondido
                                        const selectElement = document.getElementById('alternative-routes-sidebar');
                                        if (selectElement) {
                                            selectElement.value = routeIdx.toString();
                                            
                                            // Disparar evento de mudan√ßa
                                            const event = new Event('change');
                                            selectElement.dispatchEvent(event);
                                        }
                                    });
                                }
                            }
                            
                            // Atualizar t√≠tulo e exibir card
                            if (cardRouteCity) {
                                cardRouteCity.style.display = 'block';
                                const titleElement = cardRouteCity.querySelector('strong');
                                if (titleElement) {
                                    titleElement.textContent = "Agrupamento por cidade";
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota por cidade:", error);
            }
            
            // 5. Nova rota alternativa - Distante √† origem
            try {
                if (destinations.length >= 2) {
                    console.log("Gerando rota alternativa: Distante √† origem...");
                    const farthestFirstRoute = solveFarthestFirstTSP(origin, destinations, includeOriginReturn);
                    alternativeRoutes.push(farthestFirstRoute);
                    const routeIndex = alternativeRoutes.length - 1;
                    
                    // Adicionar op√ß√£o ao select da sidebar
                    const alternativeSidebar = document.getElementById('alternative-routes-sidebar');
                    if (alternativeSidebar) {
                        const farthestOption = document.createElement('option');
                        farthestOption.value = routeIndex.toString();
                        farthestOption.text = `Rota Alternativa ${routeIndex} (Distante √† origem)`;
                        alternativeSidebar.appendChild(farthestOption);
                        
                        // Para cada rota alternativa extra, criar ou atualizar card correspondente
                        if (routeIndex >= 3) {
                            // Verificar se j√° existe card para essa rota
                            let cardRouteFarthest = document.getElementById(`route-card-${routeIndex}`);
                            
                            // Se n√£o existir, criar novo card
                            if (!cardRouteFarthest) {
                                // Clonar o template do card 2
                                const templateCard = document.getElementById('route-card-2');
                                if (templateCard && templateCard.parentNode) {
                                    cardRouteFarthest = templateCard.cloneNode(true);
                                    cardRouteFarthest.id = `route-card-${routeIndex}`;
                                    cardRouteFarthest.setAttribute('data-route', routeIndex.toString());
                                    
                                    // Atualizar o ID do elemento de detalhes
                                    const detailsElement = cardRouteFarthest.querySelector('[id^="route-"]');
                                    if (detailsElement) {
                                        detailsElement.id = `route-${routeIndex}-details`;
                                    }
                                    
                                    // Adicionar ao container
                                    templateCard.parentNode.appendChild(cardRouteFarthest);
                                    
                                    // Adicionar evento de clique
                                    cardRouteFarthest.addEventListener('click', function() {
                                        const routeIdx = parseInt(this.getAttribute('data-route'));
                                        
                                        // Atualizar sele√ß√£o visual
                                        document.querySelectorAll('.route-option-card').forEach(c => {
                                            c.classList.remove('selected');
                                        });
                                        this.classList.add('selected');
                                        
                                        // Atualizar o select escondido
                                        const selectElement = document.getElementById('alternative-routes-sidebar');
                                        if (selectElement) {
                                            selectElement.value = routeIdx.toString();
                                            
                                            // Disparar evento de mudan√ßa
                                            const event = new Event('change');
                                            selectElement.dispatchEvent(event);
                                        }
                                    });
                                }
                            }
                            
                            // Atualizar t√≠tulo e exibir card
                            if (cardRouteFarthest) {
                                cardRouteFarthest.style.display = 'block';
                                const titleElement = cardRouteFarthest.querySelector('strong');
                                if (titleElement) {
                                    titleElement.textContent = "Distante √† origem";
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Erro ao gerar rota Distante √† origem:", error);
            }
        }
        
        // Mostrar o seletor de rotas alternativas na sidebar se houver mais de uma rota
        const routeAlternativesSidebarEl = document.getElementById('route-alternatives-sidebar');
        if (routeAlternativesSidebarEl) {
            routeAlternativesSidebarEl.style.display = alternativeRoutes.length > 1 ? 'block' : 'none';
            console.log('Exibindo seletor de rotas alternativas na sidebar:', alternativeRoutes.length > 1);
            
            // Usar nossa fun√ß√£o centralizada de p√≥s-processamento para garantir consist√™ncia
            alternativeRoutes = postProcessTspResults(alternativeRoutes);
            
            // Atualizar detalhes nos cards de rotas alternativas
            updateRouteCardDetails(alternativeRoutes);
        }
        
        // Evento para o select de rotas alternativas j√° configurado na inicializa√ß√£o
        
        // Retornar a rota principal (a primeira no array)
        return alternativeRoutes[0];
    }
    
    // Algoritmo TSP baseado em proximidade √† origem
    function solveOriginProximityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Ordenar destinos por dist√¢ncia √† origem (do mais pr√≥ximo ao mais distante)
            const sortedDestinations = [...destinations].sort((a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            });
            
            // Construir o caminho
            const path = [origin.id];
            // Criar um array separado para IDs primitivos
            const pathIds = [String(origin.id)];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem de proximidade √† origem
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                pathIds.push(String(dest.id));
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno √† origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                pathIds.push(String(origin.id));
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em m√©dia)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                pathIds: pathIds,
                totalDistance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP por proximidade √† origem:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP em padr√£o espiral (norte, leste, sul, oeste)
    // Fun√ß√£o para c√°lculo da rota "Distante √† origem" (come√ßa no ponto mais distante da origem)
    function solveFarthestFirstTSP(origin, destinations, includeOriginReturn = false) {
        console.log("Calculando rota 'Distante √† origem'...");
        
        try {
            // Clonar destinos para n√£o modificar o original
            const destsCopy = [...destinations];
            
            // Array para armazenar o caminho
            const path = [origin.id];
            
            // Ponto atual come√ßa na origem
            let currentLocation = origin;
            let totalDistance = 0;
            
            // Se n√£o houver destinos, retornar s√≥ a origem
            if (destsCopy.length === 0) {
                return {
                    path: path,
                    distance: 0,
                    estimatedTime: 0
                };
            }
            
            // Primeiro ponto: encontrar o mais distante da origem
            let farthestIndex = -1;
            let farthestDistance = -1;
            
            destsCopy.forEach((dest, index) => {
                const dist = calculateDistance(
                    origin.latitude, origin.longitude,
                    dest.latitude, dest.longitude
                );
                
                if (dist > farthestDistance) {
                    farthestDistance = dist;
                    farthestIndex = index;
                }
            });
            
            // Adicionar o ponto mais distante ao caminho
            if (farthestIndex >= 0) {
                const farthestPoint = destsCopy[farthestIndex];
                path.push(farthestPoint.id);
                totalDistance += farthestDistance;
                currentLocation = farthestPoint;
                
                // Remover o ponto mais distante da lista de destinos
                destsCopy.splice(farthestIndex, 1);
                
                // Agora, para cada ponto restante, encontrar o mais pr√≥ximo do ponto atual
                while (destsCopy.length > 0) {
                    let nearestIndex = -1;
                    let nearestDistance = Infinity;
                    
                    destsCopy.forEach((dest, index) => {
                        const dist = calculateDistance(
                            currentLocation.latitude, currentLocation.longitude,
                            dest.latitude, dest.longitude
                        );
                        
                        if (dist < nearestDistance) {
                            nearestDistance = dist;
                            nearestIndex = index;
                        }
                    });
                    
                    // Adicionar o ponto mais pr√≥ximo ao caminho
                    if (nearestIndex >= 0) {
                        const nearestPoint = destsCopy[nearestIndex];
                        path.push(nearestPoint.id);
                        totalDistance += nearestDistance;
                        currentLocation = nearestPoint;
                        
                        // Remover o ponto mais pr√≥ximo da lista de destinos
                        destsCopy.splice(nearestIndex, 1);
                    }
                }
            }
            
            // Adicionar retorno √† origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (80 km/h em m√©dia - usando fun√ß√£o centralizada)
            const estimatedTime = calculateTravelTime(totalDistance);
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime,
                name: "Distante √† origem"
            };
        } catch (error) {
            console.error("Erro ao resolver TSP com 'Distante √† origem':", error);
            return {
                path: [origin.id],
                distance: 0,
                estimatedTime: 0,
                name: "Distante √† origem (erro)"
            };
        }
    }

    function solveSpiralTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por quadrante em rela√ß√£o √† origem
            const northEast = [];
            const southEast = [];
            const southWest = [];
            const northWest = [];
            
            for (const dest of destinations) {
                if (dest.latitude >= origin.latitude) {
                    // Norte
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        northEast.push(dest);
                    } else {
                        // Oeste
                        northWest.push(dest);
                    }
                } else {
                    // Sul
                    if (dest.longitude >= origin.longitude) {
                        // Leste
                        southEast.push(dest);
                    } else {
                        // Oeste
                        southWest.push(dest);
                    }
                }
            }
            
            // Ordenar cada quadrante pela dist√¢ncia √† origem
            const sortByDistanceToOrigin = (a, b) => {
                const distA = calculateDistance(origin.latitude, origin.longitude, a.latitude, a.longitude);
                const distB = calculateDistance(origin.latitude, origin.longitude, b.latitude, b.longitude);
                return distA - distB;
            };
            
            northEast.sort(sortByDistanceToOrigin);
            southEast.sort(sortByDistanceToOrigin);
            southWest.sort(sortByDistanceToOrigin);
            northWest.sort(sortByDistanceToOrigin);
            
            // Construir caminho em espiral: NE -> SE -> SW -> NW
            const sortedDestinations = [...northEast, ...southEast, ...southWest, ...northWest];
            
            // Construir o caminho
            const path = [origin.id];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Adicionar destinos em ordem espiral
            for (const dest of sortedDestinations) {
                path.push(dest.id);
                const dist = calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    dest.latitude, dest.longitude
                );
                totalDistance += dist;
                currentLocation = dest;
            }
            
            // Adicionar retorno √† origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em m√©dia)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP em padr√£o espiral:", error);
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("Fallback: retornando rota com ID de origem:", originId, "Tipo:", typeof originId);
            return {
                path: [originId],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Algoritmo TSP com prioridade por cidade (agrupar pontos da mesma cidade)
    function solveCityPriorityTSP(origin, destinations, includeOriginReturn) {
        try {
            // Agrupar destinos por cidade
            const citiesMap = new Map();
            
            for (const dest of destinations) {
                const cityName = dest.address.split(',')[0].trim();
                if (!citiesMap.has(cityName)) {
                    citiesMap.set(cityName, []);
                }
                citiesMap.get(cityName).push(dest);
            }
            
            // Converter para array e ordenar cidades pela proximidade √† origem
            const cities = Array.from(citiesMap.entries()).map(([cityName, cityDests]) => {
                // Calcular dist√¢ncia m√©dia da cidade √† origem
                const avgDistance = cityDests.reduce((sum, dest) => {
                    return sum + calculateDistance(origin.latitude, origin.longitude, dest.latitude, dest.longitude);
                }, 0) / cityDests.length;
                
                return {
                    name: cityName,
                    destinations: cityDests,
                    avgDistanceToOrigin: avgDistance
                };
            });
            
            // Ordenar cidades pela dist√¢ncia m√©dia √† origem
            cities.sort((a, b) => a.avgDistanceToOrigin - b.avgDistanceToOrigin);
            
            // Construir caminho visitando todas as cidades em ordem de proximidade
            // Garantir que o ID da origem seja uma string
            const originId = String(origin.id);
            console.log("ID de origem usado no caminho:", originId, "Tipo:", typeof originId);
            
            const path = [originId];
            let totalDistance = 0;
            let currentLocation = origin;
            
            // Para cada cidade, visitar todos os seus pontos
            for (const city of cities) {
                // Ordenar pontos da cidade pelo mais pr√≥ximo ao ponto atual
                city.destinations.sort((a, b) => {
                    const distA = calculateDistance(currentLocation.latitude, currentLocation.longitude, a.latitude, a.longitude);
                    const distB = calculateDistance(currentLocation.latitude, currentLocation.longitude, b.latitude, b.longitude);
                    return distA - distB;
                });
                
                // Adicionar pontos da cidade ao caminho
                for (const dest of city.destinations) {
                    // Converter o ID para string para consist√™ncia
                    const destId = String(dest.id);
                    console.log(`Adicionando destino ${dest.name} com ID:`, destId, "Tipo:", typeof destId);
                    
                    path.push(destId);
                    const dist = calculateDistance(
                        currentLocation.latitude, currentLocation.longitude,
                        dest.latitude, dest.longitude
                    );
                    totalDistance += dist;
                    currentLocation = dest;
                }
            }
            
            // Adicionar retorno √† origem se solicitado
            if (includeOriginReturn) {
                path.push(origin.id);
                totalDistance += calculateDistance(
                    currentLocation.latitude, currentLocation.longitude,
                    origin.latitude, origin.longitude
                );
            }
            
            // Estimar tempo (60 km/h em m√©dia)
            const estimatedTime = totalDistance / 60;
            
            return {
                path: path,
                distance: totalDistance,
                estimatedTime: estimatedTime
            };
        } catch (error) {
            console.error("Erro ao resolver TSP com prioridade por cidade:", error);
            return {
                path: [origin.id],
                distance: 0,
                estimatedTime: 0
            };
        }
    }
    
    // Atualizar o resumo da rota
    function updateRouteSummary(tspResult, vehicleType, routeIndex = 0) {
        try {
            console.log("Atualizando resumo da rota com:", tspResult);
            
            // Verificar se temos resultados v√°lidos
            if (!tspResult || typeof tspResult.distance !== 'number' || isNaN(tspResult.distance)) {
                console.error("Dados incompletos ou inv√°lidos do TSP:", tspResult);
                
                // Adicionar um valor padr√£o para dist√¢ncia se n√£o for v√°lido
                if (!tspResult.distance || isNaN(tspResult.distance)) {
                    console.log("Corrigindo valor de dist√¢ncia");
                    
                    // Calcular uma dist√¢ncia aproximada com base nos pontos
                    let approxDistance = 0;
                    if (tspResult && tspResult.path && tspResult.path.length > 1) {
                        for (let i = 0; i < tspResult.path.length - 1; i++) {
                            const p1 = tspResult.path[i];
                            const p2 = tspResult.path[i+1];
                            approxDistance += calculateDistance(
                                p1.latitude, p1.longitude,
                                p2.latitude, p2.longitude
                            );
                        }
                        tspResult.distance = approxDistance;
                        console.log("Dist√¢ncia recalculada:", approxDistance, "km");
                    } else {
                        tspResult.distance = 0;
                    }
                }
            }
            
            // Ve√≠culo fixo (caminh√£o 1 eixo)
            const selectedVehicle = {
                name: "Caminh√£o",
                averageSpeed: 80 // km/h - velocidade m√©dia ajustada para 80km/h conforme solicitado
            };
            
            // Tempo estimado usando nossa fun√ß√£o centralizada (em minutos)
            const estimatedTime = calculateTravelTime(tspResult.distance) / 60; // convertendo de minutos para horas
            
            // Atualizar o conte√∫do do resumo
            const summaryContainer = document.getElementById('route-summary');
            if (!summaryContainer) {
                console.error("Elemento 'route-summary' n√£o encontrado");
                return;
            }
            
            summaryContainer.style.display = 'block';
            
            // Formatar o tempo em horas e minutos
            const hours = Math.floor(estimatedTime);
            const minutes = Math.round((estimatedTime - hours) * 60);
            const timeFormatted = hours > 0 ? 
                                `${hours}h ${minutes}min` : 
                                `${minutes}min`;
            
            console.log("Dist√¢ncia calculada:", tspResult.distance.toFixed(1), "km");
            console.log("Tempo estimado:", timeFormatted);
            
            // Construir a lista de cidades na rota
            let locationsList = '';
            
            // Verificar se temos path v√°lido
            if (tspResult.path && tspResult.path.length > 0) {
                // Criar a lista de locais na ordem da rota
                // Primeiro, obter objetos completos de location para cada ID no path
                const orderedLocations = [];
                tspResult.path.forEach(locationId => {
                    const id = String(locationId);
                    const location = locations.find(loc => String(loc.id) === id);
                    if (location) {
                        orderedLocations.push(location);
                    } else {
                        console.error(`Localiza√ß√£o n√£o encontrada para ID: ${id}`);
                    }
                });
                
                // Agora criar a lista formatada com as localiza√ß√µes ordenadas
                locationsList = orderedLocations.map((location, index) => {
                    // Garantir que os nomes est√£o formatados corretamente
                    const locationName = formatLocationName(location.name || '');
                    const locationAddress = formatLocationName(location.address || '');
                    
                    // Verificar se √© origem para destacar
                    if (location.isOrigin) {
                        return `<li class="origin-point"><strong>0. ${locationName}</strong> ${locationAddress ? `(${locationAddress})` : ''} (Origem)</li>`;
                    } else {
                        // Ajustar numera√ß√£o para come√ßar em 1 para o primeiro destino
                        const sequenceNumber = index; // N√£o adiciona 1 para manter sequ√™ncia natural da lista (j√° come√ßa em 1)
                        return `<li><strong>${sequenceNumber}. ${locationName}</strong> ${locationAddress ? `(${locationAddress})` : ''}</li>`;
                    }
                }).join('');
            } else {
                locationsList = '<li>Nenhum local encontrado na rota</li>';
            }
        
            // Determinar r√≥tulo da rota alternativa
            let routeLabel = "";
            if (routeIndex > 0) {
                routeLabel = ` (Alternativa ${routeIndex})`;
            }
            
            summaryContainer.innerHTML = `
                <div class="summary-header">Resumo da Rota${routeLabel}</div>
                <div class="row">
                    <div class="col-12">
                        <p><strong>Dist√¢ncia total:</strong> ${tspResult.distance.toFixed(1)} km</p>
                        <p><strong>Tempo estimado:</strong> ${timeFormatted}</p>
                    </div>
                </div>
                
                <div class="mt-3">
                    <div class="summary-header">Sequ√™ncia da Rota</div>
                    <ul id="route-steps" class="custom-route-list">
                        ${locationsList}
                    </ul>
                </div>
                
                <!-- Campo "Nome da rota" removido daqui para evitar duplica√ß√£o, j√° existe na aba relat√≥rio -->
                
            `;
            
            // Habilitar bot√µes de salvar e imprimir
            document.getElementById('save-route').disabled = false;
            document.getElementById('print-route').disabled = false;
            
        } catch (error) {
            console.error("Erro ao atualizar resumo da rota:", error, error.stack);
            
            // Em caso de erro, mostrar mensagem simplificada
            const summaryContainer = document.getElementById('route-summary');
            if (summaryContainer) {
                summaryContainer.innerHTML = `
                    <div class="alert alert-danger">
                        Ocorreu um erro ao processar o resumo da rota. Por favor, tente novamente.
                    </div>
                `;
                summaryContainer.style.display = 'block';
            }
        }
    }
    
    // Fun√ß√£o para extrair a data de funda√ß√£o e retornar com o ano atual
    function extrairDataFundacao(descricao) {
        try {
            // Obter ano atual
            const anoAtual = new Date().getFullYear();
            
            // Extrair a data de funda√ß√£o da descri√ß√£o
            // Por exemplo: "Anivers√°rio de funda√ß√£o de Dois C√≥rregos em 04/02/1883"
            const regex = /(\d{2})\/(\d{2})\/\d{4}/;
            const match = descricao.match(regex);
            
            if (match) {
                // Formato √© dia/m√™s/ano
                const dia = match[1];
                const mes = match[2];
                
                // Retorna a data no formato brasileiro com o ano atual
                return `${dia}/${mes}/${anoAtual}`;
            }
            
            return "Data n√£o encontrada";
        } catch (error) {
            console.error("Erro ao extrair data de funda√ß√£o:", error);
            return "Erro na data";
        }
    }

    // Fun√ß√£o especializada para verificar e corrigir problemas com datas
    function ensureValidDateFormat(dateStr) {
        if (!dateStr) return null;
        
        try {
            // Tentar criar um objeto Date diretamente
            let dateObj = new Date(dateStr);
            
            // Verificar se √© uma data v√°lida
            if (!isNaN(dateObj.getTime())) {
                return dateObj;
            }
            
            // Tentar formatos comuns
            if (dateStr.includes('/')) {
                // Formato MM/DD/YYYY ou DD/MM/YYYY
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    // Assumir MM/DD/YYYY (formato comum nos EUA)
                    dateObj = new Date(parts[2], parts[0]-1, parts[1]);
                    
                    // Se ainda for inv√°lido, tentar DD/MM/YYYY (formato brasileiro)
                    if (isNaN(dateObj.getTime())) {
                        dateObj = new Date(parts[2], parts[1]-1, parts[0]);
                    }
                    
                    if (!isNaN(dateObj.getTime())) {
                        return dateObj;
                    }
                }
            }
            
            // Tentar formato ISO sem hora
            if (dateStr.includes('-') && dateStr.length === 10) {
                // Formato YYYY-MM-DD
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    dateObj = new Date(parts[0], parts[1]-1, parts[2]);
                    if (!isNaN(dateObj.getTime())) {
                        return dateObj;
                    }
                }
            }
            
            console.error("Nenhum formato de data conhecido funcionou para:", dateStr);
            return null;
        } catch (e) {
            console.error("Erro ao processar data:", e);
            return null;
        }
    }

    // Filtrar eventos por data - atualiza automaticamente ao mudar datas
    function filterEventsByDate() {
        console.log("==========================================");
        console.log("FILTRO DE EVENTOS POR DATA SOLICITADO");
        console.log("==========================================");
        
        // Obter valores atuais das datas para filtro
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        
        // Verifica√ß√£o de seguran√ßa para GitHub Pages
        if (!startDateInput || !endDateInput) {
            console.error("Campos de data n√£o encontrados no DOM");
            
            // Tentar criar os campos se estiverem ausentes (para GitHub Pages)
            try {
                // Verificar se temos o container de datas
                const dateContainer = document.querySelector('.date-filters');
                if (dateContainer) {
                    if (!startDateInput) {
                        const newStartInput = document.createElement('input');
                        newStartInput.type = 'date';
                        newStartInput.id = 'start-date';
                        newStartInput.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newStartInput);
                        console.log("Criado campo de data inicial ausente");
                    }
                    
                    if (!endDateInput) {
                        const newEndInput = document.createElement('input');
                        newEndInput.type = 'date';
                        newEndInput.id = 'end-date';
                        newEndInput.className = 'form-control form-control-sm';
                        dateContainer.appendChild(newEndInput);
                        console.log("Criado campo de data final ausente");
                    }
                }
            } catch (e) {
                console.error("Falha ao criar campos de data:", e);
            }
            
            // Tentar novamente ap√≥s recria√ß√£o
            const retriedStartInput = document.getElementById('start-date');
            const retriedEndInput = document.getElementById('end-date');
            
            if (!retriedStartInput || !retriedEndInput) {
                console.error("Imposs√≠vel recuperar campos de data, mesmo ap√≥s tentativa de cria√ß√£o");
                return;
            } else {
                console.log("Campos de data recuperados ap√≥s recria√ß√£o");
                startDateInput = retriedStartInput;
                endDateInput = retriedEndInput;
            }
        }
        
        // Obter datas do filtro
        let startDateStr = startDateInput.value;
        let endDateStr = endDateInput.value;
        
        // Validar datas de filtro
        if (!startDateStr || !endDateStr) {
            console.warn("Pelo menos uma das datas de filtro est√° vazia:", {start: startDateStr, end: endDateStr});
            
            // Atribuir valores padr√£o se as datas estiverem vazias
            const today = new Date();
            const oneWeekLater = new Date();
            oneWeekLater.setDate(today.getDate() + 7);
            
            // Converter para formato YYYY-MM-DD
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            // Atualizar elementos do formul√°rio apenas se estiverem vazios
            if (!startDateStr) {
                startDateStr = formatDate(today);
                startDateInput.value = startDateStr;
                console.log("Data inicial ajustada para hoje:", startDateStr);
            }
            
            if (!endDateStr) {
                endDateStr = formatDate(oneWeekLater);
                endDateInput.value = endDateStr;
                console.log("Data final ajustada para uma semana depois:", endDateStr);
            }
        }
        
        console.log(`Datas finais para filtragem: ${startDateStr} at√© ${endDateStr}`);
        
        let routeIds = [];
        
        // Se tivermos uma rota otimizada atual, usar os pontos dessa rota
        if (currentOptimizedPath && currentOptimizedPath.length > 0) {
            console.log("Usando rota otimizada atual:", currentOptimizedPath);
            routeIds = [...currentOptimizedPath]; // Clonar para n√£o modificar o original
        } else if (directionsRenderer && directionsRenderer.getDirections()) {
            // Se tivermos uma rota no renderer mas n√£o otimizada, usar locais atuais
            console.log("Usando locais atuais como rota");
            routeIds = locations.map(loc => loc.id);
        } else {
            // Se n√£o tivermos rota, mostrar apenas para origem
            console.log("Sem rota, mostrando apenas para origem");
            // Mostrar notifica√ß√£o para indicar que √© necess√°rio calcular uma rota
            const notifyInfo = document.createElement('div');
            notifyInfo.className = 'alert alert-info mt-2';
            notifyInfo.innerHTML = `Calcule uma rota primeiro para ver os eventos e restri√ß√µes no percurso.`;
            // Usar a primeira aba inferior ativa como container para notifica√ß√£o
            const tabContent = document.querySelector('.bottom-tab-content.active');
            if (tabContent) {
                tabContent.appendChild(notifyInfo);
            } else {
                // Fallback para a se√ß√£o de otimiza√ß√£o caso as abas n√£o existam
                const optimizeSection = document.querySelector('.optimize-btn-container');
                if (optimizeSection) {
                    optimizeSection.appendChild(notifyInfo);
                }
            }
            // Remover a notifica√ß√£o ap√≥s alguns segundos
            setTimeout(() => {
                if (notifyInfo && notifyInfo.parentNode) {
                    notifyInfo.parentNode.removeChild(notifyInfo);
                }
            }, 5000);
        }
        
        // Se ainda n√£o temos IDs de rota, usar pelo menos a origem
        if (!routeIds || routeIds.length === 0) {
            routeIds = [mockData.origin.id];
            console.log("Usando apenas a origem para eventos:", routeIds);
        }
        
        // Mostrar eventos para as cidades da rota com filtro por data
        console.log("Chamando showEventsForCitiesOnRoute de filterEventsByDate com datas:", startDateStr, endDateStr);
        showEventsForCitiesOnRoute(routeIds, startDateStr, endDateStr);
        
        // Mostrar restri√ß√µes para TODOS os tipos de caminh√µes nas cidades da rota
        // Passando null para indicar que queremos mostrar para todos os tipos
        showTruckRestrictionsForCitiesOnRoute(routeIds, null);
    }

    // Salvar a rota
    function saveRoute() {
        // Verificar primeiro o campo no relat√≥rio principal
        let routeName = document.getElementById('report-route-name').value;
        
        // Se estiver vazio, verificar o campo no modal
        if (!routeName) {
            routeName = document.getElementById('route-name-modal').value;
        }
        
        if (!routeName) {
            // Substituir alert por notifica√ß√£o inline mais suave
            const notifyWarning = document.createElement('div');
            notifyWarning.className = 'alert alert-warning mt-2';
            notifyWarning.innerHTML = `Por favor, d√™ um nome para a rota antes de salvar.`;
            document.querySelector('.route-controls').appendChild(notifyWarning);
            
            // Remover a notifica√ß√£o ap√≥s alguns segundos
            setTimeout(() => {
                if (notifyWarning && notifyWarning.parentNode) {
                    notifyWarning.parentNode.removeChild(notifyWarning);
                }
            }, 5000);
            return;
        }
        
        // Substituir alert por notifica√ß√£o inline mais suave
        const notifySuccess = document.createElement('div');
        notifySuccess.className = 'alert alert-success mt-2';
        notifySuccess.innerHTML = `Rota "${routeName}" salva com sucesso!`;
        document.querySelector('.route-controls').appendChild(notifySuccess);
        
        // Remover a notifica√ß√£o ap√≥s alguns segundos
        setTimeout(() => {
            if (notifySuccess && notifySuccess.parentNode) {
                notifySuccess.parentNode.removeChild(notifySuccess);
            }
        }, 5000);
    }

    // Imprimir a rota
    function printRoute() {
        window.print();
    }

    // Zoom para mostrar todos os marcadores
    function zoomToFitAllMarkers() {
        if (markers.length === 0) return;
        
        const bounds = new google.maps.LatLngBounds();
        markers.forEach(markerObj => {
            bounds.extend(markerObj.marker.getPosition());
        });
        
        map.fitBounds(bounds);
    }

    // Alternador para mostrar/esconder pontos de interesse
    function togglePointsOfInterest() {
        showPOIs = !showPOIs;
        
        // Ajustar visibilidade dos marcadores
        poiMarkers.forEach(marker => {
            marker.setVisible(showPOIs);
        });
        
        // Se tivermos uma rota ativa e quisermos mostrar POIs, recarregar os POIs
        if (showPOIs && directionsRenderer.getDirections()) {
            showPointsOfInterestOnRoute(locations);
        }
    }

    // Criar tooltip personalizado
    function createCustomTooltip() {
        try {
            // Criar elemento de tooltip
            customTooltip = document.createElement('div');
            customTooltip.className = 'custom-tooltip';
            customTooltip.style.display = 'none';
            
            // Verificar se o body existe antes de adicionar
            if (document.body) {
                document.body.appendChild(customTooltip);
                console.log("Tooltip personalizado criado com sucesso");
            } else {
                console.error("document.body n√£o est√° dispon√≠vel para adicionar o tooltip");
            }
        } catch (err) {
            console.error("Erro ao criar tooltip personalizado:", err);
        }
    }

    // Mostrar tooltip
    function showTooltip(marker, data) {
        // Se o dado tiver conte√∫do de tooltip predefinido, usar esse
        if (data.tooltipContent) {
            customTooltip.innerHTML = data.tooltipContent;
        } else {
            // Caso contr√°rio, construir baseado no tipo de ponto de interesse
            let content = `<div class="tooltip-title">${data.name}</div>`;
            
            if (data.type === 'toll') {
                content += `
                    <div>Ped√°gio na rodovia ${data.highway}</div>
                    <div>Valor: R$ ${data.cost.toFixed(2)}</div>
                `;
            } else if (data.type === 'weighStation') {
                content += `
                    <div>Balan√ßa na rodovia ${data.highway}</div>
                    <div>Status: ${data.isActive ? 'Ativa' : 'Inativa'}</div>
                `;
            } else if (data.type === 'gasStation') {
                content += `
                    <div>Posto de combust√≠vel</div>
                    <div>Servi√ßos: ${formatServices(data.services)}</div>
                `;
            } else {
                content += `
                    <div>Ponto de interesse em ${data.cityName}</div>
                `;
            }
            
            customTooltip.innerHTML = content;
        }
        
        // Posicionar o tooltip acima do marcador
        const projection = map.getProjection();
        const position = marker.getPosition();
        const pixelOffset = overlay.getProjection().fromLatLngToDivPixel(position);
        
        customTooltip.style.left = pixelOffset.x + 'px';
        customTooltip.style.top = (pixelOffset.y - 120) + 'px'; // Posicionar acima do marcador
        customTooltip.style.display = 'block';
    }

    // Esconder tooltip
    function hideTooltip() {
        if (customTooltip) {
            customTooltip.style.display = 'none';
        }
    }

    // Formatar lista de servi√ßos
    function formatServices(services) {
        if (!services || !Array.isArray(services)) return '';
        
        const serviceNames = {
            'food': 'Alimenta√ß√£o',
            'rest': '√Årea de descanso',
            'shower': 'Chuveiro',
            'mechanic': 'Mec√¢nico',
            'tire': 'Borracharia'
        };
        
        return services.map(s => serviceNames[s] || s).join(', ');
    }

    // Implementa√ß√£o avan√ßada do algoritmo do Caixeiro Viajante (TSP)
    // Id√™ntico ao comportamento da vers√£o Replit
    function solveAdvancedTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP avan√ßado com", destinations.length, "destinos");
        
        // Se n√£o houver destinos, retornar apenas a origem
        if (!destinations.length) {
            console.log("Sem destinos, retornando apenas origem");
            return {
                path: [origin],
                distance: 0
            };
        }
        
        // Verificar se os objetos t√™m as propriedades necess√°rias
        if (!origin.latitude || !origin.longitude) {
            console.error("Origem sem coordenadas:", origin);
            // Criar coordenadas padr√£o para Dois C√≥rregos se n√£o existirem
            origin.latitude = origin.latitude || -22.3673;
            origin.longitude = origin.longitude || -48.3822;
        }
        
        // Verificar e corrigir destinos sem coordenadas
        for (let i = 0; i < destinations.length; i++) {
            if (!destinations[i].latitude || !destinations[i].longitude) {
                console.error("Destino sem coordenadas:", destinations[i]);
                // Atribuir coordenadas aproximadas baseadas em Dois C√≥rregos com deslocamento
                destinations[i].latitude = -22.3673 + (Math.random() - 0.5) * 0.1;
                destinations[i].longitude = -48.3822 + (Math.random() - 0.5) * 0.1;
            }
        }
        
        // Inicializar a dist√¢ncia total
        let totalDistance = 0;
        
        // Verificar se h√° pontos na mesma cidade da origem
        // Se houver, devem ser visitados primeiro
        const sameCity = [];
        const otherCities = [];
        
        destinations.forEach(dest => {
            if (isSameCity(dest, origin)) {
                sameCity.push(dest);
            } else {
                otherCities.push(dest);
            }
        });
        
        // Se h√° pontos na mesma cidade, prioriz√°-los
        if (sameCity.length > 0) {
            // Colocar os pontos da mesma cidade primeiro, depois resolver o restante
            console.log(`Encontrado ${sameCity.length} pontos na mesma cidade da origem. Priorizando.`);
            
            // Calcular a dist√¢ncia para priorizar essa ordem
            let sameCityDist = 0;
            const sameCityPath = [origin, ...sameCity];
            
            for (let i = 0; i < sameCityPath.length - 1; i++) {
                const dist = calculateDistance(
                    sameCityPath[i].latitude, sameCityPath[i].longitude,
                    sameCityPath[i+1].latitude, sameCityPath[i+1].longitude
                );
                sameCityDist += dist;
                console.log(`Dist√¢ncia de ${sameCityPath[i].name} para ${sameCityPath[i+1].name}: ${dist.toFixed(1)} km`);
            }
            
            // Se n√£o temos outros pontos, retornar apenas os da mesma cidade
            if (otherCities.length === 0) {
                console.log("Apenas pontos na mesma cidade, dist√¢ncia total:", sameCityDist.toFixed(1), "km");
                return {
                    path: sameCityPath,
                    distance: sameCityDist
                };
            }
            
            // Resolver o TSP para os outros pontos
            const otherResult = solveBasicTSP(sameCityPath[sameCityPath.length-1], otherCities, includeReturn);
            
            // Combinar os caminhos
            const fullPath = [...sameCityPath.slice(0, -1), ...otherResult.path];
            const fullDistance = sameCityDist + otherResult.distance;
            
            console.log("Combinando caminhos, dist√¢ncia na mesma cidade:", sameCityDist.toFixed(1), 
                       "km, dist√¢ncia para outras cidades:", otherResult.distance.toFixed(1), 
                       "km, total:", fullDistance.toFixed(1), "km");
            
            return {
                path: fullPath,
                distance: fullDistance
            };
        }
        
        const result = solveBasicTSP(origin, destinations, includeReturn);
        console.log("TSP b√°sico, dist√¢ncia total:", result.distance.toFixed(1), "km");
        
        // Garantir que o caminho cont√©m apenas IDs e n√£o objetos completos
        if (result.path && Array.isArray(result.path)) {
            result.pathIds = result.path.map(loc => {
                if (typeof loc === 'object' && loc !== null && loc.id !== undefined) {
                    return loc.id;
                }
                return loc;
            });
            console.log("Caminho convertido para IDs:", result.pathIds);
        }
        
        return result;
    }
    
    // Vers√£o b√°sica do TSP para cidades diferentes
    function solveBasicTSP(origin, destinations, includeReturn) {
        console.log("Iniciando TSP b√°sico com", destinations.length, "destinos");
        
        // Verificar se existem pontos na mesma cidade que o √∫ltimo ponto antes de iniciar
        const sameCityPoints = destinations.filter(dest => isSameCity(dest, origin));
        if (sameCityPoints.length > 0) {
            console.log(`Encontrados ${sameCityPoints.length} pontos na mesma cidade que o ponto de partida (${origin.name}). Eles ser√£o priorizados.`);
        }
        
        // Ordenar os destinos por proximidade da origem para priorizar a ordem
        let sortedDestinations = [...destinations].sort((a, b) => {
            // Se um est√° na mesma cidade da origem e o outro n√£o, o da mesma cidade vem primeiro
            const aInSameCity = isSameCity(a, origin);
            const bInSameCity = isSameCity(b, origin);
            
            if (aInSameCity && !bInSameCity) return -1;
            if (!aInSameCity && bInSameCity) return 1;
            
            // Se ambos est√£o ou n√£o na mesma cidade, ordenar por dist√¢ncia
            const distA = calculateDistance(
                origin.latitude, origin.longitude, 
                a.latitude, a.longitude
            );
            
            const distB = calculateDistance(
                origin.latitude, origin.longitude, 
                b.latitude, b.longitude
            );
            
            return distA - distB;
        });
        
        // Log da ordem pr√©-calculada
        console.log("Destinos ordenados por proximidade:", 
                   sortedDestinations.map((d, i) => 
                                         `${i+1}. ${d.name} (${isSameCity(d, origin) ? "mesma cidade, " : ""}${calculateDistance(
                                             origin.latitude, origin.longitude,
                                             d.latitude, d.longitude
                                         ).toFixed(1)} km)`).join(", "));
        
        // Inicializar a dist√¢ncia total
        let totalDistance = 0;
        
        // Matriz de dist√¢ncias entre todos os pontos
        const points = [origin, ...sortedDestinations];
        const numPoints = points.length;
        const distMatrix = Array(numPoints).fill().map(() => Array(numPoints).fill(0));
        
        // Preencher a matriz de dist√¢ncias
        for (let i = 0; i < numPoints; i++) {
            for (let j = i + 1; j < numPoints; j++) {
                const dist = calculateDistance(
                    points[i].latitude, points[i].longitude,
                    points[j].latitude, points[j].longitude
                );
                distMatrix[i][j] = dist;
                distMatrix[j][i] = dist; // A matriz √© sim√©trica
            }
        }
        
        // M√©todo Nearest Insertion: come√ßamos com a rota origem -> ponto mais pr√≥ximo -> origem
        // e iterativamente adicionamos o melhor ponto para inserir na rota atual
        
        // Inicializar com o ponto mais pr√≥ximo da origem
        let bestDist = Infinity;
        let bestIdx = -1;
        
        for (let i = 1; i < numPoints; i++) {
            if (distMatrix[0][i] < bestDist) {
                bestDist = distMatrix[0][i];
                bestIdx = i;
            }
        }
        
        // Rota inicial: origem -> ponto mais pr√≥ximo
        let tour = [0, bestIdx];
        let remaining = Array.from({length: numPoints - 1}, (_, i) => i + 1);
        remaining.splice(remaining.indexOf(bestIdx), 1);
        
        // Calcular a dist√¢ncia inicial
        totalDistance = bestDist;
        
        // Usar a fun√ß√£o auxiliar para completar o algoritmo
        const result = finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn);
        tour = result.tour;
        totalDistance = result.totalDistance;
        
        // Se n√£o for para incluir retorno, remover o √∫ltimo link (do √∫ltimo ponto de volta √† origem)
        if (!includeReturn && tour.length > 1) {
            const last = tour[tour.length - 1];
            totalDistance -= distMatrix[last][0];
            // N√£o removemos a origem do in√≠cio porque a rota deve come√ßar na origem
        }
        
        // Converter os √≠ndices de tour de volta para os pontos reais
        const path = tour.map(idx => points[idx]);
        
        // Ajustar a rota se n√£o for para incluir retorno √† origem
        if (!includeReturn) {
            // Garante que a rota n√£o termine voltando para a origem
            if (path[path.length - 1] === origin) {
                path.pop();
            }
        } else {
            // Garante que a rota termine na origem
            if (path[path.length - 1] !== origin) {
                path.push(origin);
                
                // Adicionar a dist√¢ncia de retorno
                const lastPoint = path[path.length - 2];
                const returnDistance = calculateDistance(
                    lastPoint.latitude, lastPoint.longitude,
                    origin.latitude, origin.longitude
                );
                totalDistance += returnDistance;
            }
        }
        
        return {
            path: path,
            distance: totalDistance
        };
    }
    
    // Manteremos a vers√£o simples para compatibilidade
    function solveTSP(origin, destinations, includeReturn) {
        return solveAdvancedTSP(origin, destinations, includeReturn);
    }
    
    // Fun√ß√£o para finalizar o algoritmo TSP b√°sico
    function finishSolveBasicTSP(tour, remaining, distMatrix, totalDistance, includeReturn) {
        // Enquanto houver pontos n√£o visitados
        while (remaining.length > 0) {
            let bestInsertion = {
                point: -1,
                position: -1,
                cost: Infinity
            };
            
            // Para cada ponto restante
            for (let i = 0; i < remaining.length; i++) {
                const point = remaining[i];
                
                // Para cada poss√≠vel posi√ß√£o de inser√ß√£o no tour atual
                for (let j = 1; j <= tour.length; j++) {
                    const prev = tour[j-1];
                    const next = j < tour.length ? tour[j] : tour[0]; // Se estamos no final, o pr√≥ximo √© o in√≠cio
                    
                    // Calcular o custo de inser√ß√£o = dist(prev, point) + dist(point, next) - dist(prev, next)
                    const insertionCost = distMatrix[prev][point] + 
                                         distMatrix[point][next] -
                                         distMatrix[prev][next];
                    
                    if (insertionCost < bestInsertion.cost) {
                        bestInsertion = {
                            point: point,
                            position: j,
                            cost: insertionCost
                        };
                    }
                }
            }
            
            // Inserir o melhor ponto na melhor posi√ß√£o
            tour.splice(bestInsertion.position, 0, bestInsertion.point);
            remaining.splice(remaining.indexOf(bestInsertion.point), 1);
            
            // Atualizar a dist√¢ncia total
            totalDistance += bestInsertion.cost;
        }
        
        return { tour, totalDistance };
    }

    // Calcular dist√¢ncia entre dois pontos usando a f√≥rmula de Haversine
    function calculateDistance(lat1, lon1, lat2, lon2) {
        // Verificar se os par√¢metros s√£o v√°lidos
        if (lat1 === undefined || lon1 === undefined || lat2 === undefined || lon2 === undefined) {
            console.error("Coordenadas inv√°lidas no c√°lculo de dist√¢ncia:", lat1, lon1, lat2, lon2);
            return 10; // Valor padr√£o seguro para evitar dist√¢ncia zero
        }
        
        // Verificar se os valores s√£o num√©ricos
        if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
            console.error("Coordenadas NaN no c√°lculo de dist√¢ncia:", lat1, lon1, lat2, lon2);
            return 15; // Valor padr√£o seguro para evitar dist√¢ncia zero
        }
        
        // Verificar se as coordenadas s√£o id√™nticas (mesmo ponto)
        if (lat1 === lat2 && lon1 === lon2) {
            console.log("Coordenadas id√™nticas detectadas, retornando valor m√≠nimo para mesma localiza√ß√£o");
            return 0.1; // Dist√¢ncia m√≠nima para evitar zero mas ainda indicar que √© o mesmo ponto
        }
        
        try {
            const R = 6371; // Raio da Terra em km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const distance = R * c; // Dist√¢ncia em km
            
            // Verificar se a dist√¢ncia √© v√°lida
            if (isNaN(distance)) {
                console.error("Dist√¢ncia calculada NaN:", distance, "para coordenadas:", lat1, lon1, lat2, lon2);
                return 20; // Valor padr√£o seguro para evitar dist√¢ncia zero
            }
            
            // Verificar se a dist√¢ncia √© zero ou muito pr√≥xima de zero
            if (distance <= 0 || distance < 0.001) {
                console.log("Dist√¢ncia calculada muito pequena:", distance, "usando valor m√≠nimo seguro");
                return 0.1; // Valor m√≠nimo seguro para evitar problemas no algoritmo
            }
            
            return distance;
        } catch (error) {
            console.error("Erro ao calcular dist√¢ncia:", error);
            return 25; // Valor padr√£o seguro em caso de erro
        }
    }

    // Converter graus para radianos
    function deg2rad(deg) {
        return deg * (Math.PI/180);
    }

    // Classe para proje√ß√£o de overlay personalizado
    class OverlayProjection {
        fromLatLngToDivPixel(latLng) {
            const scale = Math.pow(2, map.getZoom());
            const proj = map.getProjection();
            const bounds = map.getBounds();
            
            if (!proj || !bounds) {
                return { x: 0, y: 0 };
            }
            
            const nw = proj.fromLatLngToPoint(
                new google.maps.LatLng(
                    bounds.getNorthEast().lat(),
                    bounds.getSouthWest().lng()
                )
            );
            
            const point = proj.fromLatLngToPoint(latLng);
            
            return {
                x: Math.floor((point.x - nw.x) * scale),
                y: Math.floor((point.y - nw.y) * scale)
            };
        }
        
        fromDivPixelToLatLng(pixel) {
            return null; // N√£o precisamos desta funcionalidade
        }
    }

    // Criar um overlay personalizado para a proje√ß√£o
    const overlay = new google.maps.OverlayView();
    overlay.draw = function() {};
    overlay.setMap(map);
    overlay.getProjection = function() {
        return new OverlayProjection();
    };

    // Expor fun√ß√µes necess√°rias globalmente
    window.removeLocation = removeLocation;
    </script>
<script src="sidebar-fix.js"></script><script src="tabs-fullscreen.js"></script><script src="cache-buster-20250515233742.js"></script></body>
</html>