<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1976D2">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Otimizador de Rotas para log√≠stica e transporte, com suporte a c√°lculo de rotas entre m√∫ltiplos pontos, otimiza√ß√£o de sequ√™ncia, e visualiza√ß√£o de eventos e restri√ß√µes em cidades brasileiras." />
    <meta name="keywords" content="otimizador de rotas, problema do caixeiro viajante, log√≠stica, transporte, planejamento de rotas, otimiza√ß√£o de entregas, Brasil, Google Maps, ped√°gios, eventos em cidades" />
    <title>Otimizador de Rotas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Estilos globais */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Evita scroll duplo */
        }
        header {
            background-color: #1976D2;
            color: white;
            padding: 10px 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .header-title {
            margin: 0;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        /* Layout principal */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Sidebar */
        .sidebar {
            width: 320px;
            background-color: white;
            border-right: 1px solid #e0e0e0;
            box-shadow: 1px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 10;
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        /* Container da parte principal */
        .content-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* √Årea do mapa */
        .map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        
        /* Formul√°rios e controles */
        .form-control, .btn {
            border-radius: 4px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        /* Bot√£o de toggle para o sidebar */
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
        }
        
        /* Bot√£o de otimizar rota */
        .optimize-container {
            padding: 15px;
            background-color: #f0f4f8;
            border-top: 1px solid #ddd;
            margin-top: auto;
        }
        #optimize-route {
            width: 100%;
            font-weight: bold;
        }
        
        /* Estilos para locais na lista */
        .locations-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-item:last-child {
            border-bottom: none;
        }
        .location-delete {
            color: #e53935;
            cursor: pointer;
            opacity: 0.7;
        }
        .location-delete:hover {
            opacity: 1;
        }
        
        /* Loading spinner */
        .loading-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Bot√£o de abrir sidebar (para mobile) */
        .mobile-sidebar-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: #1976D2;
            color: white;
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-size: 24px;
            transition: all 0.3s ease;
        }
        .mobile-sidebar-toggle:active {
            transform: scale(0.95);
        }
        
        /* NOVO: Estilos espec√≠ficos para as abas inferiores */
        .bottom-tabs-container {
            background-color: white;
            border-top: 2px solid #1976D2;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            height: 60vh;
            max-height: 60vh;
            transition: all 0.3s ease;
            z-index: 900;
        }
        
        .bottom-tabs-container.minimized {
            height: 60px;
        }
        
        .bottom-tabs-nav {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: linear-gradient(to top, #1565C0, #1976D2);
            border-bottom: 2px solid #0d47a1;
            flex-shrink: 0;
        }
        
        .bottom-tab-btn {
            padding: 10px 15px;
            border: 1px solid rgba(255,255,255,0.5);
            background-color: rgba(255,255,255,0.1);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .bottom-tab-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .bottom-tab-btn.active {
            background-color: white;
            color: #1976D2;
            font-weight: bold;
            border-color: white;
        }
        
        .bottom-tab-btn::before {
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-events"]::before {
            content: "üóìÔ∏è";
        }
        
        .bottom-tab-btn[data-tab="bottom-restrictions"]::before {
            content: "üö´";
        }
        
        .bottom-tab-btn[data-tab="bottom-report"]::before {
            content: "üìä";
        }
        
        .bottom-tabs-content-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        
        .bottom-tab-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 20px;
            overflow-y: auto;
            background-color: white;
            display: none;
        }
        
        .bottom-tab-content.active {
            display: block;
        }
        
        /* Estilos para eventos e restri√ß√µes */
        .event-item, .restriction-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .event-badge, .restriction-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .event-badge {
            background-color: #e3f2fd;
            color: #1565C0;
        }
        
        .restriction-badge {
            background-color: #ffebee;
            color: #c62828;
        }

        /* Estilos para op√ß√µes de rota */
        .route-options {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }
        
        .route-options legend {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .route-option {
            margin-bottom: 10px;
        }
        
        .route-option input[type="radio"] {
            margin-right: 8px;
        }
        
        .route-option label {
            font-weight: normal;
            cursor: pointer;
        }
        
        .route-method-info {
            margin-top: 5px;
            font-size: 13px;
            color: #666;
            margin-left: 25px;
        }
        
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 85%;
                max-width: 320px;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.visible {
                transform: translateX(0);
            }
            
            .toggle-sidebar {
                display: block;
            }
            
            .mobile-sidebar-toggle {
                display: block;
            }
            
            /* Overlay para quando o sidebar estiver aberto */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0,0,0,0.5);
                z-index: 999;
            }
            
            .sidebar-overlay.visible {
                display: block;
            }
            
            /* Ajuste para abas inferiores em telas pequenas */
            .bottom-tabs-container {
                height: 50vh;
            }
            
            /* Tornar o conte√∫do de abas mais compacto em telas pequenas */
            .bottom-tab-content {
                padding: 15px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Spinner -->
    <div class="loading-container" id="loading-spinner">
        <div class="spinner"></div>
    </div>
    
    <!-- Cabe√ßalho -->
    <header>
        <h1 class="header-title">Otimizador de Rotas</h1>
    </header>
    
    <!-- Container principal -->
    <div class="main-container">
        <!-- Overlay para sidebar em mobile -->
        <div class="sidebar-overlay" id="sidebar-overlay"></div>
        
        <!-- Sidebar para entrada de dados -->
        <div class="sidebar" id="sidebar">
            <!-- Bot√£o para fechar sidebar em mobile -->
            <button class="btn btn-sm btn-light sidebar-close" id="close-sidebar">
                <i class="fas fa-times"></i>
            </button>
            
            <div class="p-3">
                <h5 class="mb-3">Datas da rota</h5>
                <div class="row">
                    <div class="col-6">
                        <div class="form-group">
                            <label class="form-label" for="start-date">Data inicial:</label>
                            <input type="date" class="form-control" id="start-date">
                        </div>
                    </div>
                    <div class="col-6">
                        <div class="form-group">
                            <label class="form-label" for="end-date">Data final:</label>
                            <input type="date" class="form-control" id="end-date">
                        </div>
                    </div>
                </div>
                
                <h5 class="mb-3 mt-4">Origem</h5>
                <div class="form-group">
                    <label class="form-label" for="origin">Ponto de partida:</label>
                    <input type="text" class="form-control" id="origin" readonly>
                </div>
                
                <h5 class="mb-3 mt-4">Destinos</h5>
                
                <div class="form-group">
                    <label class="form-label" for="address-input">Adicionar endere√ßo:</label>
                    <div class="input-group mb-3">
                        <input type="text" class="form-control" id="address-input" placeholder="Digite um endere√ßo ou CEP">
                        <button class="btn btn-primary" id="add-location">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Ou envie um arquivo com CEPs:</label>
                    <div class="input-group mb-3">
                        <input type="file" class="form-control" id="cep-file" accept=".txt,.csv">
                        <button class="btn btn-outline-secondary" id="upload-cep">
                            <i class="fas fa-upload"></i>
                        </button>
                    </div>
                    <small class="text-muted">Formato: CEP,nome (um por linha)</small>
                </div>
                
                <h5 class="mb-2">Locais adicionados</h5>
                <div class="locations-list" id="locations-list">
                    <div class="p-3 text-muted">Nenhum local adicionado.</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="vehicle-type">Tipo de ve√≠culo:</label>
                    <select class="form-select" id="vehicle-type">
                        <option value="truck1">Caminh√£o 1 eixo</option>
                        <option value="truck2">Caminh√£o 2 eixos</option>
                        <option value="truck3">Caminh√£o 3 eixos</option>
                        <option value="truck4">Caminh√£o 4 eixos</option>
                        <option value="truck5">Caminh√£o 5 eixos</option>
                        <option value="truck6">Caminh√£o 6 eixos+</option>
                    </select>
                </div>
                
                <!-- NOVO: Op√ß√µes de m√©todo de otimiza√ß√£o de rota -->
                <div class="form-group mt-4">
                    <fieldset class="route-options">
                        <legend>M√©todo de otimiza√ß√£o:</legend>
                        
                        <div class="route-option">
                            <input type="radio" id="route-standard" name="route-method" value="standard" checked>
                            <label for="route-standard">Padr√£o</label>
                            <div class="route-method-info">Otimiza√ß√£o b√°sica baseada no algoritmo do Caixeiro Viajante.</div>
                        </div>
                        
                        <div class="route-option">
                            <input type="radio" id="route-nearest" name="route-method" value="nearest">
                            <label for="route-nearest">Mais pr√≥ximo da origem</label>
                            <div class="route-method-info">Prioriza locais mais pr√≥ximos do ponto de partida.</div>
                        </div>
                        
                        <div class="route-option">
                            <input type="radio" id="route-spiral" name="route-method" value="spiral">
                            <label for="route-spiral">Em espiral</label>
                            <div class="route-method-info">Percorre em forma de espiral a partir da origem.</div>
                        </div>
                    </fieldset>
                </div>
            </div>
            
            <!-- Bot√£o de otimizar (fixo na parte inferior) -->
            <div class="optimize-container">
                <button class="btn btn-success" id="optimize-route">Otimizar Rota</button>
            </div>
        </div>
        
        <!-- Container do conte√∫do principal -->
        <div class="content-container">
            <!-- Bot√£o para mostrar sidebar em mobile -->
            <button class="toggle-sidebar" id="toggle-sidebar">
                <i class="fas fa-bars"></i>
            </button>
            
            <!-- Container do mapa -->
            <div class="map-container">
                <div id="map"></div>
            </div>
            
            <!-- NOVO: Tabs fixas na parte inferior do layout (inicialmente minimizadas) -->
            <div class="bottom-tabs-container minimized">
                <!-- Navega√ß√£o das abas inferiores -->
                <div class="bottom-tabs-nav">
                    <button class="bottom-tab-btn active" data-tab="bottom-events" onclick="showTab('bottom-events')">
                        Eventos na Rota
                    </button>
                    <button class="bottom-tab-btn" data-tab="bottom-restrictions" onclick="showTab('bottom-restrictions')">
                        Restri√ß√µes de Tr√°fego
                    </button>
                    <button class="bottom-tab-btn" data-tab="bottom-report" onclick="showTab('bottom-report')">
                        Relat√≥rio da Rota
                    </button>
                </div>
                
                <!-- Container das abas com rolagem independente para cada aba -->
                <div class="bottom-tabs-content-container">
                    <!-- Conte√∫do da aba Eventos -->
                    <div class="bottom-tab-content active" id="bottom-events-content">
                        <h5>Eventos nas cidades da rota:</h5>
                        <div class="events-list" id="events-list">
                            <p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                        </div>
                    </div>
                    
                    <!-- Conte√∫do da aba Restri√ß√µes -->
                    <div class="bottom-tab-content" id="bottom-restrictions-content">
                        <h5>Restri√ß√µes de tr√°fego para caminh√µes:</h5>
                        <div class="restrictions-list" id="restrictions-list">
                            <p class="text-muted">Nenhuma restri√ß√£o encontrada. Adicione locais e otimize a rota para ver as restri√ß√µes de tr√°fego.</p>
                        </div>
                    </div>
                    
                    <!-- Conte√∫do da aba Relat√≥rio -->
                    <div class="bottom-tab-content" id="bottom-report-content">
                        <h5>Resumo da rota otimizada:</h5>
                        <div class="route-info p-3 border rounded mb-3 bg-light" id="route-info">
                            <p class="text-muted">Otimize a rota para ver o relat√≥rio detalhado.</p>
                        </div>
                        
                        <h5>Sequ√™ncia de entrega:</h5>
                        <div class="route-sequence border rounded p-3" id="route-sequence">
                            <p class="text-muted">A sequ√™ncia de rota ser√° exibida aqui ap√≥s a otimiza√ß√£o.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bot√£o flutuante para abrir o sidebar em mobile -->
    <button class="mobile-sidebar-toggle" id="mobile-sidebar-toggle">
        <i class="fas fa-edit"></i>
    </button>
    
    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    
    <!-- jQuery para opera√ß√µes mais simples -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Controle de abas -->
    <script>
    // Fun√ß√£o para controlar as abas
    function showTab(tabName) {
        console.log('Mostrando aba:', tabName);
        
        // Primeiro, esconder todos os conte√∫dos das abas
        var allContents = document.querySelectorAll('.bottom-tab-content');
        allContents.forEach(function(content) {
            content.style.display = 'none';
            content.classList.remove('active');
        });
        
        // Depois, mostrar apenas o conte√∫do da aba selecionada
        var selectedContent = document.getElementById(tabName + '-content');
        if (selectedContent) {
            selectedContent.style.display = 'block';
            selectedContent.classList.add('active');
            console.log('Ativado conte√∫do:', tabName + '-content');
        } else {
            console.error('Conte√∫do n√£o encontrado para aba:', tabName);
        }
        
        // Atualizar classes ativas nos bot√µes
        var allButtons = document.querySelectorAll('.bottom-tab-btn');
        allButtons.forEach(function(button) {
            button.classList.remove('active');
            
            if (button.getAttribute('data-tab') === tabName) {
                button.classList.add('active');
            }
        });
        
        // Expandir o container se estiver minimizado
        var tabsContainer = document.querySelector('.bottom-tabs-container');
        if (tabsContainer && tabsContainer.classList.contains('minimized')) {
            tabsContainer.classList.remove('minimized');
        }
    }
    
    // Garantir que as abas funcionem corretamente ap√≥s otimiza√ß√£o
    document.addEventListener('DOMContentLoaded', function() {
        // Modificar o bot√£o de otimiza√ß√£o
        var optimizeButton = document.getElementById('optimize-route');
        if (optimizeButton) {
            // Guardar o onclick original
            var originalOnclick = optimizeButton.onclick;
            
            // Definir novo onclick
            optimizeButton.onclick = function(event) {
                // Chamar o handler original se ele existir
                if (typeof originalOnclick === 'function') {
                    originalOnclick.call(this, event);
                }
                
                // Agendar navega√ß√£o para a aba de relat√≥rio
                setTimeout(function() {
                    showTab('bottom-report');
                }, 2000);
            };
        }
        
        // Inicializa√ß√£o - mostrar aba de eventos
        setTimeout(function() {
            showTab('bottom-events');
        }, 500);
    });
    </script>
    
    <!-- Implementa√ß√£o do Problema do Caixeiro Viajante (TSP) para otimiza√ß√£o de rotas -->
    <script>
    /**
     * Implementa√ß√£o do algoritmo do Caixeiro Viajante (TSP)
     * para otimiza√ß√£o de rotas de entrega
     */
    class TSPSolver {
        constructor() {
            this.maxRouteLength = 100; // Limite de seguran√ßa para n√£o travar o navegador
        }
        
        /**
         * Calcula a dist√¢ncia entre dois pontos usando a f√≥rmula de Haversine
         * @param {number} lat1 - Latitude do ponto 1
         * @param {number} lon1 - Longitude do ponto 1
         * @param {number} lat2 - Latitude do ponto 2
         * @param {number} lon2 - Longitude do ponto 2
         * @returns {number} - Dist√¢ncia em quil√¥metros
         */
        calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raio da Terra em km
            const dLat = this.deg2rad(lat2 - lat1);
            const dLon = this.deg2rad(lon2 - lon1);
            
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
                
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Dist√¢ncia em km
        }
        
        /**
         * Converte graus para radianos
         */
        deg2rad(deg) {
            return deg * (Math.PI/180);
        }
        
        /**
         * Constr√≥i a matriz de dist√¢ncias entre todos os pontos
         * @param {Array} locations - Array de locais com coordenadas lat/lng
         * @returns {Array} - Matriz de dist√¢ncias
         */
        buildDistanceMatrix(locations) {
            const n = locations.length;
            const distMatrix = Array(n).fill().map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        distMatrix[i][j] = this.calculateDistance(
                            locations[i].lat, locations[i].lng,
                            locations[j].lat, locations[j].lng
                        );
                    }
                }
            }
            
            return distMatrix;
        }
        
        /**
         * Executa o algoritmo do vizinho mais pr√≥ximo para encontrar uma rota
         * @param {Array} distMatrix - Matriz de dist√¢ncias
         * @param {number} startIdx - √çndice do ponto de partida
         * @returns {Object} - Rota e dist√¢ncia total
         */
        nearestNeighborTSP(distMatrix, startIdx = 0) {
            const n = distMatrix.length;
            
            // Verificar se h√° pontos suficientes
            if (n <= 1) {
                return {
                    path: [0],
                    distance: 0
                };
            }
            
            const visited = Array(n).fill(false);
            const path = [];
            let totalDistance = 0;
            
            // Come√ßar pelo ponto de partida
            let currentIdx = startIdx;
            path.push(currentIdx);
            visited[currentIdx] = true;
            
            // Encontrar o vizinho mais pr√≥ximo em cada etapa
            for (let i = 1; i < n; i++) {
                let bestDistance = Infinity;
                let bestIdx = -1;
                
                for (let j = 0; j < n; j++) {
                    if (!visited[j] && distMatrix[currentIdx][j] < bestDistance) {
                        bestDistance = distMatrix[currentIdx][j];
                        bestIdx = j;
                    }
                }
                
                if (bestIdx !== -1) {
                    visited[bestIdx] = true;
                    path.push(bestIdx);
                    totalDistance += bestDistance;
                    currentIdx = bestIdx;
                }
            }
            
            // Voltar para a origem (comentado pois n√£o queremos retorno √† origem)
            // totalDistance += distMatrix[currentIdx][startIdx];
            // path.push(startIdx);
            
            return {
                path: path,
                distance: totalDistance
            };
        }
        
        /**
         * Otimiza√ß√£o baseada na proximidade com a origem
         * @param {Array} locations - Lista de locais
         * @param {number} originIndex - √çndice da localiza√ß√£o de origem
         * @returns {Array} - Caminho otimizado
         */
        nearestToOriginOptimization(locations, originIndex = 0) {
            if (locations.length <= 1) {
                return {
                    path: [0],
                    distance: 0
                };
            }
            
            const origin = locations[originIndex];
            
            // Calcular dist√¢ncia de cada ponto √† origem
            const distances = locations.map((loc, index) => {
                if (index === originIndex) return { index, distance: 0 };
                
                const distance = this.calculateDistance(
                    origin.lat, origin.lng,
                    loc.lat, loc.lng
                );
                
                return { index, distance };
            });
            
            // Ordenar por dist√¢ncia √† origem (excluindo a pr√≥pria origem)
            const sortedDistances = distances
                .filter(item => item.index !== originIndex)
                .sort((a, b) => a.distance - b.distance);
            
            // Construir o caminho
            const path = [originIndex];
            let totalDistance = 0;
            
            // Adicionar pontos em ordem de proximidade com a origem
            for (const item of sortedDistances) {
                path.push(item.index);
            }
            
            // Calcular a dist√¢ncia total do caminho
            for (let i = 0; i < path.length - 1; i++) {
                const from = locations[path[i]];
                const to = locations[path[i+1]];
                
                totalDistance += this.calculateDistance(
                    from.lat, from.lng,
                    to.lat, to.lng
                );
            }
            
            return {
                path: path,
                distance: totalDistance
            };
        }
        
        /**
         * Otimiza√ß√£o em espiral a partir da origem
         * @param {Array} locations - Lista de locais
         * @param {number} originIndex - √çndice da localiza√ß√£o de origem
         * @returns {Array} - Caminho otimizado
         */
        spiralOptimization(locations, originIndex = 0) {
            if (locations.length <= 1) {
                return {
                    path: [0],
                    distance: 0
                };
            }
            
            const origin = locations[originIndex];
            
            // Calcular √¢ngulo e dist√¢ncia de cada ponto √† origem
            const pointsWithAngles = locations.map((loc, index) => {
                if (index === originIndex) {
                    return { index, angle: 0, distance: 0 };
                }
                
                // Calcular √¢ngulo em radianos (0 √© leste, aumenta no sentido anti-hor√°rio)
                const deltaX = loc.lng - origin.lng;
                const deltaY = loc.lat - origin.lat;
                let angle = Math.atan2(deltaY, deltaX);
                
                // Converter para graus e normalizar para 0-360
                angle = (angle * 180 / Math.PI + 360) % 360;
                
                // Calcular dist√¢ncia
                const distance = this.calculateDistance(
                    origin.lat, origin.lng,
                    loc.lat, loc.lng
                );
                
                return { index, angle, distance };
            });
            
            // Ordenar pontos por √¢ngulo (para criar uma espiral)
            const sortedPoints = pointsWithAngles
                .filter(item => item.index !== originIndex)
                .sort((a, b) => {
                    // Se os √¢ngulos s√£o aproximadamente iguais, ordenar por dist√¢ncia
                    if (Math.abs(a.angle - b.angle) < 10) {
                        return a.distance - b.distance;
                    }
                    // Caso contr√°rio, ordenar por √¢ngulo
                    return a.angle - b.angle;
                });
            
            // Construir o caminho
            const path = [originIndex];
            let totalDistance = 0;
            
            // Adicionar pontos em ordem espiral
            for (const point of sortedPoints) {
                path.push(point.index);
            }
            
            // Calcular a dist√¢ncia total do caminho
            for (let i = 0; i < path.length - 1; i++) {
                const from = locations[path[i]];
                const to = locations[path[i+1]];
                
                totalDistance += this.calculateDistance(
                    from.lat, from.lng,
                    to.lat, to.lng
                );
            }
            
            return {
                path: path,
                distance: totalDistance
            };
        }
        
        /**
         * Resolve o problema do caixeiro viajante para uma lista de localiza√ß√µes
         * @param {Array} locations - Lista de locais
         * @param {number} originIndex - √çndice da localiza√ß√£o de origem
         * @param {string} method - M√©todo de otimiza√ß√£o: 'standard', 'nearest', 'spiral'
         * @returns {Object} - Resultado com caminho otimizado, dist√¢ncia total e tempo estimado
         */
        solve(locations, originIndex = 0, method = 'standard') {
            // Verificar se h√° locais suficientes
            if (locations.length === 0) {
                return {
                    path: [],
                    distance: 0,
                    estimatedTime: 0,
                    waypoint_order: []
                };
            }
            
            if (locations.length === 1) {
                return {
                    path: [locations[0]],
                    distance: 0,
                    estimatedTime: 0,
                    waypoint_order: [0]
                };
            }
            
            // Limitar o n√∫mero de locais para evitar travamento
            if (locations.length > this.maxRouteLength) {
                console.warn(`N√∫mero de locais (${locations.length}) excede o limite (${this.maxRouteLength})`);
                locations = locations.slice(0, this.maxRouteLength);
            }
            
            let result;
            
            // Escolher o m√©todo de otimiza√ß√£o
            if (method === 'nearest') {
                result = this.nearestToOriginOptimization(locations, originIndex);
            } else if (method === 'spiral') {
                result = this.spiralOptimization(locations, originIndex);
            } else {
                // M√©todo padr√£o: algoritmo do vizinho mais pr√≥ximo
                const distMatrix = this.buildDistanceMatrix(locations);
                result = this.nearestNeighborTSP(distMatrix, originIndex);
            }
            
            // Calcular o tempo estimado (considerando velocidade m√©dia de 60 km/h)
            const estimatedTime = result.distance / 60; // tempo em horas
            
            // Mapear √≠ndices do caminho para o formato esperado pelo Google Maps
            // (sem incluir o ponto de origem)
            const waypoint_order = result.path
                .filter(index => index !== originIndex)
                .map(index => {
                    // Ajustar o √≠ndice para o formato esperado pelo Google Maps
                    // (se o originIndex n√£o √© 0, pode ser necess√°rio ajustar)
                    return index > originIndex ? index - 1 : index;
                });
            
            return {
                path: result.path.map(index => locations[index]),
                distance: result.distance,
                estimatedTime: estimatedTime,
                waypoint_order: waypoint_order
            };
        }
    }
    </script>
    
    <!-- Script Principal -->
    <script>
        // Vari√°veis globais
        let map;
        let markers = [];
        let locations = [];
        let origin = null;
        let autocomplete;
        let directionsService;
        let directionsRenderer;
        let currentOptimizedPath = null;
        let currentRouteSummary = null;
        let allPolylines = [];
        let autocompleteService;
        let placesService;
        let geocoder;
        let currentStepIndex = 0;
        let animationTimeout;
        let tspSolver;
        
        // ID do √∫ltimo local adicionado
        let lastLocationId = 0;
        
        // Configura√ß√µes padr√£o
        const DEFAULT_SPEED = 80; // km/h
        
        // Inicializa√ß√£o ap√≥s o carregamento da p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar o mapa quando a API Google Maps estiver pronta
            initMap();
            
            // Inicializar o algoritmo TSP
            tspSolver = new TSPSolver();
            
            // Inicializar a interface do usu√°rio
            initUI();
            
            // Preencher com dados iniciais (origem em Dois C√≥rregos)
            fetchInitialData()
            .then(() => {
                console.log("Dados iniciais carregados com sucesso");
                // Atualizar a lista de cidades para eventos
                updateEventCitiesList();
            })
            .catch(error => {
                console.error("Erro ao carregar dados iniciais:", error);
            });
        });
        
        // Inicializar o mapa
        function initMap() {
            console.log("Iniciando carregamento da Google Maps API...");
            
            // Criar o mapa
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: -22.3636, lng: -48.3798 }, // Dois C√≥rregos, SP
                zoom: 13,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                gestureHandling: 'greedy', // Permitir zoom sem Ctrl
                zoomControl: true,
                mapTypeControl: true,
                scaleControl: true,
                streetViewControl: true,
                rotateControl: true,
                fullscreenControl: true
            });
            
            // Inicializar servi√ßos do Google Maps
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                suppressMarkers: true, // N√£o mostrar marcadores autom√°ticos
                polylineOptions: {
                    strokeColor: '#1976D2',
                    strokeWeight: 5,
                    strokeOpacity: 0.7
                }
            });
            
            geocoder = new google.maps.Geocoder();
            
            // Inicializar o servi√ßo de autocompletar para endere√ßos
            autocomplete = new google.maps.places.Autocomplete(
                document.getElementById('address-input'),
                { types: ['geocode'], componentRestrictions: { country: 'br' } }
            );
            
            // Inicializar o servi√ßo de autocompletar para busca program√°tica
            autocompleteService = new google.maps.places.AutocompleteService();
            placesService = new google.maps.places.PlacesService(map);
            
            console.log("Google Maps API loaded");
        }
        
        // Inicializar a interface do usu√°rio
        function initUI() {
            // Eventos para o sidebar em dispositivos m√≥veis
            document.getElementById('toggle-sidebar').addEventListener('click', toggleSidebar);
            document.getElementById('close-sidebar').addEventListener('click', toggleSidebar);
            document.getElementById('sidebar-overlay').addEventListener('click', toggleSidebar);
            document.getElementById('mobile-sidebar-toggle').addEventListener('click', toggleSidebar);
            
            // Evento para adicionar um local
            document.getElementById('add-location').addEventListener('click', addLocation);
            
            // Evento para o upload de arquivo de CEPs
            document.getElementById('upload-cep').addEventListener('click', uploadCEPFile);
            
            // Evento para otimizar a rota
            document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
            
            // Inicializar as datas padr√£o (hoje e hoje + 7 dias)
            const today = new Date();
            const nextWeek = new Date();
            nextWeek.setDate(today.getDate() + 7);
            
            document.getElementById('start-date').valueAsDate = today;
            document.getElementById('end-date').valueAsDate = nextWeek;
        }
        
        // Toggle para o sidebar em dispositivos m√≥veis
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            
            sidebar.classList.toggle('visible');
            overlay.classList.toggle('visible');
        }
        
        // Exibir/ocultar o spinner de carregamento
        function toggleLoadingSpinner(show) {
            const spinner = document.getElementById('loading-spinner');
            spinner.style.display = show ? 'flex' : 'none';
        }
        
        // Mostrar uma notifica√ß√£o na interface
        function showNotification(message, isError = false) {
            // Verificar se j√° existe uma notifica√ß√£o
            let notification = document.querySelector('.notification');
            
            // Se n√£o existir, criar uma nova
            if (!notification) {
                notification = document.createElement('div');
                notification.className = 'notification';
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.padding = '15px 20px';
                notification.style.borderRadius = '4px';
                notification.style.color = 'white';
                notification.style.zIndex = '2000';
                notification.style.maxWidth = '300px';
                notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                notification.style.transition = 'all 0.3s ease';
                notification.style.fontWeight = 'bold';
                
                document.body.appendChild(notification);
            }
            
            // Configurar a apar√™ncia com base no tipo
            notification.style.backgroundColor = isError ? '#f44336' : '#4caf50';
            notification.textContent = message;
            
            // Mostrar a notifica√ß√£o
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
            
            // Esconder ap√≥s alguns segundos
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                
                // Remover do DOM ap√≥s a anima√ß√£o
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Adicionar um marcador ao mapa
        function addMarker(location, title, id, isOrigin = false) {
            // Verificar se √© um marcador de origem
            const markerOptions = {
                position: location,
                map: map,
                title: title
            };
            
            // Usar √≠cones ou cores diferentes para distinguir
            if (isOrigin) {
                markerOptions.icon = {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#ff6600',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 10
                };
            }
            
            const marker = new google.maps.Marker(markerOptions);
            
            // Armazenar o ID no marcador para refer√™ncia futura
            marker.set('id', id);
            
            // Adicionar evento de clique para mostrar info
            marker.addListener('click', function() {
                // Mostrar informa√ß√µes do ponto quando clicado
                const infoWindow = new google.maps.InfoWindow({
                    content: `<div><strong>${title}</strong></div>`
                });
                infoWindow.open(map, marker);
            });
            
            markers.push(marker);
            return marker;
        }
        
        // Adicionar um local √† lista
        function addLocation() {
            const input = document.getElementById('address-input');
            const address = input.value.trim();
            
            if (!address) {
                showNotification('Por favor, digite um endere√ßo v√°lido', true);
                return;
            }
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            // Usar o geocoder para obter coordenadas
            geocoder.geocode({ address: address + ', Brasil' }, function(results, status) {
                // Ocultar o spinner
                toggleLoadingSpinner(false);
                
                if (status === google.maps.GeocoderStatus.OK && results.length > 0) {
                    const result = results[0];
                    const location = result.geometry.location;
                    
                    // Criar um novo ID para este local
                    const id = ++lastLocationId;
                    
                    // Guardar o local
                    locations.push({
                        id: id,
                        name: result.formatted_address,
                        address: result.formatted_address,
                        lat: location.lat(),
                        lng: location.lng(),
                        isOrigin: false
                    });
                    
                    // Adicionar marcador ao mapa
                    addMarker(location, result.formatted_address, id);
                    
                    // Ajustar o zoom do mapa para mostrar todos os marcadores
                    fitMapToMarkers();
                    
                    // Atualizar a lista de locais na interface
                    updateLocationsList();
                    
                    // Atualizar a lista de cidades para eventos
                    updateEventCitiesList();
                    
                    // Mostrar notifica√ß√£o de sucesso
                    showNotification('Local adicionado com sucesso');
                } else {
                    showNotification('N√£o foi poss√≠vel geocodificar o endere√ßo: ' + status, true);
                }
                
                // Limpar o campo de busca
                input.value = '';
            });
        }
        
        // Ajustar o zoom do mapa para mostrar todos os marcadores
        function fitMapToMarkers() {
            if (markers.length === 0) return;
            
            const bounds = new google.maps.LatLngBounds();
            
            markers.forEach(marker => {
                bounds.extend(marker.getPosition());
            });
            
            map.fitBounds(bounds);
            
            // Se houver apenas um marcador, zoom mais pr√≥ximo
            if (markers.length === 1) {
                map.setZoom(14);
            }
        }
        
        // Atualizar a lista de locais na interface
        function updateLocationsList() {
            const listElement = document.getElementById('locations-list');
            
            // Limpar a lista atual
            listElement.innerHTML = '';
            
            // Verificar se h√° locais
            if (locations.length === 0) {
                listElement.innerHTML = '<div class="p-3 text-muted">Nenhum local adicionado.</div>';
                return;
            }
            
            // Filtrar locais que n√£o s√£o origem
            const destinationLocations = locations.filter(loc => !loc.isOrigin);
            
            if (destinationLocations.length === 0) {
                listElement.innerHTML = '<div class="p-3 text-muted">Nenhum destino adicionado.</div>';
                return;
            }
            
            // Adicionar cada local √† lista
            destinationLocations.forEach(location => {
                const item = document.createElement('div');
                item.className = 'location-item';
                item.innerHTML = `
                    <div>${location.name}</div>
                    <div class="location-delete" data-id="${location.id}" title="Remover">
                        <i class="fas fa-trash"></i>
                    </div>
                `;
                
                listElement.appendChild(item);
            });
            
            // Adicionar evento de clique para remover locais
            const deleteButtons = document.querySelectorAll('.location-delete');
            deleteButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    removeLocation(id);
                });
            });
        }
        
        // Remover um local da lista
        function removeLocation(id) {
            // Encontrar o √≠ndice do local
            const index = locations.findIndex(loc => loc.id === id);
            
            if (index !== -1) {
                // Remover do array de locais
                locations.splice(index, 1);
                
                // Remover o marcador correspondente
                const markerIndex = markers.findIndex(marker => marker.get('id') === id);
                if (markerIndex !== -1) {
                    markers[markerIndex].setMap(null);
                    markers.splice(markerIndex, 1);
                }
                
                // Atualizar a lista na interface
                updateLocationsList();
                
                // Atualizar a lista de cidades para eventos
                updateEventCitiesList();
                
                // Mostrar notifica√ß√£o
                showNotification('Local removido com sucesso');
                
                // Limpar quaisquer rotas existentes
                clearAllPolylines();
                if (directionsRenderer) {
                    directionsRenderer.setDirections({ routes: [] });
                }
                
                // Limpar informa√ß√µes de rota
                document.getElementById('route-info').innerHTML = `
                    <p class="text-muted">Otimize a rota para ver o relat√≥rio detalhado.</p>
                `;
                document.getElementById('route-sequence').innerHTML = `
                    <p class="text-muted">A sequ√™ncia de rota ser√° exibida aqui ap√≥s a otimiza√ß√£o.</p>
                `;
            }
        }
        
        // Limpar todas as polylines no mapa
        function clearAllPolylines() {
            allPolylines.forEach(polyline => {
                polyline.setMap(null);
            });
            allPolylines = [];
        }
        
        // Processar o upload de arquivo de CEPs
        function uploadCEPFile() {
            const fileInput = document.getElementById('cep-file');
            
            if (!fileInput.files || fileInput.files.length === 0) {
                showNotification('Por favor, selecione um arquivo', true);
                return;
            }
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            reader.onload = function(e) {
                const content = e.target.result;
                
                // Processar o conte√∫do do arquivo
                processCepFile(content);
                
                // Limpar o input de arquivo
                fileInput.value = '';
                
                // Ocultar o spinner
                toggleLoadingSpinner(false);
            };
            
            reader.onerror = function() {
                toggleLoadingSpinner(false);
                showNotification('Erro ao ler o arquivo', true);
            };
            
            reader.readAsText(file);
        }
        
        // Processar o conte√∫do do arquivo de CEPs
        function processCepFile(content) {
            // Dividir por linhas
            const lines = content.split(/\r?\n/);
            
            // Verificar se h√° linhas
            if (lines.length === 0) {
                showNotification('Arquivo vazio', true);
                return;
            }
            
            // Contador para geocodifica√ß√µes bem-sucedidas
            let successCount = 0;
            let errorCount = 0;
            let totalLines = lines.filter(l => l.trim()).length;
            let processedCount = 0;
            
            // Processar cada linha
            lines.forEach(line => {
                line = line.trim();
                if (!line) return; // Pular linhas vazias
                
                // Tentar extrair CEP e nome
                let cep, name;
                
                if (line.includes(',')) {
                    // Formato CEP,nome
                    [cep, name] = line.split(',', 2).map(s => s.trim());
                } else {
                    // Apenas CEP
                    cep = line.trim();
                    name = 'Local ' + (++lastLocationId);
                }
                
                // Validar CEP (formato brasileiro: 8 d√≠gitos)
                cep = cep.replace(/\D/g, '');
                if (cep.length !== 8) {
                    console.warn('CEP inv√°lido:', cep);
                    errorCount++;
                    processedCount++;
                    
                    // Verificar se terminou
                    if (processedCount === totalLines) {
                        showNotification(`Processados ${successCount} CEPs com sucesso. ${errorCount} erros.`, errorCount > 0);
                    }
                    
                    return;
                }
                
                // Formatar CEP para exibi√ß√£o
                const formattedCep = cep.substring(0, 5) + '-' + cep.substring(5);
                
                // Geocodificar o CEP
                geocodeCEP(cep, formattedCep, name, function(success) {
                    if (success) {
                        successCount++;
                    } else {
                        errorCount++;
                    }
                    
                    processedCount++;
                    
                    // Verificar se terminou
                    if (processedCount === totalLines) {
                        showNotification(`Processados ${successCount} CEPs com sucesso. ${errorCount} erros.`, errorCount > 0);
                    }
                });
            });
        }
        
        // Geocodificar um CEP
        function geocodeCEP(cep, formattedCep, name, callback) {
            const address = formattedCep + ', Brasil';
            
            geocoder.geocode({ address: address }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK && results.length > 0) {
                    const result = results[0];
                    const location = result.geometry.location;
                    
                    // Criar um novo ID para este local
                    const id = ++lastLocationId;
                    
                    // Guardar o local
                    locations.push({
                        id: id,
                        name: name,
                        address: formattedCep + ' - ' + result.formatted_address,
                        lat: location.lat(),
                        lng: location.lng(),
                        isOrigin: false
                    });
                    
                    // Adicionar marcador ao mapa
                    addMarker(location, name, id);
                    
                    // Ajustar o zoom do mapa para mostrar todos os marcadores
                    fitMapToMarkers();
                    
                    // Atualizar a lista de locais na interface
                    updateLocationsList();
                    
                    // Atualizar a lista de cidades para eventos
                    updateEventCitiesList();
                    
                    callback(true);
                } else {
                    console.error('Erro ao geocodificar CEP:', cep, status);
                    callback(false);
                }
            });
        }
        
        // Otimizar a rota
        function optimizeRoute() {
            // Verificar se h√° locais suficientes
            if (locations.length <= 1) {
                showNotification('Adicione ao menos um destino para otimizar a rota', true);
                return;
            }
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            // Desativar o bot√£o de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.disabled = true;
            optimizeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculando...';
            
            // Limpar polylines existentes
            clearAllPolylines();
            
            // Encontrar a origem
            const originLocation = locations.find(loc => loc.isOrigin) || locations[0];
            
            // Se n√£o houver origem definida, usar o primeiro local
            if (!originLocation.isOrigin) {
                originLocation.isOrigin = true;
            }
            
            // √çndice da origem no array de locais
            const originIndex = locations.findIndex(loc => loc.id === originLocation.id);
            
            // Obter o m√©todo de otimiza√ß√£o selecionado
            const routeMethod = document.querySelector('input[name="route-method"]:checked').value;
            console.log("M√©todo de otimiza√ß√£o selecionado:", routeMethod);
            
            try {
                // Usar o algoritmo TSP para otimizar a rota
                const tspResult = tspSolver.solve(locations, originIndex, routeMethod);
                console.log("Resultado TSP:", tspResult);
                
                // Construir waypoints para o Google Maps
                const waypointsForGoogleMaps = tspResult.path
                    .filter(loc => !loc.isOrigin)
                    .map(loc => ({
                        location: new google.maps.LatLng(loc.lat, loc.lng),
                        stopover: true
                    }));
                
                // Configurar a solicita√ß√£o de rota
                const request = {
                    origin: new google.maps.LatLng(originLocation.lat, originLocation.lng),
                    destination: new google.maps.LatLng(originLocation.lat, originLocation.lng),
                    waypoints: waypointsForGoogleMaps,
                    optimizeWaypoints: false, // J√° otimizamos manualmente
                    travelMode: google.maps.TravelMode.DRIVING
                };
                
                // Solicitar a rota ao Google Maps
                directionsService.route(request, function(result, status) {
                    // Ocultar o spinner
                    toggleLoadingSpinner(false);
                    
                    // Restaurar o bot√£o de otimizar
                    optimizeBtn.disabled = false;
                    optimizeBtn.innerHTML = 'Otimizar Rota';
                    
                    if (status === google.maps.DirectionsStatus.OK) {
                        // Modificar o resultado para usar nossa ordem otimizada
                        result.routes[0].waypoint_order = tspResult.waypoint_order;
                        
                        // Armazenar o caminho otimizado
                        currentOptimizedPath = {
                            origin: originLocation,
                            path: tspResult.path,
                            waypoints: tspResult.path.filter(loc => !loc.isOrigin),
                            route: result,
                            method: routeMethod
                        };
                        
                        // Calcular resumo da rota
                        currentRouteSummary = {
                            totalDistance: tspResult.distance,
                            totalDuration: tspResult.estimatedTime * 3600, // converter horas para segundos
                            formattedDistance: tspResult.distance.toFixed(1) + ' km',
                            formattedDuration: formatDuration(tspResult.estimatedTime),
                            estimatedTolls: `R$ ${(tspResult.distance * 0.15).toFixed(2)}`
                        };
                        
                        // Mostrar a rota no mapa
                        directionsRenderer.setDirections(result);
                        
                        // Atualizar os marcadores para mostrar a sequ√™ncia
                        updateMarkersWithSequence(tspResult.path);
                        
                        // Atualizar o relat√≥rio de rota
                        updateRouteReport(currentRouteSummary, result, tspResult.path, routeMethod);
                        
                        // Atualizar eventos
                        updateEventsList();
                        
                        // Atualizar restri√ß√µes
                        updateRestrictionsList();
                        
                        // Navegar para a aba de relat√≥rio
                        showTab('bottom-report');
                        
                        // Mostrar notifica√ß√£o
                        showNotification('Rota otimizada com sucesso!');
                    } else {
                        console.error("Erro ao calcular rota:", status);
                        showNotification('Erro ao calcular a rota: ' + status, true);
                    }
                });
            } catch (error) {
                // Ocultar o spinner
                toggleLoadingSpinner(false);
                
                // Restaurar o bot√£o de otimizar
                optimizeBtn.disabled = false;
                optimizeBtn.innerHTML = 'Otimizar Rota';
                
                console.error("Erro na otimiza√ß√£o:", error);
                showNotification('Erro ao otimizar rota: ' + error.message, true);
            }
        }
        
        // Formatar dura√ß√£o de horas para texto leg√≠vel
        function formatDuration(hours) {
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return `${h}h ${m}min`;
        }
        
        // Atualizar marcadores com a sequ√™ncia otimizada
        function updateMarkersWithSequence(path) {
            // Remover marcadores existentes
            markers.forEach(marker => {
                marker.setMap(null);
            });
            markers = [];
            
            // Encontrar a origem
            const origin = path.find(loc => loc.isOrigin);
            
            // Adicionar marcador de origem
            const originMarker = new google.maps.Marker({
                position: new google.maps.LatLng(origin.lat, origin.lng),
                map: map,
                label: { text: 'A', color: 'white' },
                title: origin.name,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#ff6600',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 12
                }
            });
            markers.push(originMarker);
            
            // Adicionar marcadores para os pontos de parada na ordem otimizada
            let stopIndex = 1;
            path.forEach(location => {
                if (!location.isOrigin) {
                    const marker = new google.maps.Marker({
                        position: new google.maps.LatLng(location.lat, location.lng),
                        map: map,
                        label: { text: String(stopIndex++), color: 'white' },
                        title: location.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#1976D2',
                            fillOpacity: 1,
                            strokeColor: '#ffffff',
                            strokeWeight: 2,
                            scale: 12
                        }
                    });
                    markers.push(marker);
                }
            });
        }
        
        // Atualizar o relat√≥rio de rota
        function updateRouteReport(summary, directions, path, methodName) {
            // Mapear o m√©todo para um nome amig√°vel
            const methodNames = {
                'standard': 'Padr√£o',
                'nearest': 'Mais pr√≥ximo da origem',
                'spiral': 'Em espiral'
            };
            
            const displayMethod = methodNames[methodName] || methodName;
            
            // Atualizar o resumo da rota
            const routeInfo = document.getElementById('route-info');
            routeInfo.innerHTML = `
                <div class="mb-2"><strong>M√©todo de otimiza√ß√£o:</strong> ${displayMethod}</div>
                <div class="mb-2"><strong>Dist√¢ncia total:</strong> ${summary.formattedDistance}</div>
                <div class="mb-2"><strong>Tempo estimado:</strong> ${summary.formattedDuration}</div>
                <div><strong>Ped√°gios estimados:</strong> ${summary.estimatedTolls}</div>
            `;
            
            // Atualizar a sequ√™ncia de entrega
            const routeSequence = document.getElementById('route-sequence');
            
            // Come√ßar com a origem
            const origin = path.find(loc => loc.isOrigin);
            let sequenceHTML = `
                <div class="origin-point mb-3">
                    <strong>A.</strong> ${origin.name} (Origem)
                </div>
            `;
            
            // Adicionar cada parada na ordem otimizada
            let stopIndex = 1;
            path.forEach(location => {
                if (!location.isOrigin) {
                    sequenceHTML += `
                        <div class="mb-2">
                            <strong>${stopIndex++}.</strong> ${location.name}
                        </div>
                    `;
                }
            });
            
            // Atualizar a sequ√™ncia
            routeSequence.innerHTML = sequenceHTML;
        }
        
        // Atualizar a lista de cidades com base nos locais
        function updateEventCitiesList() {
            // Extrair cidades dos locais
            const cities = [];
            
            locations.forEach(location => {
                // Tentar extrair a cidade do endere√ßo
                let city = extractCityFromAddress(location.address);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            console.log("Cidades detectadas para eventos:", uniqueCities);
        }
        
        // Extrair cidade de um endere√ßo
        function extractCityFromAddress(address) {
            // Verificar se o endere√ßo existe
            if (!address) return null;
            
            // Lista de cidades conhecidas para detectar
            const knownCities = [
                'S√£o Paulo', 'Rio de Janeiro', 'Bras√≠lia', 'Salvador', 'Fortaleza',
                'Belo Horizonte', 'Manaus', 'Curitiba', 'Recife', 'Porto Alegre',
                'Bel√©m', 'Goi√¢nia', 'Guarulhos', 'Campinas', 'S√£o Lu√≠s',
                'S√£o Gon√ßalo', 'Macei√≥', 'Duque de Caxias', 'Natal', 'Teresina',
                'Ja√∫', 'Bauru', 'Dois C√≥rregos', 'Araraquara', 'S√£o Carlos'
            ];
            
            // Verificar se alguma cidade conhecida est√° no endere√ßo
            for (const city of knownCities) {
                if (address.includes(city)) {
                    return city;
                }
            }
            
            // Outra tentativa: verificar palavras que come√ßam com mai√∫scula e n√£o s√£o abrevia√ß√µes
            const words = address.split(/[\s,-]+/);
            for (const word of words) {
                if (word.length > 2 && 
                    word === word.charAt(0).toUpperCase() + word.slice(1).toLowerCase() &&
                    !word.match(/^[A-Z]{2,3}$/)) {  // Excluir abrevia√ß√µes como "SP", "RJ"
                    return word;
                }
            }
            
            return null;
        }
        
        // Atualizar a lista de eventos
        function updateEventsList() {
            // Verificar se h√° uma rota otimizada
            if (!currentOptimizedPath) {
                return;
            }
            
            // Extrair cidades da rota otimizada
            const cities = [];
            currentOptimizedPath.path.forEach(location => {
                let city = extractCityFromAddress(location.address || location.name);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            // Obter as datas selecionadas
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            // Obter eventos mockados nas cidades e datas
            const events = getMockEvents(uniqueCities, startDate, endDate);
            
            // Atualizar a interface
            const eventsContainer = document.getElementById('events-list');
            
            if (events.length === 0) {
                eventsContainer.innerHTML = `
                    <p class="text-muted">Nenhum evento encontrado nas cidades da rota para as datas selecionadas.</p>
                `;
                return;
            }
            
            let eventsHTML = '';
            
            events.forEach(event => {
                // Formatar data
                const eventDate = new Date(event.date);
                const formattedDate = eventDate.toLocaleDateString('pt-BR');
                
                eventsHTML += `
                    <div class="event-item">
                        <span class="event-badge">Evento</span>
                        <h5>${event.name}</h5>
                        <p><strong>Cidade:</strong> ${event.city}</p>
                        <p><strong>Data:</strong> ${formattedDate}</p>
                        <p>${event.description}</p>
                    </div>
                `;
            });
            
            eventsContainer.innerHTML = eventsHTML;
        }
        
        // Obter eventos mockados
        function getMockEvents(cities, startDate, endDate) {
            // Verificar se temos datas v√°lidas
            if (!startDate || !endDate) {
                return [];
            }
            
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            // Lista de eventos mockados
            const allEvents = [
                {
                    name: "Feriado Municipal",
                    city: "Dois C√≥rregos",
                    date: "2025-05-13",
                    description: "Feriado municipal em comemora√ß√£o √† funda√ß√£o da cidade."
                },
                {
                    name: "Festival de M√∫sica",
                    city: "Ja√∫",
                    date: "2025-05-15",
                    description: "Festival de m√∫sica com apresenta√ß√µes em pra√ßa p√∫blica."
                },
                {
                    name: "Feira Agropecu√°ria",
                    city: "Bauru",
                    date: "2025-05-17",
                    description: "Exposi√ß√£o agropecu√°ria com demonstra√ß√µes de equipamentos."
                },
                {
                    name: "Congresso de Tecnologia",
                    city: "S√£o Carlos",
                    date: "2025-05-20",
                    description: "Congresso de inova√ß√£o tecnol√≥gica na universidade."
                }
            ];
            
            // Filtrar eventos por cidade e data
            return allEvents.filter(event => {
                const eventDate = new Date(event.date);
                const isInDateRange = eventDate >= start && eventDate <= end;
                const isInCity = cities.includes(event.city);
                
                return isInDateRange && isInCity;
            });
        }
        
        // Atualizar a lista de restri√ß√µes
        function updateRestrictionsList() {
            // Verificar se h√° uma rota otimizada
            if (!currentOptimizedPath) {
                return;
            }
            
            // Extrair cidades da rota otimizada
            const cities = [];
            currentOptimizedPath.path.forEach(location => {
                let city = extractCityFromAddress(location.address || location.name);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            // Obter o tipo de ve√≠culo selecionado
            const vehicleType = document.getElementById('vehicle-type').value;
            
            // Obter restri√ß√µes mockadas nas cidades para o tipo de ve√≠culo
            const restrictions = getMockRestrictions(uniqueCities, vehicleType);
            
            // Atualizar a interface
            const restrictionsContainer = document.getElementById('restrictions-list');
            
            if (restrictions.length === 0) {
                restrictionsContainer.innerHTML = `
                    <p class="text-muted">Nenhuma restri√ß√£o encontrada para o tipo de ve√≠culo selecionado nas cidades da rota.</p>
                `;
                return;
            }
            
            let restrictionsHTML = '';
            
            restrictions.forEach(restriction => {
                restrictionsHTML += `
                    <div class="restriction-item">
                        <span class="restriction-badge">Restri√ß√£o</span>
                        <h5>${restriction.city}</h5>
                        <p><strong>Tipo:</strong> ${restriction.type}</p>
                        <p><strong>Ve√≠culos afetados:</strong> ${restriction.vehicleTypes.join(', ')}</p>
                        <p><strong>Hor√°rio:</strong> ${restriction.time}</p>
                        <p>${restriction.description}</p>
                    </div>
                `;
            });
            
            restrictionsContainer.innerHTML = restrictionsHTML;
        }
        
        // Obter restri√ß√µes mockadas
        function getMockRestrictions(cities, vehicleType) {
            // Mapear o tipo de ve√≠culo para o nome leg√≠vel
            const vehicleTypeMapping = {
                'truck1': 'Caminh√£o 1 eixo',
                'truck2': 'Caminh√£o 2 eixos',
                'truck3': 'Caminh√£o 3 eixos',
                'truck4': 'Caminh√£o 4 eixos',
                'truck5': 'Caminh√£o 5 eixos',
                'truck6': 'Caminh√£o 6 eixos+'
            };
            
            const selectedVehicleTypeName = vehicleTypeMapping[vehicleType] || vehicleType;
            
            // Lista de restri√ß√µes mockadas
            const allRestrictions = [
                {
                    city: "Dois C√≥rregos",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 07:00 √†s 09:00 e das 17:00 √†s 19:00",
                    description: "Restri√ß√£o de circula√ß√£o no centro da cidade."
                },
                {
                    city: "Ja√∫",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 2 eixos", "Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 08:00 √†s 19:00",
                    description: "Restri√ß√£o de circula√ß√£o no quadril√°tero central."
                },
                {
                    city: "Bauru",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Todos os dias das 07:00 √†s 20:00",
                    description: "Restri√ß√£o de circula√ß√£o nas avenidas principais."
                },
                {
                    city: "S√£o Carlos",
                    type: "Total",
                    vehicleTypes: ["Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 07:00 √†s 19:00",
                    description: "Proibida a circula√ß√£o dentro do per√≠metro urbano."
                }
            ];
            
            // Filtrar restri√ß√µes por cidade e tipo de ve√≠culo
            return allRestrictions.filter(restriction => {
                const isInCity = cities.includes(restriction.city);
                const appliesToVehicle = restriction.vehicleTypes.includes(selectedVehicleTypeName);
                
                return isInCity && appliesToVehicle;
            });
        }
        
        // Carregar dados iniciais
        async function fetchInitialData() {
            // Carregar a origem (Dois C√≥rregos-SP)
            const originData = {
                id: 0,
                name: "Dois C√≥rregos",
                address: "Dois C√≥rregos, SP, Brasil",
                lat: -22.3636,
                lng: -48.3798,
                isOrigin: true
            };
            
            // Guardar a origem
            locations.push(originData);
            origin = originData;
            
            // Adicionar marcador para a origem
            const originLocation = new google.maps.LatLng(originData.lat, originData.lng);
            addMarker(originLocation, originData.name, originData.id, true);
            
            // Centralizar o mapa na origem
            map.setCenter(originLocation);
            map.setZoom(13);
            
            // Atualizar o campo de origem no formul√°rio
            document.getElementById('origin').value = originData.address;
            
            return true;
        }
    </script>
</body>
</html>