<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1976D2">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Otimizador de Rotas para log√≠stica e transporte, com suporte a c√°lculo de rotas entre m√∫ltiplos pontos, otimiza√ß√£o de sequ√™ncia, e visualiza√ß√£o de eventos e restri√ß√µes em cidades brasileiras." />
    <meta name="keywords" content="otimizador de rotas, problema do caixeiro viajante, log√≠stica, transporte, planejamento de rotas, otimiza√ß√£o de entregas, Brasil, Google Maps, ped√°gios, eventos em cidades" />
    <meta name="author" content="Otimizador de Rotas" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Otimizador de Rotas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Estilos globais */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Evita scroll duplo */
        }
        header {
            background-color: #1976D2;
            color: white;
            padding: 10px 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .header-title {
            margin: 0;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        /* Layout principal */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Sidebar */
        .sidebar {
            width: 320px;
            background-color: white;
            border-right: 1px solid #e0e0e0;
            box-shadow: 1px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 10;
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        /* Container da parte principal */
        .content-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* √Årea do mapa */
        .map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        
        /* Formul√°rios e controles */
        .form-control, .btn {
            border-radius: 4px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        /* Bot√£o de toggle para o sidebar */
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
        }
        
        /* Bot√£o de otimizar rota */
        .optimize-container {
            padding: 15px;
            background-color: #f0f4f8;
            border-top: 1px solid #ddd;
            margin-top: auto;
        }
        #optimize-route {
            width: 100%;
            font-weight: bold;
        }
        
        /* Estilos para locais na lista */
        .locations-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .location-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .location-item:last-child {
            border-bottom: none;
        }
        .location-delete {
            color: #e53935;
            cursor: pointer;
            opacity: 0.7;
        }
        .location-delete:hover {
            opacity: 1;
        }
        
        /* Loading spinner */
        .loading-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Bot√£o de abrir sidebar (para mobile) */
        .mobile-sidebar-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: #1976D2;
            color: white;
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-size: 24px;
            transition: all 0.3s ease;
        }
        .mobile-sidebar-toggle:active {
            transform: scale(0.95);
        }
        
        /* Anima√ß√£o de aparecimento */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* NOVO: Estilos espec√≠ficos para as abas inferiores */
        .bottom-tabs-container {
            background-color: white;
            border-top: 2px solid #1976D2;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            height: 60vh;
            max-height: 60vh;
            transition: all 0.3s ease;
            z-index: 900;
        }
        
        .bottom-tabs-container.minimized {
            height: 60px;
        }
        
        .bottom-tabs-nav {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: linear-gradient(to top, #1565C0, #1976D2);
            border-bottom: 2px solid #0d47a1;
            flex-shrink: 0;
        }
        
        .bottom-tab-btn {
            padding: 10px 15px;
            border: 1px solid rgba(255,255,255,0.5);
            background-color: rgba(255,255,255,0.1);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .bottom-tab-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .bottom-tab-btn.active {
            background-color: white;
            color: #1976D2;
            font-weight: bold;
            border-color: white;
        }
        
        .bottom-tab-btn::before {
            display: inline-block;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        
        .bottom-tab-btn[data-tab="bottom-events"]::before {
            content: "üóìÔ∏è";
        }
        
        .bottom-tab-btn[data-tab="bottom-restrictions"]::before {
            content: "üö´";
        }
        
        .bottom-tab-btn[data-tab="bottom-report"]::before {
            content: "üìä";
        }
        
        .bottom-tabs-content-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        
        .bottom-tab-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 20px;
            overflow-y: auto;
            background-color: white;
            display: none;
        }
        
        .bottom-tab-content.active {
            display: block;
        }
        
        /* Estilos para eventos e restri√ß√µes */
        .event-item, .restriction-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .event-badge, .restriction-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .event-badge {
            background-color: #e3f2fd;
            color: #1565C0;
        }
        
        .restriction-badge {
            background-color: #ffebee;
            color: #c62828;
        }

        /* Estilos para op√ß√µes de rota */
        .route-options {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }
        
        .route-options legend {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .route-option {
            margin-bottom: 10px;
        }
        
        .route-option input[type="radio"] {
            margin-right: 8px;
        }
        
        .route-option label {
            font-weight: normal;
            cursor: pointer;
        }
        
        .route-method-info {
            margin-top: 5px;
            font-size: 13px;
            color: #666;
            margin-left: 25px;
        }
        
        /* Responsividade */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 1000;
                width: 85%;
                max-width: 320px;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar.visible {
                transform: translateX(0);
            }
            
            .toggle-sidebar {
                display: block;
            }
            
            .mobile-sidebar-toggle {
                display: block;
            }
            
            /* Overlay para quando o sidebar estiver aberto */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0,0,0,0.5);
                z-index: 999;
            }
            
            .sidebar-overlay.visible {
                display: block;
            }
            
            /* Ajuste para abas inferiores em telas pequenas */
            .bottom-tabs-container {
                height: 50vh;
            }
            
            /* Tornar o conte√∫do de abas mais compacto em telas pequenas */
            .bottom-tab-content {
                padding: 15px 10px;
            }
        }
        
        /* Print styles - esconder mapa para melhor gera√ß√£o de PDF */
        @media print {
            .map-container {
                display: none;
            }
            
            .sidebar {
                width: 100%;
                box-shadow: none;
                border: none;
            }
            
            .bottom-tabs-container {
                height: auto;
                box-shadow: none;
            }
            
            .bottom-tabs-nav {
                display: none;
            }
            
            .bottom-tab-content {
                display: block !important;
                position: static;
                overflow: visible;
                page-break-inside: avoid;
            }
            
            .optimize-container, .mobile-sidebar-toggle, .toggle-sidebar {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Spinner -->
    <div class="loading-container" id="loading-spinner">
        <div class="spinner"></div>
    </div>
    
    <!-- Cabe√ßalho -->
    <header>
        <h1 class="header-title">Otimizador de Rotas</h1>
    </header>
    
    <!-- Container principal -->
    <div class="main-container">
        <!-- Overlay para sidebar em mobile -->
        <div class="sidebar-overlay" id="sidebar-overlay"></div>
        
        <!-- Sidebar para entrada de dados -->
        <div class="sidebar" id="sidebar">
            <!-- Bot√£o para fechar sidebar em mobile -->
            <button class="btn btn-sm btn-light sidebar-close" id="close-sidebar">
                <i class="fas fa-times"></i>
            </button>
            
            <div class="p-3">
                <h5 class="mb-3">Datas da rota</h5>
                <div class="row">
                    <div class="col-6">
                        <div class="form-group">
                            <label class="form-label" for="start-date">Data inicial:</label>
                            <input type="date" class="form-control" id="start-date">
                        </div>
                    </div>
                    <div class="col-6">
                        <div class="form-group">
                            <label class="form-label" for="end-date">Data final:</label>
                            <input type="date" class="form-control" id="end-date">
                        </div>
                    </div>
                </div>
                
                <h5 class="mb-3 mt-4">Origem</h5>
                <div class="form-group">
                    <label class="form-label" for="origin">Ponto de partida:</label>
                    <input type="text" class="form-control" id="origin" readonly>
                </div>
                
                <h5 class="mb-3 mt-4">Destinos</h5>
                
                <div class="form-group">
                    <label class="form-label" for="address-input">Adicionar endere√ßo:</label>
                    <div class="input-group mb-3">
                        <input type="text" class="form-control" id="address-input" placeholder="Digite um endere√ßo ou CEP">
                        <button class="btn btn-primary" id="add-location">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Ou envie um arquivo com CEPs:</label>
                    <div class="input-group mb-3">
                        <input type="file" class="form-control" id="cep-file" accept=".txt,.csv">
                        <button class="btn btn-outline-secondary" id="upload-cep">
                            <i class="fas fa-upload"></i>
                        </button>
                    </div>
                    <small class="text-muted">Formato: CEP,nome (um por linha)</small>
                </div>
                
                <h5 class="mb-2">Locais adicionados</h5>
                <div class="locations-list" id="locations-list">
                    <div class="p-3 text-muted">Nenhum local adicionado.</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="vehicle-type">Tipo de ve√≠culo:</label>
                    <select class="form-select" id="vehicle-type">
                        <option value="truck1">Caminh√£o 1 eixo</option>
                        <option value="truck2">Caminh√£o 2 eixos</option>
                        <option value="truck3">Caminh√£o 3 eixos</option>
                        <option value="truck4">Caminh√£o 4 eixos</option>
                        <option value="truck5">Caminh√£o 5 eixos</option>
                        <option value="truck6">Caminh√£o 6 eixos+</option>
                    </select>
                </div>
                
                <!-- NOVO: Op√ß√µes de m√©todo de otimiza√ß√£o de rota -->
                <div class="form-group mt-4">
                    <fieldset class="route-options">
                        <legend>M√©todo de otimiza√ß√£o:</legend>
                        
                        <div class="route-option">
                            <input type="radio" id="route-standard" name="route-method" value="standard" checked>
                            <label for="route-standard">Padr√£o</label>
                            <div class="route-method-info">Otimiza√ß√£o b√°sica baseada no algoritmo do Caixeiro Viajante.</div>
                        </div>
                        
                        <div class="route-option">
                            <input type="radio" id="route-nearest" name="route-method" value="nearest">
                            <label for="route-nearest">Mais pr√≥ximo da origem</label>
                            <div class="route-method-info">Prioriza locais mais pr√≥ximos do ponto de partida.</div>
                        </div>
                        
                        <div class="route-option">
                            <input type="radio" id="route-spiral" name="route-method" value="spiral">
                            <label for="route-spiral">Em espiral</label>
                            <div class="route-method-info">Percorre em forma de espiral a partir da origem.</div>
                        </div>
                    </fieldset>
                </div>
            </div>
            
            <!-- Bot√£o de otimizar (fixo na parte inferior) -->
            <div class="optimize-container">
                <button class="btn btn-success" id="optimize-route">Otimizar Rota</button>
            </div>
        </div>
        
        <!-- Container do conte√∫do principal -->
        <div class="content-container">
            <!-- Bot√£o para mostrar sidebar em mobile -->
            <button class="toggle-sidebar" id="toggle-sidebar">
                <i class="fas fa-bars"></i>
            </button>
            
            <!-- Container do mapa -->
            <div class="map-container">
                <div id="map"></div>
            </div>
            
            <!-- NOVO: Tabs fixas na parte inferior do layout (inicialmente minimizadas) -->
            <div class="bottom-tabs-container minimized">
                <!-- Navega√ß√£o das abas inferiores -->
                <div class="bottom-tabs-nav">
                    <button class="bottom-tab-btn active" data-tab="bottom-events" onclick="showTab('bottom-events')">
                        Eventos na Rota
                    </button>
                    <button class="bottom-tab-btn" data-tab="bottom-restrictions" onclick="showTab('bottom-restrictions')">
                        Restri√ß√µes de Tr√°fego
                    </button>
                    <button class="bottom-tab-btn" data-tab="bottom-report" onclick="showTab('bottom-report')">
                        Relat√≥rio da Rota
                    </button>
                </div>
                
                <!-- Container das abas com rolagem independente para cada aba -->
                <div class="bottom-tabs-content-container">
                    <!-- Conte√∫do da aba Eventos -->
                    <div class="bottom-tab-content active" id="bottom-events-content">
                        <h5>Eventos nas cidades da rota:</h5>
                        <div class="events-list" id="events-list">
                            <p class="text-muted">Nenhum evento encontrado. Adicione locais e otimize a rota para ver eventos nas cidades do percurso.</p>
                        </div>
                    </div>
                    
                    <!-- Conte√∫do da aba Restri√ß√µes -->
                    <div class="bottom-tab-content" id="bottom-restrictions-content">
                        <h5>Restri√ß√µes de tr√°fego para caminh√µes:</h5>
                        <div class="restrictions-list" id="restrictions-list">
                            <p class="text-muted">Nenhuma restri√ß√£o encontrada. Adicione locais e otimize a rota para ver as restri√ß√µes de tr√°fego.</p>
                        </div>
                    </div>
                    
                    <!-- Conte√∫do da aba Relat√≥rio -->
                    <div class="bottom-tab-content" id="bottom-report-content">
                        <h5>Resumo da rota otimizada:</h5>
                        <div class="route-info p-3 border rounded mb-3 bg-light" id="route-info">
                            <p class="text-muted">Otimize a rota para ver o relat√≥rio detalhado.</p>
                        </div>
                        
                        <h5>Sequ√™ncia de entrega:</h5>
                        <div class="route-sequence border rounded p-3" id="route-sequence">
                            <p class="text-muted">A sequ√™ncia de rota ser√° exibida aqui ap√≥s a otimiza√ß√£o.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bot√£o flutuante para abrir o sidebar em mobile -->
    <button class="mobile-sidebar-toggle" id="mobile-sidebar-toggle">
        <i class="fas fa-edit"></i>
    </button>
    
    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCnallnTQ8gT2_F600vt-yAEv2BoH0mj7U&libraries=places"></script>
    
    <!-- jQuery para opera√ß√µes mais simples -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Controle de abas -->
    <script>
    // Fun√ß√£o para controlar as abas
    function showTab(tabName) {
        console.log('Mostrando aba:', tabName);
        
        // Primeiro, esconder todos os conte√∫dos das abas
        var allContents = document.querySelectorAll('.bottom-tab-content');
        allContents.forEach(function(content) {
            content.style.display = 'none';
            content.classList.remove('active');
        });
        
        // Depois, mostrar apenas o conte√∫do da aba selecionada
        var selectedContent = document.getElementById(tabName + '-content');
        if (selectedContent) {
            selectedContent.style.display = 'block';
            selectedContent.classList.add('active');
            console.log('Ativado conte√∫do:', tabName + '-content');
        } else {
            console.error('Conte√∫do n√£o encontrado para aba:', tabName);
        }
        
        // Atualizar classes ativas nos bot√µes
        var allButtons = document.querySelectorAll('.bottom-tab-btn');
        allButtons.forEach(function(button) {
            button.classList.remove('active');
            
            if (button.getAttribute('data-tab') === tabName) {
                button.classList.add('active');
            }
        });
        
        // Expandir o container se estiver minimizado
        var tabsContainer = document.querySelector('.bottom-tabs-container');
        if (tabsContainer && tabsContainer.classList.contains('minimized')) {
            tabsContainer.classList.remove('minimized');
        }
    }
    
    // Garantir que as abas funcionem corretamente ap√≥s otimiza√ß√£o
    document.addEventListener('DOMContentLoaded', function() {
        // Modificar o bot√£o de otimiza√ß√£o
        var optimizeButton = document.getElementById('optimize-route');
        if (optimizeButton) {
            // Guardar o onclick original
            var originalOnclick = optimizeButton.onclick;
            
            // Definir novo onclick
            optimizeButton.onclick = function(event) {
                // Chamar o handler original se ele existir
                if (typeof originalOnclick === 'function') {
                    originalOnclick.call(this, event);
                }
                
                // Agendar navega√ß√£o para a aba de relat√≥rio
                setTimeout(function() {
                    showTab('bottom-report');
                }, 2000);
            };
        }
        
        // Inicializa√ß√£o - mostrar aba de eventos
        setTimeout(function() {
            showTab('bottom-events');
        }, 500);
    });
    </script>
    
    <!-- Script Principal -->
    <script>
        // Vari√°veis globais
        let map;
        let markers = [];
        let locations = [];
        let origin = null;
        let autocomplete;
        let directionsService;
        let directionsRenderer;
        let currentOptimizedPath = null;
        let currentRouteSummary = null;
        let allPolylines = [];
        let autocompleteService;
        let placesService;
        let geocoder;
        let currentStepIndex = 0;
        let animationTimeout;
        
        // Pontos de interesse (ped√°gios, balan√ßas, etc.)
        let pointsOfInterest = [];
        let poiMarkers = [];
        
        // ID do √∫ltimo local adicionado
        let lastLocationId = 0;
        
        // Configura√ß√µes padr√£o
        const DEFAULT_SPEED = 80; // km/h
        
        // Constantes para POIs
        const POI_TYPES = {
            TOLL: 'toll',
            WEIGHING: 'weighing',
            GAS: 'gas',
            REST: 'rest'
        };
        
        // Mapeamento de √≠cones para POIs
        const POI_ICONS = {
            [POI_TYPES.TOLL]: 'üí∞',
            [POI_TYPES.WEIGHING]: '‚öñÔ∏è',
            [POI_TYPES.GAS]: '‚õΩ',
            [POI_TYPES.REST]: 'üõå'
        };
        
        // Inicializa√ß√£o ap√≥s o carregamento da p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            // Verificar se estamos usando dados mocked ou n√£o
            const useMockData = true;
            console.log("Using mock data:", useMockData);
            
            // Inicializar o mapa quando a API Google Maps estiver pronta
            initMap();
            
            // Inicializar a interface do usu√°rio
            initUI();
            
            // Preencher com dados iniciais
            if (useMockData) {
                fetchMockData()
                .then(() => {
                    console.log("Seed data loaded successfully");
                    // Atualizar a lista de cidades para eventos
                    updateEventCitiesList();
                })
                .catch(error => {
                    console.error("Error loading seed data:", error);
                });
            }
        });
        
        // Inicializar o mapa
        function initMap() {
            console.log("Iniciando carregamento da Google Maps API...");
            
            // Criar o mapa
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: -22.3636, lng: -48.3798 }, // Dois C√≥rregos, SP
                zoom: 13,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                gestureHandling: 'greedy', // Permitir zoom sem Ctrl
                zoomControl: true,
                mapTypeControl: true,
                scaleControl: true,
                streetViewControl: true,
                rotateControl: true,
                fullscreenControl: true
            });
            
            // Modificar gestureHandling para permitir zoom sem Ctrl
            try {
                // Este √© um hack para permitir zoom sem Ctrl
                map.setOptions({ gestureHandling: 'auto' });
                console.log("Google Maps gesture handling modificado para permitir zoom sem Ctrl");
            } catch (e) {
                console.error("Erro ao modificar gesture handling:", e);
            }
            
            // Inicializar servi√ßos do Google Maps
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                suppressMarkers: true, // N√£o mostrar marcadores autom√°ticos
                polylineOptions: {
                    strokeColor: '#1976D2',
                    strokeWeight: 5,
                    strokeOpacity: 0.7
                }
            });
            
            geocoder = new google.maps.Geocoder();
            
            // Inicializar o servi√ßo de autocompletar para endere√ßos
            autocomplete = new google.maps.places.Autocomplete(
                document.getElementById('address-input'),
                { types: ['geocode'], componentRestrictions: { country: 'br' } }
            );
            
            // Inicializar o servi√ßo de autocompletar para busca program√°tica
            autocompleteService = new google.maps.places.AutocompleteService();
            placesService = new google.maps.places.PlacesService(map);
            
            console.log("Google Maps API loaded");
            
            // Configurar a API Places
            const placesOptions = {
                types: ['geocode'],
                componentRestrictions: { country: 'br' }
            };
            
            try {
                // Inicializar o autocomplete do Places
                autocomplete = new google.maps.places.Autocomplete(
                    document.getElementById('address-input'),
                    placesOptions
                );
                
                // Prevenir submiss√£o do formul√°rio ao pressionar Enter
                document.getElementById('address-input').addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        return false;
                    }
                });
                
                console.log("Google Places API loaded");
            } catch (e) {
                console.error("Erro ao inicializar Google Places API:", e);
            }
            
            // Adicionar eventos para detectar quando o mapa est√° totalmente carregado
            google.maps.event.addListenerOnce(map, 'idle', function() {
                // O mapa est√° totalmente carregado
                try {
                    // Tentar aplicar o helper de zoom
                    setTimeout(applyZoomHelper, 1000);
                } catch (e) {
                    console.error("Erro ao aplicar helper de zoom:", e);
                }
            });
        }
        
        // Helper para facilitar o zoom no mapa
        function applyZoomHelper() {
            // Encontrar o elemento .gm-style dentro do mapa
            const gmStyleElement = document.querySelector('.gm-style');
            
            if (gmStyleElement) {
                // Adicionar um evento para capturar scroll e transformar em zoom
                gmStyleElement.addEventListener('wheel', function(e) {
                    // Se a tecla Ctrl n√£o estiver pressionada, ainda assim permitir o zoom
                    if (!e.ctrlKey) {
                        e.stopPropagation();
                        
                        // Criar um novo evento com a tecla Ctrl pressionada
                        const newEvent = new WheelEvent('wheel', {
                            bubbles: true,
                            cancelable: true,
                            composed: true,
                            deltaMode: e.deltaMode,
                            deltaX: e.deltaX,
                            deltaY: e.deltaY,
                            deltaZ: e.deltaZ,
                            ctrlKey: true
                        });
                        
                        // Disparar o novo evento
                        gmStyleElement.dispatchEvent(newEvent);
                    }
                }, { passive: false });
                
                console.log("Helper de zoom aplicado ao mapa do Google");
            } else {
                console.log("Nenhum elemento .gm-style encontrado para aplicar helper de zoom");
            }
        }
        
        // Inicializar a interface do usu√°rio
        function initUI() {
            // Eventos para o sidebar em dispositivos m√≥veis
            document.getElementById('toggle-sidebar').addEventListener('click', toggleSidebar);
            document.getElementById('close-sidebar').addEventListener('click', toggleSidebar);
            document.getElementById('sidebar-overlay').addEventListener('click', toggleSidebar);
            document.getElementById('mobile-sidebar-toggle').addEventListener('click', toggleSidebar);
            
            // Evento para adicionar um local
            document.getElementById('add-location').addEventListener('click', addLocation);
            
            // Evento para o upload de arquivo de CEPs
            document.getElementById('upload-cep').addEventListener('click', uploadCEPFile);
            
            // Evento para otimizar a rota
            document.getElementById('optimize-route').addEventListener('click', optimizeRoute);
            
            // Inicializar as datas padr√£o (hoje e hoje + 7 dias)
            const today = new Date();
            const nextWeek = new Date();
            nextWeek.setDate(today.getDate() + 7);
            
            document.getElementById('start-date').valueAsDate = today;
            document.getElementById('end-date').valueAsDate = nextWeek;
        }
        
        // Toggle para o sidebar em dispositivos m√≥veis
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            
            sidebar.classList.toggle('visible');
            overlay.classList.toggle('visible');
        }
        
        // Exibir/ocultar o spinner de carregamento
        function toggleLoadingSpinner(show) {
            const spinner = document.getElementById('loading-spinner');
            spinner.style.display = show ? 'flex' : 'none';
        }
        
        // Mostrar uma notifica√ß√£o na interface
        function showNotification(message, isError = false) {
            // Verificar se j√° existe uma notifica√ß√£o
            let notification = document.querySelector('.notification');
            
            // Se n√£o existir, criar uma nova
            if (!notification) {
                notification = document.createElement('div');
                notification.className = 'notification';
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.padding = '15px 20px';
                notification.style.borderRadius = '4px';
                notification.style.color = 'white';
                notification.style.zIndex = '2000';
                notification.style.maxWidth = '300px';
                notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                notification.style.transition = 'all 0.3s ease';
                notification.style.fontWeight = 'bold';
                
                document.body.appendChild(notification);
            }
            
            // Configurar a apar√™ncia com base no tipo
            notification.style.backgroundColor = isError ? '#f44336' : '#4caf50';
            notification.textContent = message;
            
            // Mostrar a notifica√ß√£o
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
            
            // Esconder ap√≥s alguns segundos
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                
                // Remover do DOM ap√≥s a anima√ß√£o
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Adicionar um marcador ao mapa
        function addMarker(location, title, id, isOrigin = false) {
            // Verificar se √© um marcador de origem
            const markerOptions = {
                position: location,
                map: map,
                title: title
            };
            
            // Usar √≠cones ou cores diferentes para distinguir
            if (isOrigin) {
                markerOptions.icon = {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#ff6600',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 10
                };
            }
            
            const marker = new google.maps.Marker(markerOptions);
            
            // Armazenar o ID no marcador para refer√™ncia futura
            marker.set('id', id);
            
            // Adicionar evento de clique para mostrar info
            marker.addListener('click', function() {
                // Implementar conforme necess√°rio
            });
            
            markers.push(marker);
            return marker;
        }
        
        // Adicionar um local √† lista
        function addLocation() {
            const input = document.getElementById('address-input');
            const address = input.value.trim();
            
            if (!address) {
                showNotification('Por favor, digite um endere√ßo v√°lido', true);
                return;
            }
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            // Usar o geocoder para obter coordenadas
            geocoder.geocode({ address: address + ', Brasil' }, function(results, status) {
                // Ocultar o spinner
                toggleLoadingSpinner(false);
                
                if (status === google.maps.GeocoderStatus.OK && results.length > 0) {
                    const result = results[0];
                    const location = result.geometry.location;
                    
                    // Criar um novo ID para este local
                    const id = ++lastLocationId;
                    
                    // Guardar o local
                    locations.push({
                        id: id,
                        name: result.formatted_address,
                        address: result.formatted_address,
                        lat: location.lat(),
                        lng: location.lng(),
                        isOrigin: false
                    });
                    
                    // Adicionar marcador ao mapa
                    addMarker(location, result.formatted_address, id);
                    
                    // Ajustar o zoom do mapa para mostrar todos os marcadores
                    fitMapToMarkers();
                    
                    // Atualizar a lista de locais na interface
                    updateLocationsList();
                    
                    // Atualizar a lista de cidades para eventos
                    updateEventCitiesList();
                    
                    // Mostrar notifica√ß√£o de sucesso
                    showNotification('Local adicionado com sucesso');
                } else {
                    showNotification('N√£o foi poss√≠vel geocodificar o endere√ßo: ' + status, true);
                }
                
                // Limpar o campo de busca
                input.value = '';
            });
        }
        
        // Ajustar o zoom do mapa para mostrar todos os marcadores
        function fitMapToMarkers() {
            if (markers.length === 0) return;
            
            const bounds = new google.maps.LatLngBounds();
            
            markers.forEach(marker => {
                bounds.extend(marker.getPosition());
            });
            
            map.fitBounds(bounds);
            
            // Se houver apenas um marcador, zoom mais pr√≥ximo
            if (markers.length === 1) {
                map.setZoom(14);
            }
        }
        
        // Atualizar a lista de locais na interface
        function updateLocationsList() {
            const listElement = document.getElementById('locations-list');
            
            // Limpar a lista atual
            listElement.innerHTML = '';
            
            // Verificar se h√° locais
            if (locations.length === 0) {
                listElement.innerHTML = '<div class="p-3 text-muted">Nenhum local adicionado.</div>';
                return;
            }
            
            // Adicionar cada local √† lista
            locations.forEach(location => {
                if (!location.isOrigin) { // N√£o incluir a origem na lista de destinos
                    const item = document.createElement('div');
                    item.className = 'location-item';
                    item.innerHTML = `
                        <div>${location.name}</div>
                        <div class="location-delete" data-id="${location.id}" title="Remover">
                            <i class="fas fa-trash"></i>
                        </div>
                    `;
                    
                    listElement.appendChild(item);
                }
            });
            
            // Adicionar evento de clique para remover locais
            const deleteButtons = document.querySelectorAll('.location-delete');
            deleteButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    removeLocation(id);
                });
            });
        }
        
        // Remover um local da lista
        function removeLocation(id) {
            // Encontrar o √≠ndice do local
            const index = locations.findIndex(loc => loc.id === id);
            
            if (index !== -1) {
                // Remover do array de locais
                locations.splice(index, 1);
                
                // Remover o marcador correspondente
                const markerIndex = markers.findIndex(marker => marker.get('id') === id);
                if (markerIndex !== -1) {
                    markers[markerIndex].setMap(null);
                    markers.splice(markerIndex, 1);
                }
                
                // Atualizar a lista na interface
                updateLocationsList();
                
                // Atualizar a lista de cidades para eventos
                updateEventCitiesList();
                
                // Mostrar notifica√ß√£o
                showNotification('Local removido com sucesso');
                
                // Limpar quaisquer rotas existentes
                clearAllPolylines();
                if (directionsRenderer) {
                    directionsRenderer.setDirections({ routes: [] });
                }
                
                // Limpar informa√ß√µes de rota
                document.getElementById('route-info').innerHTML = `
                    <p class="text-muted">Otimize a rota para ver o relat√≥rio detalhado.</p>
                `;
                document.getElementById('route-sequence').innerHTML = `
                    <p class="text-muted">A sequ√™ncia de rota ser√° exibida aqui ap√≥s a otimiza√ß√£o.</p>
                `;
            }
        }
        
        // Limpar todas as polylines no mapa
        function clearAllPolylines() {
            allPolylines.forEach(polyline => {
                polyline.setMap(null);
            });
            allPolylines = [];
        }
        
        // Processar o upload de arquivo de CEPs
        function uploadCEPFile() {
            const fileInput = document.getElementById('cep-file');
            
            if (!fileInput.files || fileInput.files.length === 0) {
                showNotification('Por favor, selecione um arquivo', true);
                return;
            }
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            reader.onload = function(e) {
                const content = e.target.result;
                
                // Processar o conte√∫do do arquivo
                processCepFile(content);
                
                // Limpar o input de arquivo
                fileInput.value = '';
                
                // Ocultar o spinner
                toggleLoadingSpinner(false);
            };
            
            reader.onerror = function() {
                toggleLoadingSpinner(false);
                showNotification('Erro ao ler o arquivo', true);
            };
            
            reader.readAsText(file);
        }
        
        // Processar o conte√∫do do arquivo de CEPs
        function processCepFile(content) {
            // Dividir por linhas
            const lines = content.split(/\r?\n/);
            
            // Verificar se h√° linhas
            if (lines.length === 0) {
                showNotification('Arquivo vazio', true);
                return;
            }
            
            // Contador para geocodifica√ß√µes bem-sucedidas
            let successCount = 0;
            let errorCount = 0;
            
            // Processar cada linha
            lines.forEach(line => {
                line = line.trim();
                if (!line) return; // Pular linhas vazias
                
                // Tentar extrair CEP e nome
                let cep, name;
                
                if (line.includes(',')) {
                    // Formato CEP,nome
                    [cep, name] = line.split(',', 2).map(s => s.trim());
                } else {
                    // Apenas CEP
                    cep = line.trim();
                    name = 'Local ' + (++lastLocationId);
                }
                
                // Validar CEP (formato brasileiro: 8 d√≠gitos)
                cep = cep.replace(/\D/g, '');
                if (cep.length !== 8) {
                    console.warn('CEP inv√°lido:', cep);
                    errorCount++;
                    return;
                }
                
                // Formatar CEP para exibi√ß√£o
                const formattedCep = cep.substring(0, 5) + '-' + cep.substring(5);
                
                // Geocodificar o CEP
                geocodeCEP(cep, formattedCep, name, function(success) {
                    if (success) {
                        successCount++;
                    } else {
                        errorCount++;
                    }
                    
                    // Verificar se terminou
                    if (successCount + errorCount === lines.filter(l => l.trim()).length) {
                        showNotification(`Processados ${successCount} CEPs com sucesso. ${errorCount} erros.`, errorCount > 0);
                    }
                });
            });
        }
        
        // Geocodificar um CEP
        function geocodeCEP(cep, formattedCep, name, callback) {
            const address = formattedCep + ', Brasil';
            
            geocoder.geocode({ address: address }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK && results.length > 0) {
                    const result = results[0];
                    const location = result.geometry.location;
                    
                    // Criar um novo ID para este local
                    const id = ++lastLocationId;
                    
                    // Guardar o local
                    locations.push({
                        id: id,
                        name: name,
                        address: formattedCep + ' - ' + result.formatted_address,
                        lat: location.lat(),
                        lng: location.lng(),
                        isOrigin: false
                    });
                    
                    // Adicionar marcador ao mapa
                    addMarker(location, name, id);
                    
                    // Ajustar o zoom do mapa para mostrar todos os marcadores
                    fitMapToMarkers();
                    
                    // Atualizar a lista de locais na interface
                    updateLocationsList();
                    
                    // Atualizar a lista de cidades para eventos
                    updateEventCitiesList();
                    
                    callback(true);
                } else {
                    console.error('Erro ao geocodificar CEP:', cep, status);
                    callback(false);
                }
            });
        }
        
        // Otimizar a rota
        function optimizeRoute() {
            // Verificar se h√° locais suficientes
            if (locations.length <= 1) {
                showNotification('Adicione ao menos um destino para otimizar a rota', true);
                return;
            }
            
            // Mostrar o spinner
            toggleLoadingSpinner(true);
            
            // Desativar o bot√£o de otimizar
            const optimizeBtn = document.getElementById('optimize-route');
            optimizeBtn.disabled = true;
            optimizeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculando...';
            
            // Limpar polylines existentes
            clearAllPolylines();
            
            // Encontrar a origem
            const originLocation = locations.find(loc => loc.isOrigin) || locations[0];
            
            // Se n√£o houver origem definida, usar o primeiro local
            if (!originLocation.isOrigin) {
                originLocation.isOrigin = true;
            }
            
            // Coletar todos os locais para otimiza√ß√£o
            const originLatLng = new google.maps.LatLng(originLocation.lat, originLocation.lng);
            const waypoints = locations.filter(loc => !loc.isOrigin).map(loc => ({
                location: new google.maps.LatLng(loc.lat, loc.lng),
                id: loc.id,
                name: loc.name,
                lat: loc.lat,
                lng: loc.lng
            }));
            
            // Se n√£o houver waypoints, n√£o h√° como calcular rota
            if (waypoints.length === 0) {
                toggleLoadingSpinner(false);
                optimizeBtn.disabled = false;
                optimizeBtn.innerHTML = 'Otimizar Rota';
                showNotification('Adicione destinos para calcular a rota', true);
                return;
            }
            
            // Obter o m√©todo de otimiza√ß√£o selecionado
            const routeMethod = document.querySelector('input[name="route-method"]:checked').value;
            
            // Calcular a rota usando o m√©todo selecionado
            if (routeMethod === 'standard') {
                // M√©todo padr√£o usando o servi√ßo de dire√ß√µes do Google Maps
                calculateStandardRoute(originLocation, waypoints)
                    .then(result => {
                        // Renderizar a rota no mapa
                        renderOptimizedRoute(result);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Navegar para a aba de relat√≥rio
                        showTab('bottom-report');
                    })
                    .catch(error => {
                        console.error('Erro ao otimizar rota padr√£o:', error);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Mostrar erro
                        showNotification('Erro ao calcular a rota: ' + error.message, true);
                    });
            } else if (routeMethod === 'nearest') {
                // M√©todo mais pr√≥ximo da origem
                calculateNearestToOriginRoute(originLocation, waypoints)
                    .then(result => {
                        // Renderizar a rota no mapa
                        renderOptimizedRoute(result);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Navegar para a aba de relat√≥rio
                        showTab('bottom-report');
                    })
                    .catch(error => {
                        console.error('Erro ao otimizar rota mais pr√≥xima da origem:', error);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Mostrar erro
                        showNotification('Erro ao calcular a rota mais pr√≥xima da origem: ' + error.message, true);
                    });
            } else if (routeMethod === 'spiral') {
                // M√©todo em espiral
                calculateSpiralRoute(originLocation, waypoints)
                    .then(result => {
                        // Renderizar a rota no mapa
                        renderOptimizedRoute(result);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Navegar para a aba de relat√≥rio
                        showTab('bottom-report');
                    })
                    .catch(error => {
                        console.error('Erro ao otimizar rota em espiral:', error);
                        
                        // Ocultar o spinner
                        toggleLoadingSpinner(false);
                        
                        // Restaurar o bot√£o de otimizar
                        optimizeBtn.disabled = false;
                        optimizeBtn.innerHTML = 'Otimizar Rota';
                        
                        // Mostrar erro
                        showNotification('Erro ao calcular a rota em espiral: ' + error.message, true);
                    });
            }
        }
        
        // Calcular a rota otimizada (m√©todo padr√£o)
        function calculateStandardRoute(origin, waypoints) {
            return new Promise((resolve, reject) => {
                // Configurar a solicita√ß√£o de rota
                const request = {
                    origin: new google.maps.LatLng(origin.lat, origin.lng),
                    destination: new google.maps.LatLng(origin.lat, origin.lng),  // Retorno ao ponto de origem
                    waypoints: waypoints.map(wp => ({
                        location: wp.location,
                        stopover: true
                    })),
                    optimizeWaypoints: true,
                    travelMode: google.maps.TravelMode.DRIVING,
                    avoidHighways: false,
                    avoidTolls: false
                };
                
                // Solicitar a rota
                directionsService.route(request, function(result, status) {
                    if (status === google.maps.DirectionsStatus.OK) {
                        // Armazenar o caminho otimizado e resumo
                        currentOptimizedPath = {
                            origin: origin,
                            waypoints: waypoints,
                            order: result.routes[0].waypoint_order,
                            route: result,
                            method: 'standard'
                        };
                        
                        // Calcular resumo da rota
                        currentRouteSummary = calculateRouteSummary(result, waypoints);
                        
                        resolve({
                            directions: result,
                            summary: currentRouteSummary,
                            order: result.routes[0].waypoint_order,
                            originalWaypoints: waypoints,
                            method: 'standard'
                        });
                    } else {
                        reject(new Error('Erro no c√°lculo da rota padr√£o: ' + status));
                    }
                });
            });
        }
        
        // Calcular a rota otimizada (m√©todo mais pr√≥ximo da origem)
        function calculateNearestToOriginRoute(origin, waypoints) {
            return new Promise((resolve, reject) => {
                try {
                    // Calcular a dist√¢ncia de cada ponto em rela√ß√£o √† origem
                    const distancesFromOrigin = waypoints.map((waypoint, index) => {
                        const distance = calculateHaversineDistance(
                            origin.lat, origin.lng,
                            waypoint.lat, waypoint.lng
                        );
                        return { index, distance };
                    });
                    
                    // Ordenar pontos por dist√¢ncia da origem (mais pr√≥ximo primeiro)
                    distancesFromOrigin.sort((a, b) => a.distance - b.distance);
                    
                    // Obter a ordem dos waypoints
                    const waypointOrder = distancesFromOrigin.map(item => item.index);
                    
                    // Reordenar os waypoints
                    const orderedWaypoints = waypointOrder.map(index => waypoints[index]);
                    
                    // Configurar a solicita√ß√£o de rota com os waypoints reordenados
                    const request = {
                        origin: new google.maps.LatLng(origin.lat, origin.lng),
                        destination: new google.maps.LatLng(origin.lat, origin.lng),
                        waypoints: orderedWaypoints.map(wp => ({
                            location: new google.maps.LatLng(wp.lat, wp.lng),
                            stopover: true
                        })),
                        optimizeWaypoints: false, // N√£o otimizar, j√° est√° na ordem que queremos
                        travelMode: google.maps.TravelMode.DRIVING
                    };
                    
                    // Solicitar a rota
                    directionsService.route(request, function(result, status) {
                        if (status === google.maps.DirectionsStatus.OK) {
                            // Armazenar o caminho otimizado e resumo
                            currentOptimizedPath = {
                                origin: origin,
                                waypoints: waypoints,
                                order: waypointOrder,
                                route: result,
                                method: 'nearest'
                            };
                            
                            // Calcular resumo da rota
                            currentRouteSummary = calculateRouteSummary(result, waypoints);
                            
                            resolve({
                                directions: result,
                                summary: currentRouteSummary,
                                order: waypointOrder,
                                originalWaypoints: waypoints,
                                method: 'nearest'
                            });
                        } else {
                            reject(new Error('Erro no c√°lculo da rota mais pr√≥xima da origem: ' + status));
                        }
                    });
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Calcular a rota otimizada (m√©todo em espiral)
        function calculateSpiralRoute(origin, waypoints) {
            return new Promise((resolve, reject) => {
                try {
                    // Calcular o √¢ngulo de cada ponto em rela√ß√£o √† origem
                    const pointsWithAngles = waypoints.map((waypoint, index) => {
                        // Calcular √¢ngulo em radianos (0 √© leste, aumenta no sentido anti-hor√°rio)
                        const deltaX = waypoint.lng - origin.lng;
                        const deltaY = waypoint.lat - origin.lat;
                        let angle = Math.atan2(deltaY, deltaX);
                        
                        // Converter para graus e normalizar para 0-360
                        angle = (angle * 180 / Math.PI + 360) % 360;
                        
                        // Calcular dist√¢ncia
                        const distance = calculateHaversineDistance(
                            origin.lat, origin.lng,
                            waypoint.lat, waypoint.lng
                        );
                        
                        return { index, angle, distance };
                    });
                    
                    // Ordenar pontos por √¢ngulo (para criar uma espiral)
                    pointsWithAngles.sort((a, b) => {
                        // Se os √¢ngulos s√£o aproximadamente iguais, ordenar por dist√¢ncia
                        if (Math.abs(a.angle - b.angle) < 10) {
                            return a.distance - b.distance;
                        }
                        // Caso contr√°rio, ordenar por √¢ngulo
                        return a.angle - b.angle;
                    });
                    
                    // Obter a ordem dos waypoints
                    const waypointOrder = pointsWithAngles.map(item => item.index);
                    
                    // Reordenar os waypoints
                    const orderedWaypoints = waypointOrder.map(index => waypoints[index]);
                    
                    // Configurar a solicita√ß√£o de rota com os waypoints reordenados
                    const request = {
                        origin: new google.maps.LatLng(origin.lat, origin.lng),
                        destination: new google.maps.LatLng(origin.lat, origin.lng),
                        waypoints: orderedWaypoints.map(wp => ({
                            location: new google.maps.LatLng(wp.lat, wp.lng),
                            stopover: true
                        })),
                        optimizeWaypoints: false, // N√£o otimizar, j√° est√° na ordem que queremos
                        travelMode: google.maps.TravelMode.DRIVING
                    };
                    
                    // Solicitar a rota
                    directionsService.route(request, function(result, status) {
                        if (status === google.maps.DirectionsStatus.OK) {
                            // Armazenar o caminho otimizado e resumo
                            currentOptimizedPath = {
                                origin: origin,
                                waypoints: waypoints,
                                order: waypointOrder,
                                route: result,
                                method: 'spiral'
                            };
                            
                            // Calcular resumo da rota
                            currentRouteSummary = calculateRouteSummary(result, waypoints);
                            
                            resolve({
                                directions: result,
                                summary: currentRouteSummary,
                                order: waypointOrder,
                                originalWaypoints: waypoints,
                                method: 'spiral'
                            });
                        } else {
                            reject(new Error('Erro no c√°lculo da rota em espiral: ' + status));
                        }
                    });
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Calcular dist√¢ncia usando a f√≥rmula de Haversine
        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raio da terra em km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            const distance = R * c; // Dist√¢ncia em km
            return distance;
        }
        
        // Converter graus para radianos
        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }
        
        // Calcular resumo da rota
        function calculateRouteSummary(directions, waypoints) {
            let totalDistance = 0;
            let totalDuration = 0;
            
            // Somar dist√¢ncias e dura√ß√µes de todas as pernas da rota
            const legs = directions.routes[0].legs;
            legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });
            
            // Converter dist√¢ncia de metros para km
            totalDistance = Math.round(totalDistance / 1000);
            
            // Converter dura√ß√£o de segundos para horas e minutos
            const hours = Math.floor(totalDuration / 3600);
            const minutes = Math.round((totalDuration % 3600) / 60);
            
            // Calcular ped√°gios estimados (dados mockados)
            const estimatedTolls = Math.ceil(totalDistance / 100) * 15;
            
            // Formato do resumo
            return {
                totalDistance: totalDistance,
                totalDuration: totalDuration,
                formattedDistance: totalDistance + ' km',
                formattedDuration: hours + 'h ' + minutes + 'min',
                estimatedTolls: 'R$ ' + estimatedTolls.toFixed(2)
            };
        }
        
        // Renderizar a rota otimizada no mapa
        function renderOptimizedRoute(result) {
            // Mostrar a rota no mapa
            directionsRenderer.setDirections(result.directions);
            
            // M√©todo de otimiza√ß√£o utilizado
            let methodName = "Padr√£o";
            if (result.method === 'nearest') {
                methodName = "Mais pr√≥ximo da origem";
            } else if (result.method === 'spiral') {
                methodName = "Em espiral";
            }
            
            // Atualizar os marcadores para mostrar a sequ√™ncia
            updateMarkersWithSequence(result.originalWaypoints, result.order, result.directions);
            
            // Atualizar o relat√≥rio de rota
            updateRouteReport(result.summary, result.directions, result.originalWaypoints, result.order, methodName);
            
            // Atualizar eventos
            updateEventsList();
            
            // Atualizar restri√ß√µes
            updateRestrictionsList();
        }
        
        // Atualizar marcadores com a sequ√™ncia otimizada
        function updateMarkersWithSequence(waypoints, order, directions) {
            // Remover marcadores existentes
            markers.forEach(marker => {
                marker.setMap(null);
            });
            markers = [];
            
            // Adicionar marcador de origem
            const origin = locations.find(loc => loc.isOrigin);
            const originMarker = new google.maps.Marker({
                position: new google.maps.LatLng(origin.lat, origin.lng),
                map: map,
                label: { text: 'A', color: 'white' },
                title: origin.name,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#ff6600',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 12
                }
            });
            markers.push(originMarker);
            
            // Adicionar marcadores para os pontos de parada na ordem otimizada
            order.forEach((index, i) => {
                const waypoint = waypoints[index];
                const marker = new google.maps.Marker({
                    position: waypoint.location,
                    map: map,
                    label: { text: String(i + 1), color: 'white' },
                    title: waypoint.name,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#1976D2',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2,
                        scale: 12
                    }
                });
                markers.push(marker);
            });
        }
        
        // Atualizar o relat√≥rio de rota
        function updateRouteReport(summary, directions, waypoints, order, methodName) {
            // Atualizar o resumo da rota
            const routeInfo = document.getElementById('route-info');
            routeInfo.innerHTML = `
                <div class="mb-2"><strong>M√©todo de otimiza√ß√£o:</strong> ${methodName}</div>
                <div class="mb-2"><strong>Dist√¢ncia total:</strong> ${summary.formattedDistance}</div>
                <div class="mb-2"><strong>Tempo estimado:</strong> ${summary.formattedDuration}</div>
                <div><strong>Ped√°gios estimados:</strong> ${summary.estimatedTolls}</div>
            `;
            
            // Atualizar a sequ√™ncia de entrega
            const routeSequence = document.getElementById('route-sequence');
            
            // Come√ßar com a origem
            const origin = locations.find(loc => loc.isOrigin);
            let sequenceHTML = `
                <div class="origin-point mb-3">
                    <strong>A.</strong> ${origin.name} (Origem)
                </div>
            `;
            
            // Adicionar cada parada na ordem otimizada
            order.forEach((index, i) => {
                const waypoint = waypoints[index];
                const leg = directions.routes[0].legs[i];
                
                sequenceHTML += `
                    <div class="mb-2">
                        <strong>${i + 1}.</strong> ${waypoint.name} 
                        <span class="text-muted">- ${leg.distance.text}</span>
                    </div>
                `;
            });
            
            routeSequence.innerHTML = sequenceHTML;
            
            // Disparar evento de rota otimizada
            window.dispatchEvent(new Event('route-optimized'));
        }
        
        // Atualizar a lista de cidades com base nos locais
        function updateEventCitiesList() {
            // Extrair cidades dos locais
            const cities = [];
            
            locations.forEach(location => {
                // Tentar extrair a cidade do endere√ßo
                let city = extractCityFromAddress(location.address);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            console.log("Cidades detectadas para eventos:", uniqueCities);
        }
        
        // Extrair cidade de um endere√ßo
        function extractCityFromAddress(address) {
            // Lista de cidades conhecidas para detectar
            const knownCities = [
                'S√£o Paulo', 'Rio de Janeiro', 'Bras√≠lia', 'Salvador', 'Fortaleza',
                'Belo Horizonte', 'Manaus', 'Curitiba', 'Recife', 'Porto Alegre',
                'Bel√©m', 'Goi√¢nia', 'Guarulhos', 'Campinas', 'S√£o Lu√≠s',
                'S√£o Gon√ßalo', 'Macei√≥', 'Duque de Caxias', 'Natal', 'Teresina',
                'Ja√∫', 'Bauru', 'Dois C√≥rregos', 'Araraquara', 'S√£o Carlos'
            ];
            
            // Verificar se alguma cidade conhecida est√° no endere√ßo
            for (const city of knownCities) {
                if (address.includes(city)) {
                    return city;
                }
            }
            
            // Outra tentativa: verificar palavras que come√ßam com mai√∫scula e n√£o s√£o abrevia√ß√µes
            const words = address.split(/[\s,-]+/);
            for (const word of words) {
                if (word.length > 2 && 
                    word === word.charAt(0).toUpperCase() + word.slice(1).toLowerCase() &&
                    !word.match(/^[A-Z]{2,3}$/)) {  // Excluir abrevia√ß√µes como "SP", "RJ"
                    return word;
                }
            }
            
            return null;
        }
        
        // Atualizar a lista de eventos
        function updateEventsList() {
            // Verificar se h√° uma rota otimizada
            if (!currentOptimizedPath) {
                return;
            }
            
            // Extrair cidades da rota otimizada
            const cities = [];
            const allLocations = [currentOptimizedPath.origin, ...currentOptimizedPath.waypoints];
            
            allLocations.forEach(location => {
                // Para waypoints, location √© diferente
                const address = location.address || location.name;
                let city = extractCityFromAddress(address);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            // Obter as datas selecionadas
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            // Obter eventos mockados nas cidades e datas
            const events = getMockEvents(uniqueCities, startDate, endDate);
            
            // Atualizar a interface
            const eventsContainer = document.getElementById('events-list');
            
            if (events.length === 0) {
                eventsContainer.innerHTML = `
                    <p class="text-muted">Nenhum evento encontrado nas cidades da rota para as datas selecionadas.</p>
                `;
                return;
            }
            
            let eventsHTML = '';
            
            events.forEach(event => {
                // Formatar data
                const eventDate = new Date(event.date);
                const formattedDate = eventDate.toLocaleDateString('pt-BR');
                
                eventsHTML += `
                    <div class="event-item">
                        <span class="event-badge">Evento</span>
                        <h5>${event.name}</h5>
                        <p><strong>Cidade:</strong> ${event.city}</p>
                        <p><strong>Data:</strong> ${formattedDate}</p>
                        <p>${event.description}</p>
                    </div>
                `;
            });
            
            eventsContainer.innerHTML = eventsHTML;
        }
        
        // Obter eventos mockados
        function getMockEvents(cities, startDate, endDate) {
            // Verificar se temos datas v√°lidas
            if (!startDate || !endDate) {
                return [];
            }
            
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            // Lista de eventos mockados
            const allEvents = [
                {
                    name: "Feriado Municipal",
                    city: "Dois C√≥rregos",
                    date: "2025-05-13",
                    description: "Feriado municipal em comemora√ß√£o √† funda√ß√£o da cidade."
                },
                {
                    name: "Festival de M√∫sica",
                    city: "Ja√∫",
                    date: "2025-05-15",
                    description: "Festival de m√∫sica com apresenta√ß√µes em pra√ßa p√∫blica."
                },
                {
                    name: "Feira Agropecu√°ria",
                    city: "Bauru",
                    date: "2025-05-17",
                    description: "Exposi√ß√£o agropecu√°ria com demonstra√ß√µes de equipamentos."
                },
                {
                    name: "Congresso de Tecnologia",
                    city: "S√£o Carlos",
                    date: "2025-05-20",
                    description: "Congresso de inova√ß√£o tecnol√≥gica na universidade."
                }
            ];
            
            // Filtrar eventos por cidade e data
            return allEvents.filter(event => {
                const eventDate = new Date(event.date);
                const isInDateRange = eventDate >= start && eventDate <= end;
                const isInCity = cities.includes(event.city);
                
                return isInDateRange && isInCity;
            });
        }
        
        // Atualizar a lista de restri√ß√µes
        function updateRestrictionsList() {
            // Verificar se h√° uma rota otimizada
            if (!currentOptimizedPath) {
                return;
            }
            
            // Extrair cidades da rota otimizada
            const cities = [];
            const allLocations = [currentOptimizedPath.origin, ...currentOptimizedPath.waypoints];
            
            allLocations.forEach(location => {
                // Para waypoints, location √© diferente
                const address = location.address || location.name;
                let city = extractCityFromAddress(address);
                if (city) {
                    cities.push(city);
                }
            });
            
            // Remover duplicatas
            const uniqueCities = [...new Set(cities)];
            
            // Obter o tipo de ve√≠culo selecionado
            const vehicleType = document.getElementById('vehicle-type').value;
            
            // Obter restri√ß√µes mockadas nas cidades para o tipo de ve√≠culo
            const restrictions = getMockRestrictions(uniqueCities, vehicleType);
            
            // Atualizar a interface
            const restrictionsContainer = document.getElementById('restrictions-list');
            
            if (restrictions.length === 0) {
                restrictionsContainer.innerHTML = `
                    <p class="text-muted">Nenhuma restri√ß√£o encontrada para o tipo de ve√≠culo selecionado nas cidades da rota.</p>
                `;
                return;
            }
            
            let restrictionsHTML = '';
            
            restrictions.forEach(restriction => {
                restrictionsHTML += `
                    <div class="restriction-item">
                        <span class="restriction-badge">Restri√ß√£o</span>
                        <h5>${restriction.city}</h5>
                        <p><strong>Tipo:</strong> ${restriction.type}</p>
                        <p><strong>Ve√≠culos afetados:</strong> ${restriction.vehicleTypes.join(', ')}</p>
                        <p><strong>Hor√°rio:</strong> ${restriction.time}</p>
                        <p>${restriction.description}</p>
                    </div>
                `;
            });
            
            restrictionsContainer.innerHTML = restrictionsHTML;
        }
        
        // Obter restri√ß√µes mockadas
        function getMockRestrictions(cities, vehicleType) {
            // Mapear o tipo de ve√≠culo para o nome leg√≠vel
            const vehicleTypeMapping = {
                'truck1': 'Caminh√£o 1 eixo',
                'truck2': 'Caminh√£o 2 eixos',
                'truck3': 'Caminh√£o 3 eixos',
                'truck4': 'Caminh√£o 4 eixos',
                'truck5': 'Caminh√£o 5 eixos',
                'truck6': 'Caminh√£o 6 eixos+'
            };
            
            const selectedVehicleTypeName = vehicleTypeMapping[vehicleType] || vehicleType;
            
            // Lista de restri√ß√µes mockadas
            const allRestrictions = [
                {
                    city: "Dois C√≥rregos",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 07:00 √†s 09:00 e das 17:00 √†s 19:00",
                    description: "Restri√ß√£o de circula√ß√£o no centro da cidade."
                },
                {
                    city: "Ja√∫",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 2 eixos", "Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 08:00 √†s 19:00",
                    description: "Restri√ß√£o de circula√ß√£o no quadril√°tero central."
                },
                {
                    city: "Bauru",
                    type: "Parcial",
                    vehicleTypes: ["Caminh√£o 3 eixos", "Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Todos os dias das 07:00 √†s 20:00",
                    description: "Restri√ß√£o de circula√ß√£o nas avenidas principais."
                },
                {
                    city: "S√£o Carlos",
                    type: "Total",
                    vehicleTypes: ["Caminh√£o 4 eixos", "Caminh√£o 5 eixos", "Caminh√£o 6 eixos+"],
                    time: "Dias √∫teis das 07:00 √†s 19:00",
                    description: "Proibida a circula√ß√£o dentro do per√≠metro urbano."
                }
            ];
            
            // Filtrar restri√ß√µes por cidade e tipo de ve√≠culo
            return allRestrictions.filter(restriction => {
                const isInCity = cities.includes(restriction.city);
                const appliesToVehicle = restriction.vehicleTypes.includes(selectedVehicleTypeName);
                
                return isInCity && appliesToVehicle;
            });
        }
        
        // Carregar dados mockados
        async function fetchMockData() {
            // Carregar a origem (Dois C√≥rregos-SP)
            const originData = {
                id: 0,
                name: "Dois C√≥rregos",
                address: "Dois C√≥rregos, SP, Brasil",
                lat: -22.3636,
                lng: -48.3798,
                isOrigin: true
            };
            
            // Guardar a origem
            locations.push(originData);
            origin = originData;
            
            // Adicionar marcador para a origem
            const originLocation = new google.maps.LatLng(originData.lat, originData.lng);
            addMarker(originLocation, originData.name, originData.id, true);
            
            // Centralizar o mapa na origem
            map.setCenter(originLocation);
            map.setZoom(13);
            
            // Atualizar o campo de origem no formul√°rio
            document.getElementById('origin').value = originData.address;
            
            return true;
        }
    </script>
</body>
</html>